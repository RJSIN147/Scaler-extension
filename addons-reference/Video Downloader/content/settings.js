var su = Object.create;
var Bn = Object.defineProperty;
var lu = Object.getOwnPropertyDescriptor;
var uu = Object.getOwnPropertyNames;
var cu = Object.getPrototypeOf,
  du = Object.prototype.hasOwnProperty;
var _u = (e, n) => () => (n || e((n = { exports: {} }).exports, n), n.exports),
  ye = (e, n) => {
    for (var r in n) Bn(e, r, { get: n[r], enumerable: !0 });
  },
  mu = (e, n, r, i) => {
    if ((n && typeof n == "object") || typeof n == "function")
      for (let t of uu(n))
        !du.call(e, t) &&
          t !== r &&
          Bn(e, t, {
            get: () => n[t],
            enumerable: !(i = lu(n, t)) || i.enumerable,
          });
    return e;
  };
var De = (e, n, r) => (
  (r = e != null ? su(cu(e)) : {}),
  mu(
    n || !e || !e.__esModule
      ? Bn(r, "default", { value: e, enumerable: !0 })
      : r,
    e,
  )
);
var be = _u((Kn, Wa) => {
  (function (e, n) {
    if (typeof define == "function" && define.amd)
      define("webextension-polyfill", ["module"], n);
    else if (typeof Kn < "u") n(Wa);
    else {
      var r = { exports: {} };
      (n(r), (e.browser = r.exports));
    }
  })(
    typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : Kn,
    function (e) {
      "use strict";
      if (
        !(
          globalThis.chrome &&
          globalThis.chrome.runtime &&
          globalThis.chrome.runtime.id
        )
      )
        throw new Error(
          "This script should only be loaded in a browser extension.",
        );
      if (
        globalThis.browser &&
        globalThis.browser.runtime &&
        globalThis.browser.runtime.id
      )
        e.exports = globalThis.browser;
      else {
        let n = "The message port closed before a response was received.",
          r = (i) => {
            let t = {
              alarms: {
                clear: { minArgs: 0, maxArgs: 1 },
                clearAll: { minArgs: 0, maxArgs: 0 },
                get: { minArgs: 0, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
              },
              bookmarks: {
                create: { minArgs: 1, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 1 },
                getChildren: { minArgs: 1, maxArgs: 1 },
                getRecent: { minArgs: 1, maxArgs: 1 },
                getSubTree: { minArgs: 1, maxArgs: 1 },
                getTree: { minArgs: 0, maxArgs: 0 },
                move: { minArgs: 2, maxArgs: 2 },
                remove: { minArgs: 1, maxArgs: 1 },
                removeTree: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              browserAction: {
                disable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 },
                enable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 },
                getBadgeBackgroundColor: { minArgs: 1, maxArgs: 1 },
                getBadgeText: { minArgs: 1, maxArgs: 1 },
                getPopup: { minArgs: 1, maxArgs: 1 },
                getTitle: { minArgs: 1, maxArgs: 1 },
                openPopup: { minArgs: 0, maxArgs: 0 },
                setBadgeBackgroundColor: {
                  minArgs: 1,
                  maxArgs: 1,
                  fallbackToNoCallback: !0,
                },
                setBadgeText: {
                  minArgs: 1,
                  maxArgs: 1,
                  fallbackToNoCallback: !0,
                },
                setIcon: { minArgs: 1, maxArgs: 1 },
                setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              browsingData: {
                remove: { minArgs: 2, maxArgs: 2 },
                removeCache: { minArgs: 1, maxArgs: 1 },
                removeCookies: { minArgs: 1, maxArgs: 1 },
                removeDownloads: { minArgs: 1, maxArgs: 1 },
                removeFormData: { minArgs: 1, maxArgs: 1 },
                removeHistory: { minArgs: 1, maxArgs: 1 },
                removeLocalStorage: { minArgs: 1, maxArgs: 1 },
                removePasswords: { minArgs: 1, maxArgs: 1 },
                removePluginData: { minArgs: 1, maxArgs: 1 },
                settings: { minArgs: 0, maxArgs: 0 },
              },
              commands: { getAll: { minArgs: 0, maxArgs: 0 } },
              contextMenus: {
                remove: { minArgs: 1, maxArgs: 1 },
                removeAll: { minArgs: 0, maxArgs: 0 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              cookies: {
                get: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 1, maxArgs: 1 },
                getAllCookieStores: { minArgs: 0, maxArgs: 0 },
                remove: { minArgs: 1, maxArgs: 1 },
                set: { minArgs: 1, maxArgs: 1 },
              },
              devtools: {
                inspectedWindow: {
                  eval: { minArgs: 1, maxArgs: 2, singleCallbackArg: !1 },
                },
                panels: {
                  create: { minArgs: 3, maxArgs: 3, singleCallbackArg: !0 },
                  elements: { createSidebarPane: { minArgs: 1, maxArgs: 1 } },
                },
              },
              downloads: {
                cancel: { minArgs: 1, maxArgs: 1 },
                download: { minArgs: 1, maxArgs: 1 },
                erase: { minArgs: 1, maxArgs: 1 },
                getFileIcon: { minArgs: 1, maxArgs: 2 },
                open: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                pause: { minArgs: 1, maxArgs: 1 },
                removeFile: { minArgs: 1, maxArgs: 1 },
                resume: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
                show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              extension: {
                isAllowedFileSchemeAccess: { minArgs: 0, maxArgs: 0 },
                isAllowedIncognitoAccess: { minArgs: 0, maxArgs: 0 },
              },
              history: {
                addUrl: { minArgs: 1, maxArgs: 1 },
                deleteAll: { minArgs: 0, maxArgs: 0 },
                deleteRange: { minArgs: 1, maxArgs: 1 },
                deleteUrl: { minArgs: 1, maxArgs: 1 },
                getVisits: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
              },
              i18n: {
                detectLanguage: { minArgs: 1, maxArgs: 1 },
                getAcceptLanguages: { minArgs: 0, maxArgs: 0 },
              },
              identity: { launchWebAuthFlow: { minArgs: 1, maxArgs: 1 } },
              idle: { queryState: { minArgs: 1, maxArgs: 1 } },
              management: {
                get: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
                getSelf: { minArgs: 0, maxArgs: 0 },
                setEnabled: { minArgs: 2, maxArgs: 2 },
                uninstallSelf: { minArgs: 0, maxArgs: 1 },
              },
              notifications: {
                clear: { minArgs: 1, maxArgs: 1 },
                create: { minArgs: 1, maxArgs: 2 },
                getAll: { minArgs: 0, maxArgs: 0 },
                getPermissionLevel: { minArgs: 0, maxArgs: 0 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              pageAction: {
                getPopup: { minArgs: 1, maxArgs: 1 },
                getTitle: { minArgs: 1, maxArgs: 1 },
                hide: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setIcon: { minArgs: 1, maxArgs: 1 },
                setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              permissions: {
                contains: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
                remove: { minArgs: 1, maxArgs: 1 },
                request: { minArgs: 1, maxArgs: 1 },
              },
              runtime: {
                getBackgroundPage: { minArgs: 0, maxArgs: 0 },
                getPlatformInfo: { minArgs: 0, maxArgs: 0 },
                openOptionsPage: { minArgs: 0, maxArgs: 0 },
                requestUpdateCheck: { minArgs: 0, maxArgs: 0 },
                sendMessage: { minArgs: 1, maxArgs: 3 },
                sendNativeMessage: { minArgs: 2, maxArgs: 2 },
                setUninstallURL: { minArgs: 1, maxArgs: 1 },
              },
              sessions: {
                getDevices: { minArgs: 0, maxArgs: 1 },
                getRecentlyClosed: { minArgs: 0, maxArgs: 1 },
                restore: { minArgs: 0, maxArgs: 1 },
              },
              storage: {
                local: {
                  clear: { minArgs: 0, maxArgs: 0 },
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                  remove: { minArgs: 1, maxArgs: 1 },
                  set: { minArgs: 1, maxArgs: 1 },
                },
                managed: {
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                },
                sync: {
                  clear: { minArgs: 0, maxArgs: 0 },
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                  remove: { minArgs: 1, maxArgs: 1 },
                  set: { minArgs: 1, maxArgs: 1 },
                },
              },
              tabs: {
                captureVisibleTab: { minArgs: 0, maxArgs: 2 },
                create: { minArgs: 1, maxArgs: 1 },
                detectLanguage: { minArgs: 0, maxArgs: 1 },
                discard: { minArgs: 0, maxArgs: 1 },
                duplicate: { minArgs: 1, maxArgs: 1 },
                executeScript: { minArgs: 1, maxArgs: 2 },
                get: { minArgs: 1, maxArgs: 1 },
                getCurrent: { minArgs: 0, maxArgs: 0 },
                getZoom: { minArgs: 0, maxArgs: 1 },
                getZoomSettings: { minArgs: 0, maxArgs: 1 },
                goBack: { minArgs: 0, maxArgs: 1 },
                goForward: { minArgs: 0, maxArgs: 1 },
                highlight: { minArgs: 1, maxArgs: 1 },
                insertCSS: { minArgs: 1, maxArgs: 2 },
                move: { minArgs: 2, maxArgs: 2 },
                query: { minArgs: 1, maxArgs: 1 },
                reload: { minArgs: 0, maxArgs: 2 },
                remove: { minArgs: 1, maxArgs: 1 },
                removeCSS: { minArgs: 1, maxArgs: 2 },
                sendMessage: { minArgs: 2, maxArgs: 3 },
                setZoom: { minArgs: 1, maxArgs: 2 },
                setZoomSettings: { minArgs: 1, maxArgs: 2 },
                update: { minArgs: 1, maxArgs: 2 },
              },
              topSites: { get: { minArgs: 0, maxArgs: 0 } },
              webNavigation: {
                getAllFrames: { minArgs: 1, maxArgs: 1 },
                getFrame: { minArgs: 1, maxArgs: 1 },
              },
              webRequest: {
                handlerBehaviorChanged: { minArgs: 0, maxArgs: 0 },
              },
              windows: {
                create: { minArgs: 0, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 2 },
                getAll: { minArgs: 0, maxArgs: 1 },
                getCurrent: { minArgs: 0, maxArgs: 1 },
                getLastFocused: { minArgs: 0, maxArgs: 1 },
                remove: { minArgs: 1, maxArgs: 1 },
                update: { minArgs: 2, maxArgs: 2 },
              },
            };
            if (Object.keys(t).length === 0)
              throw new Error(
                "api-metadata.json has not been included in browser-polyfill",
              );
            class o extends WeakMap {
              constructor(x, A = void 0) {
                (super(A), (this.createItem = x));
              }
              get(x) {
                return (
                  this.has(x) || this.set(x, this.createItem(x)),
                  super.get(x)
                );
              }
            }
            let a = (w) =>
                w && typeof w == "object" && typeof w.then == "function",
              s =
                (w, x) =>
                (...A) => {
                  i.runtime.lastError
                    ? w.reject(new Error(i.runtime.lastError.message))
                    : x.singleCallbackArg ||
                        (A.length <= 1 && x.singleCallbackArg !== !1)
                      ? w.resolve(A[0])
                      : w.resolve(A);
                },
              l = (w) => (w == 1 ? "argument" : "arguments"),
              u = (w, x) =>
                function (O, ...M) {
                  if (M.length < x.minArgs)
                    throw new Error(
                      `Expected at least ${x.minArgs} ${l(x.minArgs)} for ${w}(), got ${M.length}`,
                    );
                  if (M.length > x.maxArgs)
                    throw new Error(
                      `Expected at most ${x.maxArgs} ${l(x.maxArgs)} for ${w}(), got ${M.length}`,
                    );
                  return new Promise((H, J) => {
                    if (x.fallbackToNoCallback)
                      try {
                        O[w](...M, s({ resolve: H, reject: J }, x));
                      } catch (D) {
                        (console.warn(
                          `${w} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,
                          D,
                        ),
                          O[w](...M),
                          (x.fallbackToNoCallback = !1),
                          (x.noCallback = !0),
                          H());
                      }
                    else
                      x.noCallback
                        ? (O[w](...M), H())
                        : O[w](...M, s({ resolve: H, reject: J }, x));
                  });
                },
              m = (w, x, A) =>
                new Proxy(x, {
                  apply(O, M, H) {
                    return A.call(M, w, ...H);
                  },
                }),
              p = Function.call.bind(Object.prototype.hasOwnProperty),
              f = (w, x = {}, A = {}) => {
                let O = Object.create(null),
                  M = {
                    has(J, D) {
                      return D in w || D in O;
                    },
                    get(J, D, Y) {
                      if (D in O) return O[D];
                      if (!(D in w)) return;
                      let F = w[D];
                      if (typeof F == "function")
                        if (typeof x[D] == "function") F = m(w, w[D], x[D]);
                        else if (p(A, D)) {
                          let Pe = u(D, A[D]);
                          F = m(w, w[D], Pe);
                        } else F = F.bind(w);
                      else if (
                        typeof F == "object" &&
                        F !== null &&
                        (p(x, D) || p(A, D))
                      )
                        F = f(F, x[D], A[D]);
                      else if (p(A, "*")) F = f(F, x[D], A["*"]);
                      else
                        return (
                          Object.defineProperty(O, D, {
                            configurable: !0,
                            enumerable: !0,
                            get() {
                              return w[D];
                            },
                            set(Pe) {
                              w[D] = Pe;
                            },
                          }),
                          F
                        );
                      return ((O[D] = F), F);
                    },
                    set(J, D, Y, F) {
                      return (D in O ? (O[D] = Y) : (w[D] = Y), !0);
                    },
                    defineProperty(J, D, Y) {
                      return Reflect.defineProperty(O, D, Y);
                    },
                    deleteProperty(J, D) {
                      return Reflect.deleteProperty(O, D);
                    },
                  },
                  H = Object.create(w);
                return new Proxy(H, M);
              },
              d = (w) => ({
                addListener(x, A, ...O) {
                  x.addListener(w.get(A), ...O);
                },
                hasListener(x, A) {
                  return x.hasListener(w.get(A));
                },
                removeListener(x, A) {
                  x.removeListener(w.get(A));
                },
              }),
              v = new o((w) =>
                typeof w != "function"
                  ? w
                  : function (A) {
                      let O = f(
                        A,
                        {},
                        { getContent: { minArgs: 0, maxArgs: 0 } },
                      );
                      w(O);
                    },
              ),
              k = new o((w) =>
                typeof w != "function"
                  ? w
                  : function (A, O, M) {
                      let H = !1,
                        J,
                        D = new Promise((Fe) => {
                          J = function (te) {
                            ((H = !0), Fe(te));
                          };
                        }),
                        Y;
                      try {
                        Y = w(A, O, J);
                      } catch (Fe) {
                        Y = Promise.reject(Fe);
                      }
                      let F = Y !== !0 && a(Y);
                      if (Y !== !0 && !F && !H) return !1;
                      let Pe = (Fe) => {
                        Fe.then(
                          (te) => {
                            M(te);
                          },
                          (te) => {
                            let Hn;
                            (te &&
                            (te instanceof Error ||
                              typeof te.message == "string")
                              ? (Hn = te.message)
                              : (Hn = "An unexpected error occurred"),
                              M({
                                __mozWebExtensionPolyfillReject__: !0,
                                message: Hn,
                              }));
                          },
                        ).catch((te) => {
                          console.error(
                            "Failed to send onMessage rejected reply",
                            te,
                          );
                        });
                      };
                      return (Pe(F ? Y : D), !0);
                    },
              ),
              P = ({ reject: w, resolve: x }, A) => {
                i.runtime.lastError
                  ? i.runtime.lastError.message === n
                    ? x()
                    : w(new Error(i.runtime.lastError.message))
                  : A && A.__mozWebExtensionPolyfillReject__
                    ? w(new Error(A.message))
                    : x(A);
              },
              j = (w, x, A, ...O) => {
                if (O.length < x.minArgs)
                  throw new Error(
                    `Expected at least ${x.minArgs} ${l(x.minArgs)} for ${w}(), got ${O.length}`,
                  );
                if (O.length > x.maxArgs)
                  throw new Error(
                    `Expected at most ${x.maxArgs} ${l(x.maxArgs)} for ${w}(), got ${O.length}`,
                  );
                return new Promise((M, H) => {
                  let J = P.bind(null, { resolve: M, reject: H });
                  (O.push(J), A.sendMessage(...O));
                });
              },
              S = {
                devtools: { network: { onRequestFinished: d(v) } },
                runtime: {
                  onMessage: d(k),
                  onMessageExternal: d(k),
                  sendMessage: j.bind(null, "sendMessage", {
                    minArgs: 1,
                    maxArgs: 3,
                  }),
                },
                tabs: {
                  sendMessage: j.bind(null, "sendMessage", {
                    minArgs: 2,
                    maxArgs: 3,
                  }),
                },
              },
              z = {
                clear: { minArgs: 1, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 1 },
                set: { minArgs: 1, maxArgs: 1 },
              };
            return (
              (t.privacy = {
                network: { "*": z },
                services: { "*": z },
                websites: { "*": z },
              }),
              f(i, S, t)
            );
          };
        e.exports = r(chrome);
      }
    },
  );
});
var Ha = De(be(), 1);
var X_ = new BroadcastChannel("worker_service");
var Jn = {
  FromInjectedToService: 0,
  FromContentToService: 1,
  FromServiceToWorker: 2,
  FromWorkerToService: 3,
  FromUntrustedInjectedToTrusted: 4,
  FromTrustedInjectedToUntrusted: 5,
  FromServiceToContent: 6,
  FromServiceToInjected: 7,
  FromServiceToService: 8,
};
async function pu(e, n) {
  await Ha.default.runtime.sendMessage({ msg: e, channel: n });
}
async function N(e) {
  let n = Jn.FromContentToService;
  try {
    return (await pu(e, n), !0);
  } catch {
    return !1;
  }
}
function jt(e) {
  e.removeAttribute("hidden");
}
function Ot(e) {
  e.setAttribute("hidden", "true");
}
function Tt(e, n) {
  n ? jt(e) : n === !1 ? Ot(e) : e.hasAttribute("hidden") ? jt(e) : Ot(e);
}
var ee = De(be(), 1);
var pe = "google";
var um = pe != "mozilla",
  je = pe == "mozilla";
var Ba = !1;
var Ka = !1,
  cm = atob(
    "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFOURtQkJNNitRZ1BDRlhJK2dBTFMreXkvdytBaQplMjdMbXRTWmExWjFWMlV1YWt6UmxzTGgrOFZMdE9KekdwVlcyenQ0bUpSMzVFWFRlYUhOQ0g0bEFBPT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==",
  );
var ne = "https://v10.downloadhelper.net:443",
  dm = `${ne}/v2/entitlements/validate`,
  _m = `${ne}/v2/entitlements/activate`,
  mm = `${ne}/v2/entitlements/migrate`,
  pm = `${ne}/v2/reports`,
  Ja = `${ne}/issue`,
  Ya = `${ne}/premium`,
  Ga = `${ne}/manage-subscription`,
  fm = `${ne}/welcome/${pe}`,
  gm = `${ne}/changelog/${pe}`,
  hm = `${ne}/goodbye/${pe}`;
var we = De(be(), 1);
function Yn() {
  je
    ? we.default.tabs.create({
        url: "https://support.mozilla.org/en-US/kb/where-find-and-manage-downloaded-files-firefox#w_change-where-downloads-are-saved",
      })
    : we.default.tabs.create({ url: "chrome://settings/downloads" });
}
function Xa() {
  je
    ? we.default.tabs.create({
        url: "https://support.mozilla.org/en-US/kb/extensions-private-browsing#w_enabling-or-disabling-extensions-in-private-windows",
      })
    : we.default.tabs.create({
        url: `chrome://extensions/?id=${we.default.runtime.id}`,
      });
}
async function Qa() {
  if (Ba) return !1;
  let e = await we.default.runtime.getPlatformInfo();
  return e.os == "linux" || e.os == "openbsd";
}
var Dt = De(be(), 1);
function fe(e) {
  var n = String(e);
  if (n === "[object Object]")
    try {
      n = JSON.stringify(e);
    } catch {}
  return n;
}
var hu = (function () {
    function e() {}
    return (
      (e.prototype.isSome = function () {
        return !1;
      }),
      (e.prototype.isNone = function () {
        return !0;
      }),
      (e.prototype[Symbol.iterator] = function () {
        return {
          next: function () {
            return { done: !0, value: void 0 };
          },
        };
      }),
      (e.prototype.unwrapOr = function (n) {
        return n;
      }),
      (e.prototype.expect = function (n) {
        throw new Error("".concat(n));
      }),
      (e.prototype.unwrap = function () {
        throw new Error("Tried to unwrap None");
      }),
      (e.prototype.map = function (n) {
        return this;
      }),
      (e.prototype.mapOr = function (n, r) {
        return n;
      }),
      (e.prototype.mapOrElse = function (n, r) {
        return n();
      }),
      (e.prototype.or = function (n) {
        return n;
      }),
      (e.prototype.orElse = function (n) {
        return n();
      }),
      (e.prototype.andThen = function (n) {
        return this;
      }),
      (e.prototype.toResult = function (n) {
        return L(n);
      }),
      (e.prototype.toString = function () {
        return "None";
      }),
      (e.prototype.toAsyncOption = function () {
        return new qe(G);
      }),
      e
    );
  })(),
  G = new hu();
Object.freeze(G);
var vu = (function () {
    function e(n) {
      if (!(this instanceof e)) return new e(n);
      this.value = n;
    }
    return (
      (e.prototype.isSome = function () {
        return !0;
      }),
      (e.prototype.isNone = function () {
        return !1;
      }),
      (e.prototype[Symbol.iterator] = function () {
        var n = Object(this.value);
        return Symbol.iterator in n
          ? n[Symbol.iterator]()
          : {
              next: function () {
                return { done: !0, value: void 0 };
              },
            };
      }),
      (e.prototype.unwrapOr = function (n) {
        return this.value;
      }),
      (e.prototype.expect = function (n) {
        return this.value;
      }),
      (e.prototype.unwrap = function () {
        return this.value;
      }),
      (e.prototype.map = function (n) {
        return X(n(this.value));
      }),
      (e.prototype.mapOr = function (n, r) {
        return r(this.value);
      }),
      (e.prototype.mapOrElse = function (n, r) {
        return r(this.value);
      }),
      (e.prototype.or = function (n) {
        return this;
      }),
      (e.prototype.orElse = function (n) {
        return this;
      }),
      (e.prototype.andThen = function (n) {
        return n(this.value);
      }),
      (e.prototype.toResult = function (n) {
        return E(this.value);
      }),
      (e.prototype.toAsyncOption = function () {
        return new qe(this);
      }),
      (e.prototype.safeUnwrap = function () {
        return this.value;
      }),
      (e.prototype.toString = function () {
        return "Some(".concat(fe(this.value), ")");
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })(),
  X = vu,
  Nt;
(function (e) {
  function n() {
    for (var t = [], o = 0; o < arguments.length; o++) t[o] = arguments[o];
    for (var a = [], s = 0, l = t; s < l.length; s++) {
      var u = l[s];
      if (u.isSome()) a.push(u.value);
      else return u;
    }
    return X(a);
  }
  e.all = n;
  function r() {
    for (var t = [], o = 0; o < arguments.length; o++) t[o] = arguments[o];
    for (var a = 0, s = t; a < s.length; a++) {
      var l = s[a];
      if (l.isSome()) return l;
    }
    return G;
  }
  e.any = r;
  function i(t) {
    return t instanceof X || t === G;
  }
  e.isOption = i;
})(Nt || (Nt = {}));
var Oe = function (e, n, r) {
    if (r || arguments.length === 2)
      for (var i = 0, t = n.length, o; i < t; i++)
        (o || !(i in n)) &&
          (o || (o = Array.prototype.slice.call(n, 0, i)), (o[i] = n[i]));
    return e.concat(o || Array.prototype.slice.call(n));
  },
  yu = (function () {
    function e(n) {
      if (!(this instanceof e)) return new e(n);
      this.error = n;
      var r = new Error().stack
        .split(
          `
`,
        )
        .slice(2);
      (r && r.length > 0 && r[0].includes("ErrImpl") && r.shift(),
        (this._stack = r.join(`
`)));
    }
    return (
      (e.prototype.isOk = function () {
        return !1;
      }),
      (e.prototype.isErr = function () {
        return !0;
      }),
      (e.prototype[Symbol.iterator] = function () {
        return {
          next: function () {
            return { done: !0, value: void 0 };
          },
        };
      }),
      (e.prototype.else = function (n) {
        return n;
      }),
      (e.prototype.unwrapOr = function (n) {
        return n;
      }),
      (e.prototype.expect = function (n) {
        throw new Error(
          ""
            .concat(n, " - Error: ")
            .concat(
              fe(this.error),
              `
`,
            )
            .concat(this._stack),
          { cause: this.error },
        );
      }),
      (e.prototype.expectErr = function (n) {
        return this.error;
      }),
      (e.prototype.unwrap = function () {
        throw new Error(
          "Tried to unwrap Error: "
            .concat(
              fe(this.error),
              `
`,
            )
            .concat(this._stack),
          { cause: this.error },
        );
      }),
      (e.prototype.unwrapErr = function () {
        return this.error;
      }),
      (e.prototype.map = function (n) {
        return this;
      }),
      (e.prototype.andThen = function (n) {
        return this;
      }),
      (e.prototype.mapErr = function (n) {
        return new L(n(this.error));
      }),
      (e.prototype.mapOr = function (n, r) {
        return n;
      }),
      (e.prototype.mapOrElse = function (n, r) {
        return n(this.error);
      }),
      (e.prototype.or = function (n) {
        return n;
      }),
      (e.prototype.orElse = function (n) {
        return n(this.error);
      }),
      (e.prototype.toOption = function () {
        return G;
      }),
      (e.prototype.toString = function () {
        return "Err(".concat(fe(this.error), ")");
      }),
      Object.defineProperty(e.prototype, "stack", {
        get: function () {
          return ""
            .concat(
              this,
              `
`,
            )
            .concat(this._stack);
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.toAsyncResult = function () {
        return new We(this);
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })();
var L = yu,
  bu = (function () {
    function e(n) {
      if (!(this instanceof e)) return new e(n);
      this.value = n;
    }
    return (
      (e.prototype.isOk = function () {
        return !0;
      }),
      (e.prototype.isErr = function () {
        return !1;
      }),
      (e.prototype[Symbol.iterator] = function () {
        var n = Object(this.value);
        return Symbol.iterator in n
          ? n[Symbol.iterator]()
          : {
              next: function () {
                return { done: !0, value: void 0 };
              },
            };
      }),
      (e.prototype.else = function (n) {
        return this.value;
      }),
      (e.prototype.unwrapOr = function (n) {
        return this.value;
      }),
      (e.prototype.expect = function (n) {
        return this.value;
      }),
      (e.prototype.expectErr = function (n) {
        throw new Error(n);
      }),
      (e.prototype.unwrap = function () {
        return this.value;
      }),
      (e.prototype.unwrapErr = function () {
        throw new Error("Tried to unwrap Ok: ".concat(fe(this.value)), {
          cause: this.value,
        });
      }),
      (e.prototype.map = function (n) {
        return new E(n(this.value));
      }),
      (e.prototype.andThen = function (n) {
        return n(this.value);
      }),
      (e.prototype.mapErr = function (n) {
        return this;
      }),
      (e.prototype.mapOr = function (n, r) {
        return r(this.value);
      }),
      (e.prototype.mapOrElse = function (n, r) {
        return r(this.value);
      }),
      (e.prototype.or = function (n) {
        return this;
      }),
      (e.prototype.orElse = function (n) {
        return this;
      }),
      (e.prototype.toOption = function () {
        return X(this.value);
      }),
      (e.prototype.safeUnwrap = function () {
        return this.value;
      }),
      (e.prototype.toString = function () {
        return "Ok(".concat(fe(this.value), ")");
      }),
      (e.prototype.toAsyncResult = function () {
        return new We(this);
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })();
var E = bu,
  Et;
(function (e) {
  function n(s) {
    for (var l = [], u = 1; u < arguments.length; u++) l[u - 1] = arguments[u];
    for (
      var m = s === void 0 ? [] : Array.isArray(s) ? s : Oe([s], l, !0),
        p = [],
        f = 0,
        d = m;
      f < d.length;
      f++
    ) {
      var v = d[f];
      if (v.isOk()) p.push(v.value);
      else return v;
    }
    return new E(p);
  }
  e.all = n;
  function r(s) {
    for (var l = [], u = 1; u < arguments.length; u++) l[u - 1] = arguments[u];
    for (
      var m = s === void 0 ? [] : Array.isArray(s) ? s : Oe([s], l, !0),
        p = [],
        f = 0,
        d = m;
      f < d.length;
      f++
    ) {
      var v = d[f];
      if (v.isOk()) return v;
      p.push(v.error);
    }
    return new L(p);
  }
  e.any = r;
  function i(s) {
    try {
      return new E(s());
    } catch (l) {
      return new L(l);
    }
  }
  e.wrap = i;
  function t(s) {
    try {
      return s()
        .then(function (l) {
          return new E(l);
        })
        .catch(function (l) {
          return new L(l);
        });
    } catch (l) {
      return Promise.resolve(new L(l));
    }
  }
  e.wrapAsync = t;
  function o(s) {
    return s.reduce(
      function (l, u) {
        var m = l[0],
          p = l[1];
        return u.isOk()
          ? [Oe(Oe([], m, !0), [u.value], !1), p]
          : [m, Oe(Oe([], p, !0), [u.error], !1)];
      },
      [[], []],
    );
  }
  e.partition = o;
  function a(s) {
    return s instanceof L || s instanceof E;
  }
  e.isResult = a;
})(Et || (Et = {}));
var Ut = function (e, n, r, i) {
    function t(o) {
      return o instanceof r
        ? o
        : new r(function (a) {
            a(o);
          });
    }
    return new (r || (r = Promise))(function (o, a) {
      function s(m) {
        try {
          u(i.next(m));
        } catch (p) {
          a(p);
        }
      }
      function l(m) {
        try {
          u(i.throw(m));
        } catch (p) {
          a(p);
        }
      }
      function u(m) {
        m.done ? o(m.value) : t(m.value).then(s, l);
      }
      u((i = i.apply(e, n || [])).next());
    });
  },
  Zt = function (e, n) {
    var r = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      i,
      t,
      o,
      a;
    return (
      (a = { next: s(0), throw: s(1), return: s(2) }),
      typeof Symbol == "function" &&
        (a[Symbol.iterator] = function () {
          return this;
        }),
      a
    );
    function s(u) {
      return function (m) {
        return l([u, m]);
      };
    }
    function l(u) {
      if (i) throw new TypeError("Generator is already executing.");
      for (; a && ((a = 0), u[0] && (r = 0)), r; )
        try {
          if (
            ((i = 1),
            t &&
              (o =
                u[0] & 2
                  ? t.return
                  : u[0]
                    ? t.throw || ((o = t.return) && o.call(t), 0)
                    : t.next) &&
              !(o = o.call(t, u[1])).done)
          )
            return o;
          switch (((t = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
            case 0:
            case 1:
              o = u;
              break;
            case 4:
              return (r.label++, { value: u[1], done: !1 });
            case 5:
              (r.label++, (t = u[1]), (u = [0]));
              continue;
            case 7:
              ((u = r.ops.pop()), r.trys.pop());
              continue;
            default:
              if (
                ((o = r.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (u[0] === 6 || u[0] === 2))
              ) {
                r = 0;
                continue;
              }
              if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
                r.label = u[1];
                break;
              }
              if (u[0] === 6 && r.label < o[1]) {
                ((r.label = o[1]), (o = u));
                break;
              }
              if (o && r.label < o[2]) {
                ((r.label = o[2]), r.ops.push(u));
                break;
              }
              (o[2] && r.ops.pop(), r.trys.pop());
              continue;
          }
          u = n.call(e, r);
        } catch (m) {
          ((u = [6, m]), (t = 0));
        } finally {
          i = o = 0;
        }
      if (u[0] & 5) throw u[1];
      return { value: u[0] ? u[1] : void 0, done: !0 };
    }
  },
  We = (function () {
    function e(n) {
      this.promise = Promise.resolve(n);
    }
    return (
      (e.prototype.andThen = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Ut(r, void 0, void 0, function () {
            var t;
            return Zt(this, function (o) {
              return i.isErr()
                ? [2, i]
                : ((t = n(i.value)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.map = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Ut(r, void 0, void 0, function () {
            var t;
            return Zt(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isErr() ? [2, i] : ((t = E), [4, n(i.value)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.mapErr = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Ut(r, void 0, void 0, function () {
            var t;
            return Zt(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isOk() ? [2, i] : ((t = L), [4, n(i.error)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.or = function (n) {
        return this.orElse(function () {
          return n;
        });
      }),
      (e.prototype.orElse = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Ut(r, void 0, void 0, function () {
            var t;
            return Zt(this, function (o) {
              return i.isOk()
                ? [2, i]
                : ((t = n(i.error)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.toOption = function () {
        return new qe(
          this.promise.then(function (n) {
            return n.toOption();
          }),
        );
      }),
      (e.prototype.thenInternal = function (n) {
        return new e(this.promise.then(n));
      }),
      e
    );
  })();
var Gn = function (e, n, r, i) {
    function t(o) {
      return o instanceof r
        ? o
        : new r(function (a) {
            a(o);
          });
    }
    return new (r || (r = Promise))(function (o, a) {
      function s(m) {
        try {
          u(i.next(m));
        } catch (p) {
          a(p);
        }
      }
      function l(m) {
        try {
          u(i.throw(m));
        } catch (p) {
          a(p);
        }
      }
      function u(m) {
        m.done ? o(m.value) : t(m.value).then(s, l);
      }
      u((i = i.apply(e, n || [])).next());
    });
  },
  Xn = function (e, n) {
    var r = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      i,
      t,
      o,
      a;
    return (
      (a = { next: s(0), throw: s(1), return: s(2) }),
      typeof Symbol == "function" &&
        (a[Symbol.iterator] = function () {
          return this;
        }),
      a
    );
    function s(u) {
      return function (m) {
        return l([u, m]);
      };
    }
    function l(u) {
      if (i) throw new TypeError("Generator is already executing.");
      for (; a && ((a = 0), u[0] && (r = 0)), r; )
        try {
          if (
            ((i = 1),
            t &&
              (o =
                u[0] & 2
                  ? t.return
                  : u[0]
                    ? t.throw || ((o = t.return) && o.call(t), 0)
                    : t.next) &&
              !(o = o.call(t, u[1])).done)
          )
            return o;
          switch (((t = 0), o && (u = [u[0] & 2, o.value]), u[0])) {
            case 0:
            case 1:
              o = u;
              break;
            case 4:
              return (r.label++, { value: u[1], done: !1 });
            case 5:
              (r.label++, (t = u[1]), (u = [0]));
              continue;
            case 7:
              ((u = r.ops.pop()), r.trys.pop());
              continue;
            default:
              if (
                ((o = r.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (u[0] === 6 || u[0] === 2))
              ) {
                r = 0;
                continue;
              }
              if (u[0] === 3 && (!o || (u[1] > o[0] && u[1] < o[3]))) {
                r.label = u[1];
                break;
              }
              if (u[0] === 6 && r.label < o[1]) {
                ((r.label = o[1]), (o = u));
                break;
              }
              if (o && r.label < o[2]) {
                ((r.label = o[2]), r.ops.push(u));
                break;
              }
              (o[2] && r.ops.pop(), r.trys.pop());
              continue;
          }
          u = n.call(e, r);
        } catch (m) {
          ((u = [6, m]), (t = 0));
        } finally {
          i = o = 0;
        }
      if (u[0] & 5) throw u[1];
      return { value: u[0] ? u[1] : void 0, done: !0 };
    }
  },
  qe = (function () {
    function e(n) {
      this.promise = Promise.resolve(n);
    }
    return (
      (e.prototype.andThen = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Gn(r, void 0, void 0, function () {
            var t;
            return Xn(this, function (o) {
              return i.isNone()
                ? [2, i]
                : ((t = n(i.value)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.map = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Gn(r, void 0, void 0, function () {
            var t;
            return Xn(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isNone() ? [2, i] : ((t = X), [4, n(i.value)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.or = function (n) {
        return this.orElse(function () {
          return n;
        });
      }),
      (e.prototype.orElse = function (n) {
        var r = this;
        return this.thenInternal(function (i) {
          return Gn(r, void 0, void 0, function () {
            var t;
            return Xn(this, function (o) {
              return i.isSome()
                ? [2, i]
                : ((t = n()), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.toResult = function (n) {
        return new We(
          this.promise.then(function (r) {
            return r.toResult(n);
          }),
        );
      }),
      (e.prototype.thenInternal = function (n) {
        return new e(this.promise.then(n));
      }),
      e
    );
  })();
function re(e) {
  if (e.__serde_tag == "primitive") return e.__serde_val;
  if (e.__serde_tag == "object") {
    let n = {};
    for (let [r, i] of Object.entries(e.__serde_val)) {
      let t = i;
      n[r] = re(t);
    }
    return n;
  } else {
    if (e.__serde_tag == "map")
      return new Map(e.__serde_val.map(([n, r]) => [re(n), re(r)]));
    if (e.__serde_tag == "set") return new Set(e.__serde_val.map(re));
    if (e.__serde_tag == "url") return new URL(e.__serde_val);
    if (e.__serde_tag == "array") return e.__serde_val.map(re);
    if (e.__serde_tag == "headers") return new Headers(e.__serde_val);
    if (e.__serde_tag == "regex")
      return new RegExp(e.__serde_val[0], e.__serde_val[1]);
    if (e.__serde_tag == "some") return X(re(e.__serde_val));
    if (e.__serde_tag == "none") return G;
    if (e.__serde_tag == "ok") return E(re(e.__serde_val));
    if (e.__serde_tag == "err") return L(re(e.__serde_val));
    throw new Error("Unreachable");
  }
}
function oe(e) {
  if (typeof e == "string") return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e == "number") return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e == "boolean")
    return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e > "u") return { __serde_tag: "primitive", __serde_val: e };
  if (e == null) return { __serde_tag: "primitive", __serde_val: e };
  if (Array.isArray(e))
    return { __serde_tag: "array", __serde_val: e.map((n) => oe(n)) };
  if (e instanceof URL) return { __serde_tag: "url", __serde_val: e.href };
  if (e instanceof Headers) {
    let n = [];
    return (
      e.forEach((r, i) => {
        n.push([i, r]);
      }),
      { __serde_tag: "headers", __serde_val: n }
    );
  } else {
    if (e instanceof Set)
      return { __serde_tag: "set", __serde_val: [...e.values()].map(oe) };
    if (e instanceof Map)
      return {
        __serde_tag: "map",
        __serde_val: [...e.entries()].map(([n, r]) => [oe(n), oe(r)]),
      };
    if (e instanceof RegExp)
      return { __serde_tag: "regex", __serde_val: [e.source, e.flags] };
    if (Nt.isOption(e))
      return e.isSome()
        ? { __serde_tag: "some", __serde_val: oe(e.value) }
        : { __serde_tag: "none" };
    if (Et.isResult(e))
      return e.isOk()
        ? { __serde_tag: "ok", __serde_val: oe(e.value) }
        : { __serde_tag: "err", __serde_val: oe(e.error) };
    if (typeof e == "object") {
      let n = {};
      for (let [r, i] of Object.entries(e)) n[r] = oe(i);
      return { __serde_tag: "object", __serde_val: n };
    } else throw new Error("Unreachable");
  }
}
var ts = De(be(), 1),
  ju = De(be(), 1);
var Pu = (e, n) => typeof e[n] == "string";
function se(e) {
  try {
    if (Pu(e, "__serializer_tag")) {
      if (e.__serializer_tag === "primitive") return E(e.__serializer_value);
      if (e.__serializer_tag === "regex") {
        let i = new RegExp(e.__serializer_value);
        return E(i);
      } else if (e.__serializer_tag === "array") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = se(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return E(i);
      } else if (e.__serializer_tag === "map") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = se(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return E(new Map(i));
      } else if (e.__serializer_tag === "set") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = se(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return E(new Set(i));
      } else if (e.__serializer_tag === "result_ok") {
        let i = e.__serializer_value,
          t = se(i);
        return t.isErr() ? t : E(E(t.unwrap()));
      } else if (e.__serializer_tag === "result_err") {
        let i = e.__serializer_value,
          t = se(i);
        return t.isErr() ? t : E(L(t.unwrap()));
      } else if (e.__serializer_tag === "option_some") {
        let i = e.__serializer_value,
          t = se(i);
        return t.isErr() ? t : E(X(t.unwrap()));
      } else if (e.__serializer_tag === "option_none") return E(G);
    }
    let n = typeof e;
    if (
      n === "string" ||
      n === "number" ||
      n === "boolean" ||
      n === "undefined" ||
      Array.isArray(e) ||
      e == null
    )
      return L("This object was not serialized with Serialize");
    let r = {};
    for (let i of Object.keys(e))
      if (typeof i == "string") {
        let t = se(e[i]);
        if (t.isErr()) return t;
        r[i] = t.unwrap();
      }
    return E(r);
  } catch {
    return L("Failed to inspect object. Not JSON?");
  }
}
var Rt = "";
function ns(e) {
  if (e == "") return E(Rt);
  (e.startsWith("/") && (e = e.slice(1)),
    e.endsWith("/") && (e = e.slice(0, -1)));
  let n = e.split("/");
  for (let i of n)
    if (Ou(i) != i)
      return L(
        'This not a valid path. Avoid special characters. Use "/" between directories.',
      );
  let r = n.join("/") + "/";
  return r.length > 255 ? L("Path too long") : E(r);
}
function er() {
  return { default_: { max_length: 64, template: "%title" }, rules: [] };
}
function Ou(e) {
  let n = e
    .trim()
    .normalize("NFC")
    .replace(/^\.+/gu, "")
    .replace(/[^\p{L}\p{N}\p{M}\-\s_\.]/gu, "")
    .replace(/-+/gu, "-")
    .replace(/\s+/gu, " ")
    .replace(/^(\s|-)+/gu, "")
    .substring(0, 190)
    .replace(/(\s|-)+$/gu, "");
  return n.length == 0 ? "no-name" : n;
}
async function rs() {
  let e = er(),
    n = await ts.storage.local.get("smartnaming");
  if (typeof n.smartnaming == "object") {
    let r = se(n.smartnaming);
    if (r.isOk())
      for (let [i, t] of r.value.entries())
        if (i == "*")
          ((e.default_.max_length = t.max_length),
            (e.default_.template = t.template));
        else {
          let o = {
            max_length: t.max_length,
            url: i,
            selector: null,
            template: t.template,
          };
          (t.selector && (o.selector = t.selector), e.rules.push(o));
        }
  }
  return e;
}
var g = {};
ye(g, {
  $brand: () => Ct,
  $input: () => fi,
  $output: () => pi,
  NEVER: () => v_,
  ZodAny: () => yl,
  ZodArray: () => kl,
  ZodBase64: () => Sa,
  ZodBase64URL: () => Ia,
  ZodBigInt: () => Pt,
  ZodBigIntFormat: () => Da,
  ZodBoolean: () => At,
  ZodCIDRv4: () => $a,
  ZodCIDRv6: () => za,
  ZodCUID: () => ha,
  ZodCUID2: () => va,
  ZodCatch: () => Vl,
  ZodCustom: () => Ln,
  ZodDate: () => Rn,
  ZodDefault: () => Ul,
  ZodDiscriminatedUnion: () => xl,
  ZodE164: () => Aa,
  ZodEmail: () => ma,
  ZodEmoji: () => fa,
  ZodEnum: () => St,
  ZodError: () => md,
  ZodFile: () => Tl,
  ZodGUID: () => jn,
  ZodIPv4: () => ka,
  ZodIPv6: () => xa,
  ZodISODate: () => In,
  ZodISODateTime: () => Sn,
  ZodISODuration: () => Pn,
  ZodISOTime: () => An,
  ZodIntersection: () => $l,
  ZodIssueCode: () => g_,
  ZodJWT: () => Pa,
  ZodKSUID: () => wa,
  ZodLazy: () => Kl,
  ZodLiteral: () => jl,
  ZodMap: () => Al,
  ZodNaN: () => ql,
  ZodNanoID: () => ga,
  ZodNever: () => bl,
  ZodNonOptional: () => Za,
  ZodNull: () => hl,
  ZodNullable: () => El,
  ZodNumber: () => It,
  ZodNumberFormat: () => Ve,
  ZodObject: () => Cn,
  ZodOptional: () => Ua,
  ZodPipe: () => Ra,
  ZodPrefault: () => Rl,
  ZodPromise: () => Yl,
  ZodReadonly: () => Wl,
  ZodRealError: () => Le,
  ZodRecord: () => Na,
  ZodSet: () => Pl,
  ZodString: () => Un,
  ZodStringFormat: () => Z,
  ZodSuccess: () => Ll,
  ZodSymbol: () => fl,
  ZodTemplateLiteral: () => Bl,
  ZodTransform: () => Nl,
  ZodTuple: () => Sl,
  ZodType: () => I,
  ZodULID: () => ya,
  ZodURL: () => pa,
  ZodUUID: () => me,
  ZodUndefined: () => gl,
  ZodUnion: () => Ta,
  ZodUnknown: () => ja,
  ZodVoid: () => wl,
  ZodXID: () => ba,
  _ZodString: () => _a,
  _default: () => Zl,
  any: () => Hd,
  array: () => Oa,
  base64: () => Td,
  base64url: () => Nd,
  bigint: () => Ld,
  boolean: () => pl,
  catch: () => Fl,
  check: () => Gl,
  cidrv4: () => jd,
  cidrv6: () => Od,
  clone: () => B,
  coerce: () => Ca,
  config: () => C,
  core: () => _e,
  cuid: () => $d,
  cuid2: () => zd,
  custom: () => d_,
  date: () => Kd,
  discriminatedUnion: () => Qd,
  e164: () => Ed,
  email: () => fd,
  emoji: () => kd,
  endsWith: () => vt,
  enum: () => Dl,
  file: () => i_,
  flattenError: () => rt,
  float32: () => Zd,
  float64: () => Rd,
  formatError: () => ot,
  function: () => ea,
  getErrorMap: () => b_,
  globalRegistry: () => ae,
  gt: () => ce,
  gte: () => W,
  guid: () => gd,
  includes: () => gt,
  instanceof: () => __,
  int: () => da,
  int32: () => Cd,
  int64: () => Vd,
  intersection: () => zl,
  ipv4: () => Pd,
  ipv6: () => Dd,
  iso: () => Dn,
  json: () => p_,
  jwt: () => Ud,
  keyof: () => Jd,
  ksuid: () => Ad,
  lazy: () => Jl,
  length: () => Me,
  literal: () => Ol,
  locales: () => ct,
  looseObject: () => Xd,
  lowercase: () => pt,
  lt: () => ue,
  lte: () => Q,
  map: () => n_,
  maxLength: () => Ce,
  maxSize: () => Re,
  mime: () => yt,
  minLength: () => ve,
  minSize: () => Ae,
  multipleOf: () => Ie,
  nan: () => l_,
  nanoid: () => xd,
  nativeEnum: () => o_,
  negative: () => Wi,
  never: () => Zn,
  nonnegative: () => Bi,
  nonoptional: () => Ml,
  nonpositive: () => Hi,
  normalize: () => bt,
  null: () => vl,
  nullable: () => Nn,
  nullish: () => a_,
  number: () => ml,
  object: () => Yd,
  optional: () => Tn,
  overwrite: () => de,
  parse: () => aa,
  parseAsync: () => sa,
  partialRecord: () => t_,
  pipe: () => En,
  positive: () => qi,
  prefault: () => Cl,
  preprocess: () => f_,
  prettifyError: () => mr,
  promise: () => c_,
  property: () => Ki,
  readonly: () => Hl,
  record: () => Il,
  refine: () => Xl,
  regex: () => mt,
  regexes: () => ze,
  registry: () => nn,
  safeParse: () => la,
  safeParseAsync: () => ua,
  set: () => r_,
  setErrorMap: () => y_,
  size: () => _t,
  startsWith: () => ht,
  strictObject: () => Gd,
  string: () => ca,
  stringbool: () => m_,
  success: () => s_,
  superRefine: () => Ql,
  symbol: () => qd,
  templateLiteral: () => u_,
  toJSONSchema: () => ta,
  toLowerCase: () => kt,
  toUpperCase: () => xt,
  transform: () => Ea,
  treeifyError: () => _r,
  trim: () => wt,
  tuple: () => e_,
  uint32: () => Md,
  uint64: () => Fd,
  ulid: () => Sd,
  undefined: () => Wd,
  union: () => Mn,
  unknown: () => On,
  uppercase: () => ft,
  url: () => wd,
  uuid: () => hd,
  uuidv4: () => vd,
  uuidv6: () => yd,
  uuidv7: () => bd,
  void: () => Bd,
  xid: () => Id,
});
var _e = {};
ye(_e, {
  $ZodAny: () => Lo,
  $ZodArray: () => lt,
  $ZodAsyncError: () => ie,
  $ZodBase64: () => Oo,
  $ZodBase64URL: () => To,
  $ZodBigInt: () => Qt,
  $ZodBigIntFormat: () => Zo,
  $ZodBoolean: () => st,
  $ZodCIDRv4: () => Po,
  $ZodCIDRv6: () => Do,
  $ZodCUID: () => vo,
  $ZodCUID2: () => yo,
  $ZodCatch: () => si,
  $ZodCheck: () => R,
  $ZodCheckBigIntFormat: () => Br,
  $ZodCheckEndsWith: () => io,
  $ZodCheckGreaterThan: () => Jt,
  $ZodCheckIncludes: () => ro,
  $ZodCheckLengthEquals: () => Qr,
  $ZodCheckLessThan: () => Kt,
  $ZodCheckLowerCase: () => to,
  $ZodCheckMaxLength: () => Gr,
  $ZodCheckMaxSize: () => Kr,
  $ZodCheckMimeType: () => so,
  $ZodCheckMinLength: () => Xr,
  $ZodCheckMinSize: () => Jr,
  $ZodCheckMultipleOf: () => Wr,
  $ZodCheckNumberFormat: () => Hr,
  $ZodCheckOverwrite: () => lo,
  $ZodCheckProperty: () => ao,
  $ZodCheckRegex: () => eo,
  $ZodCheckSizeEquals: () => Yr,
  $ZodCheckStartsWith: () => oo,
  $ZodCheckStringFormat: () => Ee,
  $ZodCheckUpperCase: () => no,
  $ZodCustom: () => mi,
  $ZodDate: () => qo,
  $ZodDefault: () => ri,
  $ZodDiscriminatedUnion: () => Ho,
  $ZodE164: () => No,
  $ZodEmail: () => po,
  $ZodEmoji: () => go,
  $ZodEnum: () => Go,
  $ZodError: () => nt,
  $ZodFile: () => Qo,
  $ZodFunction: () => zn,
  $ZodGUID: () => _o,
  $ZodIPv4: () => Io,
  $ZodIPv6: () => Ao,
  $ZodISODate: () => $o,
  $ZodISODateTime: () => xo,
  $ZodISODuration: () => So,
  $ZodISOTime: () => zo,
  $ZodIntersection: () => Bo,
  $ZodJWT: () => Eo,
  $ZodKSUID: () => ko,
  $ZodLazy: () => _i,
  $ZodLiteral: () => Xo,
  $ZodMap: () => Jo,
  $ZodNaN: () => li,
  $ZodNanoID: () => ho,
  $ZodNever: () => Vo,
  $ZodNonOptional: () => ii,
  $ZodNull: () => Mo,
  $ZodNullable: () => ni,
  $ZodNumber: () => Xt,
  $ZodNumberFormat: () => Uo,
  $ZodObject: () => Wo,
  $ZodOptional: () => ti,
  $ZodPipe: () => ut,
  $ZodPrefault: () => oi,
  $ZodPromise: () => di,
  $ZodReadonly: () => ui,
  $ZodRealError: () => Ne,
  $ZodRecord: () => Ko,
  $ZodRegistry: () => Ue,
  $ZodSet: () => Yo,
  $ZodString: () => at,
  $ZodStringFormat: () => U,
  $ZodSuccess: () => ai,
  $ZodSymbol: () => Ro,
  $ZodTemplateLiteral: () => ci,
  $ZodTransform: () => ei,
  $ZodTuple: () => Se,
  $ZodType: () => $,
  $ZodULID: () => bo,
  $ZodURL: () => fo,
  $ZodUUID: () => mo,
  $ZodUndefined: () => Co,
  $ZodUnion: () => en,
  $ZodUnknown: () => he,
  $ZodVoid: () => Fo,
  $ZodXID: () => wo,
  $brand: () => Ct,
  $constructor: () => c,
  $input: () => fi,
  $output: () => pi,
  Doc: () => it,
  JSONSchema: () => cl,
  JSONSchemaGenerator: () => zt,
  _any: () => Ri,
  _array: () => $t,
  _base64: () => wn,
  _base64url: () => kn,
  _bigint: () => ji,
  _boolean: () => Pi,
  _catch: () => ad,
  _cidrv4: () => yn,
  _cidrv6: () => bn,
  _coercedBigint: () => Oi,
  _coercedBoolean: () => Di,
  _coercedDate: () => Vi,
  _coercedNumber: () => xi,
  _coercedString: () => hi,
  _cuid: () => _n,
  _cuid2: () => mn,
  _custom: () => Gi,
  _date: () => Li,
  _default: () => rd,
  _discriminatedUnion: () => Hc,
  _e164: () => xn,
  _email: () => rn,
  _emoji: () => cn,
  _endsWith: () => vt,
  _enum: () => Gc,
  _file: () => Yi,
  _float32: () => zi,
  _float64: () => Si,
  _gt: () => ce,
  _gte: () => W,
  _guid: () => dt,
  _includes: () => gt,
  _int: () => $i,
  _int32: () => Ii,
  _int64: () => Ti,
  _intersection: () => Bc,
  _ipv4: () => hn,
  _ipv6: () => vn,
  _isoDate: () => yi,
  _isoDateTime: () => vi,
  _isoDuration: () => wi,
  _isoTime: () => bi,
  _jwt: () => $n,
  _ksuid: () => gn,
  _lazy: () => cd,
  _length: () => Me,
  _literal: () => Qc,
  _lowercase: () => pt,
  _lt: () => ue,
  _lte: () => Q,
  _map: () => Jc,
  _max: () => Q,
  _maxLength: () => Ce,
  _maxSize: () => Re,
  _mime: () => yt,
  _min: () => W,
  _minLength: () => ve,
  _minSize: () => Ae,
  _multipleOf: () => Ie,
  _nan: () => Fi,
  _nanoid: () => dn,
  _nativeEnum: () => Xc,
  _negative: () => Wi,
  _never: () => Ci,
  _nonnegative: () => Bi,
  _nonoptional: () => od,
  _nonpositive: () => Hi,
  _normalize: () => bt,
  _null: () => Zi,
  _nullable: () => nd,
  _number: () => ki,
  _optional: () => td,
  _overwrite: () => de,
  _parse: () => Lt,
  _parseAsync: () => Ft,
  _pipe: () => sd,
  _positive: () => qi,
  _promise: () => dd,
  _property: () => Ki,
  _readonly: () => ld,
  _record: () => Kc,
  _refine: () => Xi,
  _regex: () => mt,
  _safeParse: () => Wt,
  _safeParseAsync: () => Ht,
  _set: () => Yc,
  _size: () => _t,
  _startsWith: () => ht,
  _string: () => gi,
  _stringbool: () => Qi,
  _success: () => id,
  _symbol: () => Ei,
  _templateLiteral: () => ud,
  _toLowerCase: () => kt,
  _toUpperCase: () => xt,
  _transform: () => ed,
  _trim: () => wt,
  _tuple: () => Ji,
  _uint32: () => Ai,
  _uint64: () => Ni,
  _ulid: () => pn,
  _undefined: () => Ui,
  _union: () => Wc,
  _unknown: () => Ze,
  _uppercase: () => ft,
  _url: () => un,
  _uuid: () => on,
  _uuidv4: () => an,
  _uuidv6: () => sn,
  _uuidv7: () => ln,
  _void: () => Mi,
  _xid: () => fn,
  clone: () => B,
  config: () => C,
  flattenError: () => rt,
  formatError: () => ot,
  function: () => ea,
  globalConfig: () => Be,
  globalRegistry: () => ae,
  isValidBase64: () => jo,
  isValidBase64URL: () => xs,
  isValidJWT: () => $s,
  locales: () => ct,
  parse: () => Vt,
  parseAsync: () => qt,
  prettifyError: () => mr,
  regexes: () => ze,
  registry: () => nn,
  safeParse: () => pr,
  safeParseAsync: () => fr,
  toDotPath: () => is,
  toJSONSchema: () => ta,
  treeifyError: () => _r,
  util: () => y,
  version: () => uo,
});
function c(e, n, r) {
  function i(s, l) {
    var u;
    (Object.defineProperty(s, "_zod", { value: s._zod ?? {}, enumerable: !1 }),
      (u = s._zod).traits ?? (u.traits = new Set()),
      s._zod.traits.add(e),
      n(s, l));
    for (let m in a.prototype)
      m in s || Object.defineProperty(s, m, { value: a.prototype[m].bind(s) });
    ((s._zod.constr = a), (s._zod.def = l));
  }
  let t = r?.Parent ?? Object;
  class o extends t {}
  Object.defineProperty(o, "name", { value: e });
  function a(s) {
    var l;
    let u = r?.Parent ? new o() : this;
    (i(u, s), (l = u._zod).deferred ?? (l.deferred = []));
    for (let m of u._zod.deferred) m();
    return u;
  }
  return (
    Object.defineProperty(a, "init", { value: i }),
    Object.defineProperty(a, Symbol.hasInstance, {
      value: (s) =>
        r?.Parent && s instanceof r.Parent ? !0 : s?._zod?.traits?.has(e),
    }),
    Object.defineProperty(a, "name", { value: e }),
    a
  );
}
var Ct = Symbol("zod_brand"),
  ie = class extends Error {
    constructor() {
      super(
        "Encountered Promise during synchronous parse. Use .parseAsync() instead.",
      );
    }
  },
  Be = {};
function C(e) {
  return (e && Object.assign(Be, e), Be);
}
var y = {};
ye(y, {
  BIGINT_FORMAT_RANGES: () => cr,
  Class: () => nr,
  NUMBER_FORMAT_RANGES: () => ur,
  aborted: () => xe,
  allowsEval: () => ar,
  assert: () => Zu,
  assertEqual: () => Tu,
  assertIs: () => Eu,
  assertNever: () => Uu,
  assertNotEqual: () => Nu,
  assignProp: () => ir,
  cached: () => Ye,
  cleanEnum: () => Ju,
  cleanRegex: () => Ge,
  clone: () => B,
  createTransparentProxy: () => Vu,
  defineLazy: () => T,
  esc: () => ke,
  escapeRegex: () => le,
  extend: () => Wu,
  finalizeIssue: () => K,
  floatSafeRemainder: () => or,
  getElementAtPath: () => Ru,
  getEnumValues: () => Je,
  getLengthableOrigin: () => tt,
  getParsedType: () => Lu,
  getSizableOrigin: () => et,
  isObject: () => Te,
  isPlainObject: () => Xe,
  issue: () => dr,
  joinValues: () => _,
  jsonStringifyReplacer: () => rr,
  merge: () => Hu,
  normalizeParams: () => h,
  nullish: () => ge,
  numKeys: () => Mu,
  omit: () => qu,
  optionalKeys: () => lr,
  partial: () => Bu,
  pick: () => Fu,
  prefixIssues: () => q,
  primitiveTypes: () => sr,
  promiseAllObject: () => Cu,
  propertyKeyTypes: () => Qe,
  randomString: () => Mt,
  required: () => Ku,
  stringifyPrimitive: () => b,
  unwrapMessage: () => Ke,
});
function Tu(e) {
  return e;
}
function Nu(e) {
  return e;
}
function Eu(e) {}
function Uu(e) {
  throw new Error();
}
function Zu(e) {}
function Je(e) {
  let n = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e)
    .filter(([i, t]) => n.indexOf(+i) === -1)
    .map(([i, t]) => t);
}
function _(e, n = "|") {
  return e.map((r) => b(r)).join(n);
}
function rr(e, n) {
  return typeof n == "bigint" ? n.toString() : n;
}
function Ye(e) {
  return {
    get value() {
      {
        let r = e();
        return (Object.defineProperty(this, "value", { value: r }), r);
      }
      throw new Error("cached value already set");
    },
  };
}
function ge(e) {
  return e == null;
}
function Ge(e) {
  let n = e.startsWith("^") ? 1 : 0,
    r = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(n, r);
}
function or(e, n) {
  let r = (e.toString().split(".")[1] || "").length,
    i = (n.toString().split(".")[1] || "").length,
    t = r > i ? r : i,
    o = Number.parseInt(e.toFixed(t).replace(".", "")),
    a = Number.parseInt(n.toFixed(t).replace(".", ""));
  return (o % a) / 10 ** t;
}
function T(e, n, r) {
  Object.defineProperty(e, n, {
    get() {
      {
        let t = r();
        return ((e[n] = t), t);
      }
      throw new Error("cached value already set");
    },
    set(t) {
      Object.defineProperty(e, n, { value: t });
    },
    configurable: !0,
  });
}
function ir(e, n, r) {
  Object.defineProperty(e, n, {
    value: r,
    writable: !0,
    enumerable: !0,
    configurable: !0,
  });
}
function Ru(e, n) {
  return n ? n.reduce((r, i) => r?.[i], e) : e;
}
function Cu(e) {
  let n = Object.keys(e),
    r = n.map((i) => e[i]);
  return Promise.all(r).then((i) => {
    let t = {};
    for (let o = 0; o < n.length; o++) t[n[o]] = i[o];
    return t;
  });
}
function Mt(e = 10) {
  let n = "abcdefghijklmnopqrstuvwxyz",
    r = "";
  for (let i = 0; i < e; i++) r += n[Math.floor(Math.random() * n.length)];
  return r;
}
function ke(e) {
  return JSON.stringify(e);
}
function Te(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var ar = Ye(() => {
  try {
    let e = Function;
    return (new e(""), !0);
  } catch {
    return !1;
  }
});
function Xe(e) {
  if (Te(e) === !1) return !1;
  let n = e.constructor;
  if (n === void 0) return !0;
  let r = n.prototype;
  return !(
    Te(r) === !1 ||
    Object.prototype.hasOwnProperty.call(r, "isPrototypeOf") === !1
  );
}
function Mu(e) {
  let n = 0;
  for (let r in e) Object.prototype.hasOwnProperty.call(e, r) && n++;
  return n;
}
var Lu = (e) => {
    let n = typeof e;
    switch (n) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(e) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        return Array.isArray(e)
          ? "array"
          : e === null
            ? "null"
            : e.then &&
                typeof e.then == "function" &&
                e.catch &&
                typeof e.catch == "function"
              ? "promise"
              : typeof Map < "u" && e instanceof Map
                ? "map"
                : typeof Set < "u" && e instanceof Set
                  ? "set"
                  : typeof Date < "u" && e instanceof Date
                    ? "date"
                    : typeof File < "u" && e instanceof File
                      ? "file"
                      : "object";
      default:
        throw new Error(`Unknown data type: ${n}`);
    }
  },
  Qe = new Set(["string", "number", "symbol"]),
  sr = new Set([
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol",
    "undefined",
  ]);
function le(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function B(e, n, r) {
  let i = new e._zod.constr(n ?? e._zod.def);
  return ((!n || r?.parent) && (i._zod.parent = e), i);
}
function h(e) {
  let n = e;
  if (!n) return {};
  if (typeof n == "string") return { error: () => n };
  if (n?.message !== void 0) {
    if (n?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    n.error = n.message;
  }
  return (
    delete n.message,
    typeof n.error == "string" ? { ...n, error: () => n.error } : n
  );
}
function Vu(e) {
  let n;
  return new Proxy(
    {},
    {
      get(r, i, t) {
        return (n ?? (n = e()), Reflect.get(n, i, t));
      },
      set(r, i, t, o) {
        return (n ?? (n = e()), Reflect.set(n, i, t, o));
      },
      has(r, i) {
        return (n ?? (n = e()), Reflect.has(n, i));
      },
      deleteProperty(r, i) {
        return (n ?? (n = e()), Reflect.deleteProperty(n, i));
      },
      ownKeys(r) {
        return (n ?? (n = e()), Reflect.ownKeys(n));
      },
      getOwnPropertyDescriptor(r, i) {
        return (n ?? (n = e()), Reflect.getOwnPropertyDescriptor(n, i));
      },
      defineProperty(r, i, t) {
        return (n ?? (n = e()), Reflect.defineProperty(n, i, t));
      },
    },
  );
}
function b(e) {
  return typeof e == "bigint"
    ? e.toString() + "n"
    : typeof e == "string"
      ? `"${e}"`
      : `${e}`;
}
function lr(e) {
  return Object.keys(e).filter(
    (n) => e[n]._zod.optin === "optional" && e[n]._zod.optout === "optional",
  );
}
var ur = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  },
  cr = {
    int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
    uint64: [BigInt(0), BigInt("18446744073709551615")],
  };
function Fu(e, n) {
  let r = {},
    i = e._zod.def;
  for (let t in n) {
    if (!(t in i.shape)) throw new Error(`Unrecognized key: "${t}"`);
    n[t] && (r[t] = i.shape[t]);
  }
  return B(e, { ...e._zod.def, shape: r, checks: [] });
}
function qu(e, n) {
  let r = { ...e._zod.def.shape },
    i = e._zod.def;
  for (let t in n) {
    if (!(t in i.shape)) throw new Error(`Unrecognized key: "${t}"`);
    n[t] && delete r[t];
  }
  return B(e, { ...e._zod.def, shape: r, checks: [] });
}
function Wu(e, n) {
  let r = {
    ...e._zod.def,
    get shape() {
      let i = { ...e._zod.def.shape, ...n };
      return (ir(this, "shape", i), i);
    },
    checks: [],
  };
  return B(e, r);
}
function Hu(e, n) {
  return B(e, {
    ...e._zod.def,
    get shape() {
      let r = { ...e._zod.def.shape, ...n._zod.def.shape };
      return (ir(this, "shape", r), r);
    },
    catchall: n._zod.def.catchall,
    checks: [],
  });
}
function Bu(e, n, r) {
  let i = n._zod.def.shape,
    t = { ...i };
  if (r)
    for (let o in r) {
      if (!(o in i)) throw new Error(`Unrecognized key: "${o}"`);
      r[o] && (t[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o]);
    }
  else
    for (let o in i)
      t[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o];
  return B(n, { ...n._zod.def, shape: t, checks: [] });
}
function Ku(e, n, r) {
  let i = n._zod.def.shape,
    t = { ...i };
  if (r)
    for (let o in r) {
      if (!(o in t)) throw new Error(`Unrecognized key: "${o}"`);
      r[o] && (t[o] = new e({ type: "nonoptional", innerType: i[o] }));
    }
  else for (let o in i) t[o] = new e({ type: "nonoptional", innerType: i[o] });
  return B(n, { ...n._zod.def, shape: t, checks: [] });
}
function xe(e, n = 0) {
  for (let r = n; r < e.issues.length; r++)
    if (e.issues[r].continue !== !0) return !0;
  return !1;
}
function q(e, n) {
  return n.map((r) => {
    var i;
    return ((i = r).path ?? (i.path = []), r.path.unshift(e), r);
  });
}
function Ke(e) {
  return typeof e == "string" ? e : e?.message;
}
function K(e, n, r) {
  let i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    let t =
      Ke(e.inst?._zod.def?.error?.(e)) ??
      Ke(n?.error?.(e)) ??
      Ke(r.customError?.(e)) ??
      Ke(r.localeError?.(e)) ??
      "Invalid input";
    i.message = t;
  }
  return (
    delete i.inst,
    delete i.continue,
    n?.reportInput || delete i.input,
    i
  );
}
function et(e) {
  return e instanceof Set
    ? "set"
    : e instanceof Map
      ? "map"
      : e instanceof File
        ? "file"
        : "unknown";
}
function tt(e) {
  return Array.isArray(e)
    ? "array"
    : typeof e == "string"
      ? "string"
      : "unknown";
}
function dr(...e) {
  let [n, r, i] = e;
  return typeof n == "string"
    ? { message: n, code: "custom", input: r, inst: i }
    : { ...n };
}
function Ju(e) {
  return Object.entries(e)
    .filter(([n, r]) => Number.isNaN(Number.parseInt(n, 10)))
    .map((n) => n[1]);
}
var nr = class {
  constructor(...n) {}
};
var os = (e, n) => {
    ((e.name = "$ZodError"),
      Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }),
      Object.defineProperty(e, "issues", { value: n, enumerable: !1 }),
      Object.defineProperty(e, "message", {
        get() {
          return JSON.stringify(n, rr, 2);
        },
        enumerable: !0,
      }));
  },
  nt = c("$ZodError", os),
  Ne = c("$ZodError", os, { Parent: Error });
function rt(e, n = (r) => r.message) {
  let r = {},
    i = [];
  for (let t of e.issues)
    t.path.length > 0
      ? ((r[t.path[0]] = r[t.path[0]] || []), r[t.path[0]].push(n(t)))
      : i.push(n(t));
  return { formErrors: i, fieldErrors: r };
}
function ot(e, n) {
  let r =
      n ||
      function (o) {
        return o.message;
      },
    i = { _errors: [] },
    t = (o) => {
      for (let a of o.issues)
        if (a.code === "invalid_union" && a.errors.length)
          a.errors.map((s) => t({ issues: s }));
        else if (a.code === "invalid_key") t({ issues: a.issues });
        else if (a.code === "invalid_element") t({ issues: a.issues });
        else if (a.path.length === 0) i._errors.push(r(a));
        else {
          let s = i,
            l = 0;
          for (; l < a.path.length; ) {
            let u = a.path[l];
            (l === a.path.length - 1
              ? ((s[u] = s[u] || { _errors: [] }), s[u]._errors.push(r(a)))
              : (s[u] = s[u] || { _errors: [] }),
              (s = s[u]),
              l++);
          }
        }
    };
  return (t(e), i);
}
function _r(e, n) {
  let r =
      n ||
      function (o) {
        return o.message;
      },
    i = { errors: [] },
    t = (o, a = []) => {
      var s, l;
      for (let u of o.issues)
        if (u.code === "invalid_union" && u.errors.length)
          u.errors.map((m) => t({ issues: m }, u.path));
        else if (u.code === "invalid_key") t({ issues: u.issues }, u.path);
        else if (u.code === "invalid_element") t({ issues: u.issues }, u.path);
        else {
          let m = [...a, ...u.path];
          if (m.length === 0) {
            i.errors.push(r(u));
            continue;
          }
          let p = i,
            f = 0;
          for (; f < m.length; ) {
            let d = m[f],
              v = f === m.length - 1;
            (typeof d == "string"
              ? (p.properties ?? (p.properties = {}),
                (s = p.properties)[d] ?? (s[d] = { errors: [] }),
                (p = p.properties[d]))
              : (p.items ?? (p.items = []),
                (l = p.items)[d] ?? (l[d] = { errors: [] }),
                (p = p.items[d])),
              v && p.errors.push(r(u)),
              f++);
          }
        }
    };
  return (t(e), i);
}
function is(e) {
  let n = [];
  for (let r of e)
    typeof r == "number"
      ? n.push(`[${r}]`)
      : typeof r == "symbol"
        ? n.push(`[${JSON.stringify(String(r))}]`)
        : /[^\w$]/.test(r)
          ? n.push(`[${JSON.stringify(r)}]`)
          : (n.length && n.push("."), n.push(r));
  return n.join("");
}
function mr(e) {
  let n = [],
    r = [...e.issues].sort((i, t) => i.path.length - t.path.length);
  for (let i of r)
    (n.push(`\u2716 ${i.message}`),
      i.path?.length && n.push(`  \u2192 at ${is(i.path)}`));
  return n.join(`
`);
}
var Lt = (e) => (n, r, i, t) => {
    let o = i ? Object.assign(i, { async: !1 }) : { async: !1 },
      a = n._zod.run({ value: r, issues: [] }, o);
    if (a instanceof Promise) throw new ie();
    if (a.issues.length) {
      let s = new (t?.Err ?? e)(a.issues.map((l) => K(l, o, C())));
      throw (Error.captureStackTrace(s, t?.callee), s);
    }
    return a.value;
  },
  Vt = Lt(Ne),
  Ft = (e) => async (n, r, i, t) => {
    let o = i ? Object.assign(i, { async: !0 }) : { async: !0 },
      a = n._zod.run({ value: r, issues: [] }, o);
    if ((a instanceof Promise && (a = await a), a.issues.length)) {
      let s = new (t?.Err ?? e)(a.issues.map((l) => K(l, o, C())));
      throw (Error.captureStackTrace(s, t?.callee), s);
    }
    return a.value;
  },
  qt = Ft(Ne),
  Wt = (e) => (n, r, i) => {
    let t = i ? { ...i, async: !1 } : { async: !1 },
      o = n._zod.run({ value: r, issues: [] }, t);
    if (o instanceof Promise) throw new ie();
    return o.issues.length
      ? { success: !1, error: new (e ?? nt)(o.issues.map((a) => K(a, t, C()))) }
      : { success: !0, data: o.value };
  },
  pr = Wt(Ne),
  Ht = (e) => async (n, r, i) => {
    let t = i ? Object.assign(i, { async: !0 }) : { async: !0 },
      o = n._zod.run({ value: r, issues: [] }, t);
    return (
      o instanceof Promise && (o = await o),
      o.issues.length
        ? { success: !1, error: new e(o.issues.map((a) => K(a, t, C()))) }
        : { success: !0, data: o.value }
    );
  },
  fr = Ht(Ne);
var ze = {};
ye(ze, {
  _emoji: () => as,
  base64: () => Dr,
  base64url: () => Bt,
  bigint: () => Zr,
  boolean: () => Mr,
  browserEmail: () => oc,
  cidrv4: () => Ar,
  cidrv6: () => Pr,
  cuid: () => gr,
  cuid2: () => hr,
  date: () => Tr,
  datetime: () => Er,
  domain: () => ic,
  duration: () => kr,
  e164: () => Or,
  email: () => $r,
  emoji: () => zr,
  extendedDuration: () => Gu,
  guid: () => xr,
  hostname: () => jr,
  html5Email: () => tc,
  integer: () => Rr,
  ipv4: () => Sr,
  ipv6: () => Ir,
  ksuid: () => br,
  lowercase: () => Fr,
  nanoid: () => wr,
  null: () => Lr,
  number: () => Cr,
  rfc5322Email: () => nc,
  string: () => Ur,
  time: () => Nr,
  ulid: () => vr,
  undefined: () => Vr,
  unicodeEmail: () => rc,
  uppercase: () => qr,
  uuid: () => $e,
  uuid4: () => Xu,
  uuid6: () => Qu,
  uuid7: () => ec,
  xid: () => yr,
});
var gr = /^[cC][^\s-]{8,}$/,
  hr = /^[0-9a-z]+$/,
  vr = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
  yr = /^[0-9a-vA-V]{20}$/,
  br = /^[A-Za-z0-9]{27}$/,
  wr = /^[a-zA-Z0-9_-]{21}$/,
  kr =
    /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
  Gu =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  xr =
    /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
  $e = (e) =>
    e
      ? new RegExp(
          `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
        )
      : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/,
  Xu = $e(4),
  Qu = $e(6),
  ec = $e(7),
  $r =
    /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
  tc =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  nc =
    /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  rc = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
  oc =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  as = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function zr() {
  return new RegExp(as, "u");
}
var Sr =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  Ir =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
  Ar =
    /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
  Pr =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  Dr =
    /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
  Bt = /^[A-Za-z0-9_-]*$/,
  jr = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
  ic = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
  Or = /^\+(?:[0-9]){6,14}[0-9]$/,
  ss =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Tr = new RegExp(`^${ss}$`);
function ls(e) {
  let n = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return (
    e.precision
      ? (n = `${n}\\.\\d{${e.precision}}`)
      : e.precision == null && (n = `${n}(\\.\\d+)?`),
    n
  );
}
function Nr(e) {
  return new RegExp(`^${ls(e)}$`);
}
function Er(e) {
  let n = `${ss}T${ls(e)}`,
    r = [];
  return (
    r.push(e.local ? "Z?" : "Z"),
    e.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    (n = `${n}(${r.join("|")})`),
    new RegExp(`^${n}$`)
  );
}
var Ur = (e) => {
    let n = e
      ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}`
      : "[\\s\\S]*";
    return new RegExp(`^${n}$`);
  },
  Zr = /^\d+n?$/,
  Rr = /^\d+$/,
  Cr = /^-?\d+(?:\.\d+)?/i,
  Mr = /true|false/i,
  Lr = /null/i;
var Vr = /undefined/i;
var Fr = /^[^A-Z]*$/,
  qr = /^[^a-z]*$/;
var R = c("$ZodCheck", (e, n) => {
    var r;
    (e._zod ?? (e._zod = {}),
      (e._zod.def = n),
      (r = e._zod).onattach ?? (r.onattach = []));
  }),
  cs = { number: "number", bigint: "bigint", object: "date" },
  Kt = c("$ZodCheckLessThan", (e, n) => {
    R.init(e, n);
    let r = cs[typeof n.value];
    (e._zod.onattach.push((i) => {
      let t = i._zod.bag,
        o =
          (n.inclusive ? t.maximum : t.exclusiveMaximum) ??
          Number.POSITIVE_INFINITY;
      n.value < o &&
        (n.inclusive ? (t.maximum = n.value) : (t.exclusiveMaximum = n.value));
    }),
      (e._zod.check = (i) => {
        (n.inclusive ? i.value <= n.value : i.value < n.value) ||
          i.issues.push({
            origin: r,
            code: "too_big",
            maximum: n.value,
            input: i.value,
            inclusive: n.inclusive,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Jt = c("$ZodCheckGreaterThan", (e, n) => {
    R.init(e, n);
    let r = cs[typeof n.value];
    (e._zod.onattach.push((i) => {
      let t = i._zod.bag,
        o =
          (n.inclusive ? t.minimum : t.exclusiveMinimum) ??
          Number.NEGATIVE_INFINITY;
      n.value > o &&
        (n.inclusive ? (t.minimum = n.value) : (t.exclusiveMinimum = n.value));
    }),
      (e._zod.check = (i) => {
        (n.inclusive ? i.value >= n.value : i.value > n.value) ||
          i.issues.push({
            origin: r,
            code: "too_small",
            minimum: n.value,
            input: i.value,
            inclusive: n.inclusive,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Wr = c("$ZodCheckMultipleOf", (e, n) => {
    (R.init(e, n),
      e._zod.onattach.push((r) => {
        var i;
        (i = r._zod.bag).multipleOf ?? (i.multipleOf = n.value);
      }),
      (e._zod.check = (r) => {
        if (typeof r.value != typeof n.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        (typeof r.value == "bigint"
          ? r.value % n.value === BigInt(0)
          : or(r.value, n.value) === 0) ||
          r.issues.push({
            origin: typeof r.value,
            code: "not_multiple_of",
            divisor: n.value,
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Hr = c("$ZodCheckNumberFormat", (e, n) => {
    (R.init(e, n), (n.format = n.format || "float64"));
    let r = n.format?.includes("int"),
      i = r ? "int" : "number",
      [t, o] = ur[n.format];
    (e._zod.onattach.push((a) => {
      let s = a._zod.bag;
      ((s.format = n.format),
        (s.minimum = t),
        (s.maximum = o),
        r && (s.pattern = Rr));
    }),
      (e._zod.check = (a) => {
        let s = a.value;
        if (r) {
          if (!Number.isInteger(s)) {
            a.issues.push({
              expected: i,
              format: n.format,
              code: "invalid_type",
              input: s,
              inst: e,
            });
            return;
          }
          if (!Number.isSafeInteger(s)) {
            s > 0
              ? a.issues.push({
                  input: s,
                  code: "too_big",
                  maximum: Number.MAX_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: i,
                  continue: !n.abort,
                })
              : a.issues.push({
                  input: s,
                  code: "too_small",
                  minimum: Number.MIN_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: i,
                  continue: !n.abort,
                });
            return;
          }
        }
        (s < t &&
          a.issues.push({
            origin: "number",
            input: s,
            code: "too_small",
            minimum: t,
            inclusive: !0,
            inst: e,
            continue: !n.abort,
          }),
          s > o &&
            a.issues.push({
              origin: "number",
              input: s,
              code: "too_big",
              maximum: o,
              inst: e,
            }));
      }));
  }),
  Br = c("$ZodCheckBigIntFormat", (e, n) => {
    R.init(e, n);
    let [r, i] = cr[n.format];
    (e._zod.onattach.push((t) => {
      let o = t._zod.bag;
      ((o.format = n.format), (o.minimum = r), (o.maximum = i));
    }),
      (e._zod.check = (t) => {
        let o = t.value;
        (o < r &&
          t.issues.push({
            origin: "bigint",
            input: o,
            code: "too_small",
            minimum: r,
            inclusive: !0,
            inst: e,
            continue: !n.abort,
          }),
          o > i &&
            t.issues.push({
              origin: "bigint",
              input: o,
              code: "too_big",
              maximum: i,
              inst: e,
            }));
      }));
  }),
  Kr = c("$ZodCheckMaxSize", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        n.maximum < i && (r._zod.bag.maximum = n.maximum);
      }),
      (e._zod.check = (r) => {
        let i = r.value;
        i.size <= n.maximum ||
          r.issues.push({
            origin: et(i),
            code: "too_big",
            maximum: n.maximum,
            input: i,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Jr = c("$ZodCheckMinSize", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        n.minimum > i && (r._zod.bag.minimum = n.minimum);
      }),
      (e._zod.check = (r) => {
        let i = r.value;
        i.size >= n.minimum ||
          r.issues.push({
            origin: et(i),
            code: "too_small",
            minimum: n.minimum,
            input: i,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Yr = c("$ZodCheckSizeEquals", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag;
        ((i.minimum = n.size), (i.maximum = n.size), (i.size = n.size));
      }),
      (e._zod.check = (r) => {
        let i = r.value,
          t = i.size;
        if (t === n.size) return;
        let o = t > n.size;
        r.issues.push({
          origin: et(i),
          ...(o
            ? { code: "too_big", maximum: n.size }
            : { code: "too_small", minimum: n.size }),
          input: r.value,
          inst: e,
          continue: !n.abort,
        });
      }));
  }),
  Gr = c("$ZodCheckMaxLength", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        n.maximum < i && (r._zod.bag.maximum = n.maximum);
      }),
      (e._zod.check = (r) => {
        let i = r.value;
        if (i.length <= n.maximum) return;
        let o = tt(i);
        r.issues.push({
          origin: o,
          code: "too_big",
          maximum: n.maximum,
          inclusive: !0,
          input: i,
          inst: e,
          continue: !n.abort,
        });
      }));
  }),
  Xr = c("$ZodCheckMinLength", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        n.minimum > i && (r._zod.bag.minimum = n.minimum);
      }),
      (e._zod.check = (r) => {
        let i = r.value;
        if (i.length >= n.minimum) return;
        let o = tt(i);
        r.issues.push({
          origin: o,
          code: "too_small",
          minimum: n.minimum,
          inclusive: !0,
          input: i,
          inst: e,
          continue: !n.abort,
        });
      }));
  }),
  Qr = c("$ZodCheckLengthEquals", (e, n) => {
    (R.init(e, n),
      (e._zod.when = (r) => {
        let i = r.value;
        return !ge(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag;
        ((i.minimum = n.length), (i.maximum = n.length), (i.length = n.length));
      }),
      (e._zod.check = (r) => {
        let i = r.value,
          t = i.length;
        if (t === n.length) return;
        let o = tt(i),
          a = t > n.length;
        r.issues.push({
          origin: o,
          ...(a
            ? { code: "too_big", maximum: n.length }
            : { code: "too_small", minimum: n.length }),
          input: r.value,
          inst: e,
          continue: !n.abort,
        });
      }));
  }),
  Ee = c("$ZodCheckStringFormat", (e, n) => {
    var r;
    (R.init(e, n),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        ((t.format = n.format),
          n.pattern &&
            (t.patterns ?? (t.patterns = new Set()),
            t.patterns.add(n.pattern)));
      }),
      (r = e._zod).check ??
        (r.check = (i) => {
          if (!n.pattern) throw new Error("Not implemented.");
          ((n.pattern.lastIndex = 0),
            !n.pattern.test(i.value) &&
              i.issues.push({
                origin: "string",
                code: "invalid_format",
                format: n.format,
                input: i.value,
                ...(n.pattern ? { pattern: n.pattern.toString() } : {}),
                inst: e,
                continue: !n.abort,
              }));
        }));
  }),
  eo = c("$ZodCheckRegex", (e, n) => {
    (Ee.init(e, n),
      (e._zod.check = (r) => {
        ((n.pattern.lastIndex = 0),
          !n.pattern.test(r.value) &&
            r.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: r.value,
              pattern: n.pattern.toString(),
              inst: e,
              continue: !n.abort,
            }));
      }));
  }),
  to = c("$ZodCheckLowerCase", (e, n) => {
    (n.pattern ?? (n.pattern = Fr), Ee.init(e, n));
  }),
  no = c("$ZodCheckUpperCase", (e, n) => {
    (n.pattern ?? (n.pattern = qr), Ee.init(e, n));
  }),
  ro = c("$ZodCheckIncludes", (e, n) => {
    R.init(e, n);
    let r = le(n.includes),
      i = new RegExp(
        typeof n.position == "number" ? `^.{${n.position}}${r}` : r,
      );
    ((n.pattern = i),
      e._zod.onattach.push((t) => {
        let o = t._zod.bag;
        (o.patterns ?? (o.patterns = new Set()), o.patterns.add(i));
      }),
      (e._zod.check = (t) => {
        t.value.includes(n.includes, n.position) ||
          t.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: n.includes,
            input: t.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  oo = c("$ZodCheckStartsWith", (e, n) => {
    R.init(e, n);
    let r = new RegExp(`^${le(n.prefix)}.*`);
    (n.pattern ?? (n.pattern = r),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        (t.patterns ?? (t.patterns = new Set()), t.patterns.add(r));
      }),
      (e._zod.check = (i) => {
        i.value.startsWith(n.prefix) ||
          i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: n.prefix,
            input: i.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  io = c("$ZodCheckEndsWith", (e, n) => {
    R.init(e, n);
    let r = new RegExp(`.*${le(n.suffix)}$`);
    (n.pattern ?? (n.pattern = r),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        (t.patterns ?? (t.patterns = new Set()), t.patterns.add(r));
      }),
      (e._zod.check = (i) => {
        i.value.endsWith(n.suffix) ||
          i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: n.suffix,
            input: i.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  });
function us(e, n, r) {
  e.issues.length && n.issues.push(...q(r, e.issues));
}
var ao = c("$ZodCheckProperty", (e, n) => {
    (R.init(e, n),
      (e._zod.check = (r) => {
        let i = n.schema._zod.run(
          { value: r.value[n.property], issues: [] },
          {},
        );
        if (i instanceof Promise) return i.then((t) => us(t, r, n.property));
        us(i, r, n.property);
      }));
  }),
  so = c("$ZodCheckMimeType", (e, n) => {
    R.init(e, n);
    let r = new Set(n.mime);
    (e._zod.onattach.push((i) => {
      i._zod.bag.mime = n.mime;
    }),
      (e._zod.check = (i) => {
        r.has(i.value.type) ||
          i.issues.push({
            code: "invalid_value",
            values: n.mime,
            input: i.value.type,
            path: ["type"],
            inst: e,
          });
      }));
  }),
  lo = c("$ZodCheckOverwrite", (e, n) => {
    (R.init(e, n),
      (e._zod.check = (r) => {
        r.value = n.tx(r.value);
      }));
  });
var it = class {
  constructor(n = []) {
    ((this.content = []), (this.indent = 0), this && (this.args = n));
  }
  indented(n) {
    ((this.indent += 1), n(this), (this.indent -= 1));
  }
  write(n) {
    if (typeof n == "function") {
      (n(this, { execution: "sync" }), n(this, { execution: "async" }));
      return;
    }
    let i = n
        .split(
          `
`,
        )
        .filter((a) => a),
      t = Math.min(...i.map((a) => a.length - a.trimStart().length)),
      o = i.map((a) => a.slice(t)).map((a) => " ".repeat(this.indent * 2) + a);
    for (let a of o) this.content.push(a);
  }
  compile() {
    let n = Function,
      r = this?.args,
      t = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new n(
      ...r,
      t.join(`
`),
    );
  }
};
var uo = { major: 4, minor: 0, patch: 0 };
var $ = c("$ZodType", (e, n) => {
    var r;
    (e ?? (e = {}),
      (e._zod.id = n.type + "_" + Mt(10)),
      (e._zod.def = n),
      (e._zod.bag = e._zod.bag || {}),
      (e._zod.version = uo));
    let i = [...(e._zod.def.checks ?? [])];
    e._zod.traits.has("$ZodCheck") && i.unshift(e);
    for (let t of i) for (let o of t._zod.onattach) o(e);
    if (i.length === 0)
      ((r = e._zod).deferred ?? (r.deferred = []),
        e._zod.deferred?.push(() => {
          e._zod.run = e._zod.parse;
        }));
    else {
      let t = (o, a, s) => {
        let l = xe(o),
          u;
        for (let m of a) {
          if (m._zod.when) {
            if (!m._zod.when(o)) continue;
          } else if (l) continue;
          let p = o.issues.length,
            f = m._zod.check(o);
          if (f instanceof Promise && s?.async === !1) throw new ie();
          if (u || f instanceof Promise)
            u = (u ?? Promise.resolve()).then(async () => {
              (await f, o.issues.length !== p && (l || (l = xe(o, p))));
            });
          else {
            if (o.issues.length === p) continue;
            l || (l = xe(o, p));
          }
        }
        return u ? u.then(() => o) : o;
      };
      e._zod.run = (o, a) => {
        let s = e._zod.parse(o, a);
        if (s instanceof Promise) {
          if (a.async === !1) throw new ie();
          return s.then((l) => t(l, i, a));
        }
        return t(s, i, a);
      };
    }
    e["~standard"] = {
      validate: (t) => {
        try {
          let o = pr(e, t);
          return o.success ? { value: o.data } : { issues: o.error?.issues };
        } catch {
          return fr(e, t).then((a) =>
            a.success ? { value: a.data } : { issues: a.error?.issues },
          );
        }
      },
      vendor: "zod",
      version: 1,
    };
  }),
  at = c("$ZodString", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern =
        [...(e?._zod.bag?.patterns ?? [])].pop() ?? Ur(e._zod.bag)),
      (e._zod.parse = (r, i) => {
        if (n.coerce)
          try {
            r.value = String(r.value);
          } catch {}
        return (
          typeof r.value == "string" ||
            r.issues.push({
              expected: "string",
              code: "invalid_type",
              input: r.value,
              inst: e,
            }),
          r
        );
      }));
  }),
  U = c("$ZodStringFormat", (e, n) => {
    (Ee.init(e, n), at.init(e, n));
  }),
  _o = c("$ZodGUID", (e, n) => {
    (n.pattern ?? (n.pattern = xr), U.init(e, n));
  }),
  mo = c("$ZodUUID", (e, n) => {
    if (n.version) {
      let i = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
        n.version
      ];
      if (i === void 0) throw new Error(`Invalid UUID version: "${n.version}"`);
      n.pattern ?? (n.pattern = $e(i));
    } else n.pattern ?? (n.pattern = $e());
    U.init(e, n);
  }),
  po = c("$ZodEmail", (e, n) => {
    (n.pattern ?? (n.pattern = $r), U.init(e, n));
  }),
  fo = c("$ZodURL", (e, n) => {
    (U.init(e, n),
      (e._zod.check = (r) => {
        try {
          let i = new URL(r.value);
          (n.hostname &&
            ((n.hostname.lastIndex = 0),
            n.hostname.test(i.hostname) ||
              r.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: jr.source,
                input: r.value,
                inst: e,
                continue: !n.abort,
              })),
            n.protocol &&
              ((n.protocol.lastIndex = 0),
              n.protocol.test(
                i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol,
              ) ||
                r.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid protocol",
                  pattern: n.protocol.source,
                  input: r.value,
                  inst: e,
                  continue: !n.abort,
                })));
          return;
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "url",
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
        }
      }));
  }),
  go = c("$ZodEmoji", (e, n) => {
    (n.pattern ?? (n.pattern = zr()), U.init(e, n));
  }),
  ho = c("$ZodNanoID", (e, n) => {
    (n.pattern ?? (n.pattern = wr), U.init(e, n));
  }),
  vo = c("$ZodCUID", (e, n) => {
    (n.pattern ?? (n.pattern = gr), U.init(e, n));
  }),
  yo = c("$ZodCUID2", (e, n) => {
    (n.pattern ?? (n.pattern = hr), U.init(e, n));
  }),
  bo = c("$ZodULID", (e, n) => {
    (n.pattern ?? (n.pattern = vr), U.init(e, n));
  }),
  wo = c("$ZodXID", (e, n) => {
    (n.pattern ?? (n.pattern = yr), U.init(e, n));
  }),
  ko = c("$ZodKSUID", (e, n) => {
    (n.pattern ?? (n.pattern = br), U.init(e, n));
  }),
  xo = c("$ZodISODateTime", (e, n) => {
    (n.pattern ?? (n.pattern = Er(n)), U.init(e, n));
  }),
  $o = c("$ZodISODate", (e, n) => {
    (n.pattern ?? (n.pattern = Tr), U.init(e, n));
  }),
  zo = c("$ZodISOTime", (e, n) => {
    (n.pattern ?? (n.pattern = Nr(n)), U.init(e, n));
  }),
  So = c("$ZodISODuration", (e, n) => {
    (n.pattern ?? (n.pattern = kr), U.init(e, n));
  }),
  Io = c("$ZodIPv4", (e, n) => {
    (n.pattern ?? (n.pattern = Sr),
      U.init(e, n),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag;
        i.format = "ipv4";
      }));
  }),
  Ao = c("$ZodIPv6", (e, n) => {
    (n.pattern ?? (n.pattern = Ir),
      U.init(e, n),
      e._zod.onattach.push((r) => {
        let i = r._zod.bag;
        i.format = "ipv6";
      }),
      (e._zod.check = (r) => {
        try {
          new URL(`http://[${r.value}]`);
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
        }
      }));
  }),
  Po = c("$ZodCIDRv4", (e, n) => {
    (n.pattern ?? (n.pattern = Ar), U.init(e, n));
  }),
  Do = c("$ZodCIDRv6", (e, n) => {
    (n.pattern ?? (n.pattern = Pr),
      U.init(e, n),
      (e._zod.check = (r) => {
        let [i, t] = r.value.split("/");
        try {
          if (!t) throw new Error();
          let o = Number(t);
          if (`${o}` !== t) throw new Error();
          if (o < 0 || o > 128) throw new Error();
          new URL(`http://[${i}]`);
        } catch {
          r.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
        }
      }));
  });
function jo(e) {
  if (e === "") return !0;
  if (e.length % 4 !== 0) return !1;
  try {
    return (atob(e), !0);
  } catch {
    return !1;
  }
}
var Oo = c("$ZodBase64", (e, n) => {
  (n.pattern ?? (n.pattern = Dr),
    U.init(e, n),
    e._zod.onattach.push((r) => {
      r._zod.bag.contentEncoding = "base64";
    }),
    (e._zod.check = (r) => {
      jo(r.value) ||
        r.issues.push({
          code: "invalid_format",
          format: "base64",
          input: r.value,
          inst: e,
          continue: !n.abort,
        });
    }));
});
function xs(e) {
  if (!Bt.test(e)) return !1;
  let n = e.replace(/[-_]/g, (i) => (i === "-" ? "+" : "/")),
    r = n.padEnd(Math.ceil(n.length / 4) * 4, "=");
  return jo(r);
}
var To = c("$ZodBase64URL", (e, n) => {
    (n.pattern ?? (n.pattern = Bt),
      U.init(e, n),
      e._zod.onattach.push((r) => {
        r._zod.bag.contentEncoding = "base64url";
      }),
      (e._zod.check = (r) => {
        xs(r.value) ||
          r.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  No = c("$ZodE164", (e, n) => {
    (n.pattern ?? (n.pattern = Or), U.init(e, n));
  });
function $s(e, n = null) {
  try {
    let r = e.split(".");
    if (r.length !== 3) return !1;
    let [i] = r,
      t = JSON.parse(atob(i));
    return !(
      ("typ" in t && t?.typ !== "JWT") ||
      !t.alg ||
      (n && (!("alg" in t) || t.alg !== n))
    );
  } catch {
    return !1;
  }
}
var Eo = c("$ZodJWT", (e, n) => {
    (U.init(e, n),
      (e._zod.check = (r) => {
        $s(r.value, n.alg) ||
          r.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: r.value,
            inst: e,
            continue: !n.abort,
          });
      }));
  }),
  Xt = c("$ZodNumber", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern = e._zod.bag.pattern ?? Cr),
      (e._zod.parse = (r, i) => {
        if (n.coerce)
          try {
            r.value = Number(r.value);
          } catch {}
        let t = r.value;
        if (typeof t == "number" && !Number.isNaN(t) && Number.isFinite(t))
          return r;
        let o =
          typeof t == "number"
            ? Number.isNaN(t)
              ? "NaN"
              : Number.isFinite(t)
                ? void 0
                : "Infinity"
            : void 0;
        return (
          r.issues.push({
            expected: "number",
            code: "invalid_type",
            input: t,
            inst: e,
            ...(o ? { received: o } : {}),
          }),
          r
        );
      }));
  }),
  Uo = c("$ZodNumber", (e, n) => {
    (Hr.init(e, n), Xt.init(e, n));
  }),
  st = c("$ZodBoolean", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern = Mr),
      (e._zod.parse = (r, i) => {
        if (n.coerce)
          try {
            r.value = !!r.value;
          } catch {}
        let t = r.value;
        return (
          typeof t == "boolean" ||
            r.issues.push({
              expected: "boolean",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Qt = c("$ZodBigInt", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern = Zr),
      (e._zod.parse = (r, i) => {
        if (n.coerce)
          try {
            r.value = BigInt(r.value);
          } catch {}
        let { value: t } = r;
        return (
          typeof t == "bigint" ||
            r.issues.push({
              expected: "bigint",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Zo = c("$ZodBigInt", (e, n) => {
    (Br.init(e, n), Qt.init(e, n));
  }),
  Ro = c("$ZodSymbol", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let { value: t } = r;
        return (
          typeof t == "symbol" ||
            r.issues.push({
              expected: "symbol",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Co = c("$ZodUndefined", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern = Vr),
      (e._zod.values = new Set([void 0])),
      (e._zod.parse = (r, i) => {
        let { value: t } = r;
        return (
          typeof t > "u" ||
            r.issues.push({
              expected: "undefined",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Mo = c("$ZodNull", (e, n) => {
    ($.init(e, n),
      (e._zod.pattern = Lr),
      (e._zod.values = new Set([null])),
      (e._zod.parse = (r, i) => {
        let { value: t } = r;
        return (
          t === null ||
            r.issues.push({
              expected: "null",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Lo = c("$ZodAny", (e, n) => {
    ($.init(e, n), (e._zod.parse = (r) => r));
  }),
  he = c("$ZodUnknown", (e, n) => {
    ($.init(e, n), (e._zod.parse = (r) => r));
  }),
  Vo = c("$ZodNever", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => (
        r.issues.push({
          expected: "never",
          code: "invalid_type",
          input: r.value,
          inst: e,
        }),
        r
      )));
  }),
  Fo = c("$ZodVoid", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let { value: t } = r;
        return (
          typeof t > "u" ||
            r.issues.push({
              expected: "void",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  qo = c("$ZodDate", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        if (n.coerce)
          try {
            r.value = new Date(r.value);
          } catch {}
        let t = r.value,
          o = t instanceof Date;
        return (
          (o && !Number.isNaN(t.getTime())) ||
            r.issues.push({
              expected: "date",
              code: "invalid_type",
              input: t,
              ...(o ? { received: "Invalid Date" } : {}),
              inst: e,
            }),
          r
        );
      }));
  });
function _s(e, n, r) {
  (e.issues.length && n.issues.push(...q(r, e.issues)), (n.value[r] = e.value));
}
var lt = c("$ZodArray", (e, n) => {
  ($.init(e, n),
    (e._zod.parse = (r, i) => {
      let t = r.value;
      if (!Array.isArray(t))
        return (
          r.issues.push({
            expected: "array",
            code: "invalid_type",
            input: t,
            inst: e,
          }),
          r
        );
      r.value = Array(t.length);
      let o = [];
      for (let a = 0; a < t.length; a++) {
        let s = t[a],
          l = n.element._zod.run({ value: s, issues: [] }, i);
        l instanceof Promise ? o.push(l.then((u) => _s(u, r, a))) : _s(l, r, a);
      }
      return o.length ? Promise.all(o).then(() => r) : r;
    }));
});
function Yt(e, n, r) {
  (e.issues.length && n.issues.push(...q(r, e.issues)), (n.value[r] = e.value));
}
function ms(e, n, r, i) {
  e.issues.length
    ? i[r] === void 0
      ? r in i
        ? (n.value[r] = void 0)
        : (n.value[r] = e.value)
      : n.issues.push(...q(r, e.issues))
    : e.value === void 0
      ? r in i && (n.value[r] = void 0)
      : (n.value[r] = e.value);
}
var Wo = c("$ZodObject", (e, n) => {
  $.init(e, n);
  let r = Ye(() => {
    let p = Object.keys(n.shape);
    for (let d of p)
      if (!(n.shape[d] instanceof $))
        throw new Error(`Invalid element at key "${d}": expected a Zod schema`);
    let f = lr(n.shape);
    return {
      shape: n.shape,
      keys: p,
      keySet: new Set(p),
      numKeys: p.length,
      optionalKeys: new Set(f),
    };
  });
  T(e._zod, "propValues", () => {
    let p = n.shape,
      f = {};
    for (let d in p) {
      let v = p[d]._zod;
      if (v.values) {
        f[d] ?? (f[d] = new Set());
        for (let k of v.values) f[d].add(k);
      }
    }
    return f;
  });
  let i = (p) => {
      let f = new it(["shape", "payload", "ctx"]),
        { keys: d, optionalKeys: v } = r.value,
        k = (S) => {
          let z = ke(S);
          return `shape[${z}]._zod.run({ value: input[${z}], issues: [] }, ctx)`;
        };
      f.write("const input = payload.value;");
      let P = Object.create(null);
      for (let S of d) P[S] = Mt(15);
      f.write("const newResult = {}");
      for (let S of d)
        if (v.has(S)) {
          let z = P[S];
          f.write(`const ${z} = ${k(S)};`);
          let w = ke(S);
          f.write(`
        if (${z}.issues.length) {
          if (input[${w}] === undefined) {
            if (${w} in input) {
              newResult[${w}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${z}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${w}, ...iss.path] : [${w}],
              }))
            );
          }
        } else if (${z}.value === undefined) {
          if (${w} in input) newResult[${w}] = undefined;
        } else {
          newResult[${w}] = ${z}.value;
        }
        `);
        } else {
          let z = P[S];
          (f.write(`const ${z} = ${k(S)};`),
            f.write(`
          if (${z}.issues.length) payload.issues = payload.issues.concat(${z}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${ke(S)}, ...iss.path] : [${ke(S)}]
          })));`),
            f.write(`newResult[${ke(S)}] = ${z}.value`));
        }
      (f.write("payload.value = newResult;"), f.write("return payload;"));
      let j = f.compile();
      return (S, z) => j(p, S, z);
    },
    t,
    o = Te,
    a = !Be.jitless,
    l = a && ar.value,
    { catchall: u } = n,
    m;
  e._zod.parse = (p, f) => {
    m ?? (m = r.value);
    let d = p.value;
    if (!o(d))
      return (
        p.issues.push({
          expected: "object",
          code: "invalid_type",
          input: d,
          inst: e,
        }),
        p
      );
    let v = [];
    if (a && l && f?.async === !1 && f.jitless !== !0)
      (t || (t = i(n.shape)), (p = t(p, f)));
    else {
      p.value = {};
      let z = m.shape;
      for (let w of m.keys) {
        let x = z[w],
          A = x._zod.run({ value: d[w], issues: [] }, f),
          O = x._zod.optin === "optional" && x._zod.optout === "optional";
        A instanceof Promise
          ? v.push(A.then((M) => (O ? ms(M, p, w, d) : Yt(M, p, w))))
          : O
            ? ms(A, p, w, d)
            : Yt(A, p, w);
      }
    }
    if (!u) return v.length ? Promise.all(v).then(() => p) : p;
    let k = [],
      P = m.keySet,
      j = u._zod,
      S = j.def.type;
    for (let z of Object.keys(d)) {
      if (P.has(z)) continue;
      if (S === "never") {
        k.push(z);
        continue;
      }
      let w = j.run({ value: d[z], issues: [] }, f);
      w instanceof Promise ? v.push(w.then((x) => Yt(x, p, z))) : Yt(w, p, z);
    }
    return (
      k.length &&
        p.issues.push({
          code: "unrecognized_keys",
          keys: k,
          input: d,
          inst: e,
        }),
      v.length ? Promise.all(v).then(() => p) : p
    );
  };
});
function ps(e, n, r, i) {
  for (let t of e) if (t.issues.length === 0) return ((n.value = t.value), n);
  return (
    n.issues.push({
      code: "invalid_union",
      input: n.value,
      inst: r,
      errors: e.map((t) => t.issues.map((o) => K(o, i, C()))),
    }),
    n
  );
}
var en = c("$ZodUnion", (e, n) => {
    ($.init(e, n),
      T(e._zod, "values", () => {
        if (n.options.every((r) => r._zod.values))
          return new Set(n.options.flatMap((r) => Array.from(r._zod.values)));
      }),
      T(e._zod, "pattern", () => {
        if (n.options.every((r) => r._zod.pattern)) {
          let r = n.options.map((i) => i._zod.pattern);
          return new RegExp(`^(${r.map((i) => Ge(i.source)).join("|")})$`);
        }
      }),
      (e._zod.parse = (r, i) => {
        let t = !1,
          o = [];
        for (let a of n.options) {
          let s = a._zod.run({ value: r.value, issues: [] }, i);
          if (s instanceof Promise) (o.push(s), (t = !0));
          else {
            if (s.issues.length === 0) return s;
            o.push(s);
          }
        }
        return t ? Promise.all(o).then((a) => ps(a, r, e, i)) : ps(o, r, e, i);
      }));
  }),
  Ho = c("$ZodDiscriminatedUnion", (e, n) => {
    en.init(e, n);
    let r = e._zod.parse;
    T(e._zod, "propValues", () => {
      let t = {};
      for (let o of n.options) {
        let a = o._zod.propValues;
        if (!a || Object.keys(a).length === 0)
          throw new Error(
            `Invalid discriminated union option at index "${n.options.indexOf(o)}"`,
          );
        for (let [s, l] of Object.entries(a)) {
          t[s] || (t[s] = new Set());
          for (let u of l) t[s].add(u);
        }
      }
      return t;
    });
    let i = Ye(() => {
      let t = n.options,
        o = new Map();
      for (let a of t) {
        let s = a._zod.propValues[n.discriminator];
        if (!s || s.size === 0)
          throw new Error(
            `Invalid discriminated union option at index "${n.options.indexOf(a)}"`,
          );
        for (let l of s) {
          if (o.has(l))
            throw new Error(`Duplicate discriminator value "${String(l)}"`);
          o.set(l, a);
        }
      }
      return o;
    });
    e._zod.parse = (t, o) => {
      let a = t.value;
      if (!Te(a))
        return (
          t.issues.push({
            code: "invalid_type",
            expected: "object",
            input: a,
            inst: e,
          }),
          t
        );
      let s = i.value.get(a?.[n.discriminator]);
      return s
        ? s._zod.run(t, o)
        : n.unionFallback
          ? r(t, o)
          : (t.issues.push({
              code: "invalid_union",
              errors: [],
              note: "No matching discriminator",
              input: a,
              path: [n.discriminator],
              inst: e,
            }),
            t);
    };
  }),
  Bo = c("$ZodIntersection", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let { value: t } = r,
          o = n.left._zod.run({ value: t, issues: [] }, i),
          a = n.right._zod.run({ value: t, issues: [] }, i);
        return o instanceof Promise || a instanceof Promise
          ? Promise.all([o, a]).then(([l, u]) => fs(r, l, u))
          : fs(r, o, a);
      }));
  });
function co(e, n) {
  if (e === n) return { valid: !0, data: e };
  if (e instanceof Date && n instanceof Date && +e == +n)
    return { valid: !0, data: e };
  if (Xe(e) && Xe(n)) {
    let r = Object.keys(n),
      i = Object.keys(e).filter((o) => r.indexOf(o) !== -1),
      t = { ...e, ...n };
    for (let o of i) {
      let a = co(e[o], n[o]);
      if (!a.valid)
        return { valid: !1, mergeErrorPath: [o, ...a.mergeErrorPath] };
      t[o] = a.data;
    }
    return { valid: !0, data: t };
  }
  if (Array.isArray(e) && Array.isArray(n)) {
    if (e.length !== n.length) return { valid: !1, mergeErrorPath: [] };
    let r = [];
    for (let i = 0; i < e.length; i++) {
      let t = e[i],
        o = n[i],
        a = co(t, o);
      if (!a.valid)
        return { valid: !1, mergeErrorPath: [i, ...a.mergeErrorPath] };
      r.push(a.data);
    }
    return { valid: !0, data: r };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function fs(e, n, r) {
  if (
    (n.issues.length && e.issues.push(...n.issues),
    r.issues.length && e.issues.push(...r.issues),
    xe(e))
  )
    return e;
  let i = co(n.value, r.value);
  if (!i.valid)
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`,
    );
  return ((e.value = i.data), e);
}
var Se = c("$ZodTuple", (e, n) => {
  $.init(e, n);
  let r = n.items,
    i =
      r.length - [...r].reverse().findIndex((t) => t._zod.optin !== "optional");
  e._zod.parse = (t, o) => {
    let a = t.value;
    if (!Array.isArray(a))
      return (
        t.issues.push({
          input: a,
          inst: e,
          expected: "tuple",
          code: "invalid_type",
        }),
        t
      );
    t.value = [];
    let s = [];
    if (!n.rest) {
      let u = a.length > r.length,
        m = a.length < i - 1;
      if (u || m)
        return (
          t.issues.push({
            input: a,
            inst: e,
            origin: "array",
            ...(u
              ? { code: "too_big", maximum: r.length }
              : { code: "too_small", minimum: r.length }),
          }),
          t
        );
    }
    let l = -1;
    for (let u of r) {
      if ((l++, l >= a.length && l >= i)) continue;
      let m = u._zod.run({ value: a[l], issues: [] }, o);
      m instanceof Promise ? s.push(m.then((p) => Gt(p, t, l))) : Gt(m, t, l);
    }
    if (n.rest) {
      let u = a.slice(r.length);
      for (let m of u) {
        l++;
        let p = n.rest._zod.run({ value: m, issues: [] }, o);
        p instanceof Promise ? s.push(p.then((f) => Gt(f, t, l))) : Gt(p, t, l);
      }
    }
    return s.length ? Promise.all(s).then(() => t) : t;
  };
});
function Gt(e, n, r) {
  (e.issues.length && n.issues.push(...q(r, e.issues)), (n.value[r] = e.value));
}
var Ko = c("$ZodRecord", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let t = r.value;
        if (!Xe(t))
          return (
            r.issues.push({
              expected: "record",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
            r
          );
        let o = [];
        if (n.keyType._zod.values) {
          let a = n.keyType._zod.values;
          r.value = {};
          for (let l of a)
            if (
              typeof l == "string" ||
              typeof l == "number" ||
              typeof l == "symbol"
            ) {
              let u = n.valueType._zod.run({ value: t[l], issues: [] }, i);
              u instanceof Promise
                ? o.push(
                    u.then((m) => {
                      (m.issues.length && r.issues.push(...q(l, m.issues)),
                        (r.value[l] = m.value));
                    }),
                  )
                : (u.issues.length && r.issues.push(...q(l, u.issues)),
                  (r.value[l] = u.value));
            }
          let s;
          for (let l in t) a.has(l) || ((s = s ?? []), s.push(l));
          s &&
            s.length > 0 &&
            r.issues.push({
              code: "unrecognized_keys",
              input: t,
              inst: e,
              keys: s,
            });
        } else {
          r.value = {};
          for (let a of Reflect.ownKeys(t)) {
            if (a === "__proto__") continue;
            let s = n.keyType._zod.run({ value: a, issues: [] }, i);
            if (s instanceof Promise)
              throw new Error(
                "Async schemas not supported in object keys currently",
              );
            if (s.issues.length) {
              (r.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: s.issues.map((u) => K(u, i, C())),
                input: a,
                path: [a],
                inst: e,
              }),
                (r.value[s.value] = s.value));
              continue;
            }
            let l = n.valueType._zod.run({ value: t[a], issues: [] }, i);
            l instanceof Promise
              ? o.push(
                  l.then((u) => {
                    (u.issues.length && r.issues.push(...q(a, u.issues)),
                      (r.value[s.value] = u.value));
                  }),
                )
              : (l.issues.length && r.issues.push(...q(a, l.issues)),
                (r.value[s.value] = l.value));
          }
        }
        return o.length ? Promise.all(o).then(() => r) : r;
      }));
  }),
  Jo = c("$ZodMap", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let t = r.value;
        if (!(t instanceof Map))
          return (
            r.issues.push({
              expected: "map",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
            r
          );
        let o = [];
        r.value = new Map();
        for (let [a, s] of t) {
          let l = n.keyType._zod.run({ value: a, issues: [] }, i),
            u = n.valueType._zod.run({ value: s, issues: [] }, i);
          l instanceof Promise || u instanceof Promise
            ? o.push(
                Promise.all([l, u]).then(([m, p]) => {
                  gs(m, p, r, a, t, e, i);
                }),
              )
            : gs(l, u, r, a, t, e, i);
        }
        return o.length ? Promise.all(o).then(() => r) : r;
      }));
  });
function gs(e, n, r, i, t, o, a) {
  (e.issues.length &&
    (Qe.has(typeof i)
      ? r.issues.push(...q(i, e.issues))
      : r.issues.push({
          origin: "map",
          code: "invalid_key",
          input: t,
          inst: o,
          issues: e.issues.map((s) => K(s, a, C())),
        })),
    n.issues.length &&
      (Qe.has(typeof i)
        ? r.issues.push(...q(i, n.issues))
        : r.issues.push({
            origin: "map",
            code: "invalid_element",
            input: t,
            inst: o,
            key: i,
            issues: n.issues.map((s) => K(s, a, C())),
          })),
    r.value.set(e.value, n.value));
}
var Yo = c("$ZodSet", (e, n) => {
  ($.init(e, n),
    (e._zod.parse = (r, i) => {
      let t = r.value;
      if (!(t instanceof Set))
        return (
          r.issues.push({
            input: t,
            inst: e,
            expected: "set",
            code: "invalid_type",
          }),
          r
        );
      let o = [];
      r.value = new Set();
      for (let a of t) {
        let s = n.valueType._zod.run({ value: a, issues: [] }, i);
        s instanceof Promise ? o.push(s.then((l) => hs(l, r))) : hs(s, r);
      }
      return o.length ? Promise.all(o).then(() => r) : r;
    }));
});
function hs(e, n) {
  (e.issues.length && n.issues.push(...e.issues), n.value.add(e.value));
}
var Go = c("$ZodEnum", (e, n) => {
    $.init(e, n);
    let r = Je(n.entries);
    ((e._zod.values = new Set(r)),
      (e._zod.pattern = new RegExp(
        `^(${r
          .filter((i) => Qe.has(typeof i))
          .map((i) => (typeof i == "string" ? le(i) : i.toString()))
          .join("|")})$`,
      )),
      (e._zod.parse = (i, t) => {
        let o = i.value;
        return (
          e._zod.values.has(o) ||
            i.issues.push({
              code: "invalid_value",
              values: r,
              input: o,
              inst: e,
            }),
          i
        );
      }));
  }),
  Xo = c("$ZodLiteral", (e, n) => {
    ($.init(e, n),
      (e._zod.values = new Set(n.values)),
      (e._zod.pattern = new RegExp(
        `^(${n.values.map((r) => (typeof r == "string" ? le(r) : r ? r.toString() : String(r))).join("|")})$`,
      )),
      (e._zod.parse = (r, i) => {
        let t = r.value;
        return (
          e._zod.values.has(t) ||
            r.issues.push({
              code: "invalid_value",
              values: n.values,
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  Qo = c("$ZodFile", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let t = r.value;
        return (
          t instanceof File ||
            r.issues.push({
              expected: "file",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          r
        );
      }));
  }),
  ei = c("$ZodTransform", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let t = n.transform(r.value, r);
        if (i.async)
          return (t instanceof Promise ? t : Promise.resolve(t)).then(
            (a) => ((r.value = a), r),
          );
        if (t instanceof Promise) throw new ie();
        return ((r.value = t), r);
      }));
  }),
  ti = c("$ZodOptional", (e, n) => {
    ($.init(e, n),
      (e._zod.optin = "optional"),
      (e._zod.optout = "optional"),
      T(e._zod, "values", () =>
        n.innerType._zod.values
          ? new Set([...n.innerType._zod.values, void 0])
          : void 0,
      ),
      T(e._zod, "pattern", () => {
        let r = n.innerType._zod.pattern;
        return r ? new RegExp(`^(${Ge(r.source)})?$`) : void 0;
      }),
      (e._zod.parse = (r, i) =>
        r.value === void 0 ? r : n.innerType._zod.run(r, i)));
  }),
  ni = c("$ZodNullable", (e, n) => {
    ($.init(e, n),
      T(e._zod, "optin", () => n.innerType._zod.optin),
      T(e._zod, "optout", () => n.innerType._zod.optout),
      T(e._zod, "pattern", () => {
        let r = n.innerType._zod.pattern;
        return r ? new RegExp(`^(${Ge(r.source)}|null)$`) : void 0;
      }),
      T(e._zod, "values", () =>
        n.innerType._zod.values
          ? new Set([...n.innerType._zod.values, null])
          : void 0,
      ),
      (e._zod.parse = (r, i) =>
        r.value === null ? r : n.innerType._zod.run(r, i)));
  }),
  ri = c("$ZodDefault", (e, n) => {
    ($.init(e, n),
      (e._zod.optin = "optional"),
      T(e._zod, "values", () => n.innerType._zod.values),
      (e._zod.parse = (r, i) => {
        if (r.value === void 0) return ((r.value = n.defaultValue), r);
        let t = n.innerType._zod.run(r, i);
        return t instanceof Promise ? t.then((o) => vs(o, n)) : vs(t, n);
      }));
  });
function vs(e, n) {
  return (e.value === void 0 && (e.value = n.defaultValue), e);
}
var oi = c("$ZodPrefault", (e, n) => {
    ($.init(e, n),
      (e._zod.optin = "optional"),
      T(e._zod, "values", () => n.innerType._zod.values),
      (e._zod.parse = (r, i) => (
        r.value === void 0 && (r.value = n.defaultValue),
        n.innerType._zod.run(r, i)
      )));
  }),
  ii = c("$ZodNonOptional", (e, n) => {
    ($.init(e, n),
      T(e._zod, "values", () => {
        let r = n.innerType._zod.values;
        return r ? new Set([...r].filter((i) => i !== void 0)) : void 0;
      }),
      (e._zod.parse = (r, i) => {
        let t = n.innerType._zod.run(r, i);
        return t instanceof Promise ? t.then((o) => ys(o, e)) : ys(t, e);
      }));
  });
function ys(e, n) {
  return (
    !e.issues.length &&
      e.value === void 0 &&
      e.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: e.value,
        inst: n,
      }),
    e
  );
}
var ai = c("$ZodSuccess", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => {
        let t = n.innerType._zod.run(r, i);
        return t instanceof Promise
          ? t.then((o) => ((r.value = o.issues.length === 0), r))
          : ((r.value = t.issues.length === 0), r);
      }));
  }),
  si = c("$ZodCatch", (e, n) => {
    ($.init(e, n),
      T(e._zod, "optin", () => n.innerType._zod.optin),
      T(e._zod, "optout", () => n.innerType._zod.optout),
      T(e._zod, "values", () => n.innerType._zod.values),
      (e._zod.parse = (r, i) => {
        let t = n.innerType._zod.run(r, i);
        return t instanceof Promise
          ? t.then(
              (o) => (
                (r.value = o.value),
                o.issues.length &&
                  ((r.value = n.catchValue({
                    ...r,
                    error: { issues: o.issues.map((a) => K(a, i, C())) },
                    input: r.value,
                  })),
                  (r.issues = [])),
                r
              ),
            )
          : ((r.value = t.value),
            t.issues.length &&
              ((r.value = n.catchValue({
                ...r,
                error: { issues: t.issues.map((o) => K(o, i, C())) },
                input: r.value,
              })),
              (r.issues = [])),
            r);
      }));
  }),
  li = c("$ZodNaN", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) => (
        (typeof r.value != "number" || !Number.isNaN(r.value)) &&
          r.issues.push({
            input: r.value,
            inst: e,
            expected: "nan",
            code: "invalid_type",
          }),
        r
      )));
  }),
  ut = c("$ZodPipe", (e, n) => {
    ($.init(e, n),
      T(e._zod, "values", () => n.in._zod.values),
      T(e._zod, "optin", () => n.in._zod.optin),
      T(e._zod, "optout", () => n.out._zod.optout),
      (e._zod.parse = (r, i) => {
        let t = n.in._zod.run(r, i);
        return t instanceof Promise ? t.then((o) => bs(o, n, i)) : bs(t, n, i);
      }));
  });
function bs(e, n, r) {
  return xe(e) ? e : n.out._zod.run({ value: e.value, issues: e.issues }, r);
}
var ui = c("$ZodReadonly", (e, n) => {
  ($.init(e, n),
    T(e._zod, "propValues", () => n.innerType._zod.propValues),
    T(e._zod, "optin", () => n.innerType._zod.optin),
    T(e._zod, "optout", () => n.innerType._zod.optout),
    (e._zod.parse = (r, i) => {
      let t = n.innerType._zod.run(r, i);
      return t instanceof Promise ? t.then(ws) : ws(t);
    }));
});
function ws(e) {
  return ((e.value = Object.freeze(e.value)), e);
}
var ci = c("$ZodTemplateLiteral", (e, n) => {
    $.init(e, n);
    let r = [];
    for (let i of n.parts)
      if (i instanceof $) {
        if (!i._zod.pattern)
          throw new Error(
            `Invalid template literal part, no pattern found: ${[...i._zod.traits].shift()}`,
          );
        let t =
          i._zod.pattern instanceof RegExp
            ? i._zod.pattern.source
            : i._zod.pattern;
        if (!t)
          throw new Error(`Invalid template literal part: ${i._zod.traits}`);
        let o = t.startsWith("^") ? 1 : 0,
          a = t.endsWith("$") ? t.length - 1 : t.length;
        r.push(t.slice(o, a));
      } else if (i === null || sr.has(typeof i)) r.push(le(`${i}`));
      else throw new Error(`Invalid template literal part: ${i}`);
    ((e._zod.pattern = new RegExp(`^${r.join("")}$`)),
      (e._zod.parse = (i, t) =>
        typeof i.value != "string"
          ? (i.issues.push({
              input: i.value,
              inst: e,
              expected: "template_literal",
              code: "invalid_type",
            }),
            i)
          : ((e._zod.pattern.lastIndex = 0),
            e._zod.pattern.test(i.value) ||
              i.issues.push({
                input: i.value,
                inst: e,
                code: "invalid_format",
                format: "template_literal",
                pattern: e._zod.pattern.source,
              }),
            i)));
  }),
  di = c("$ZodPromise", (e, n) => {
    ($.init(e, n),
      (e._zod.parse = (r, i) =>
        Promise.resolve(r.value).then((t) =>
          n.innerType._zod.run({ value: t, issues: [] }, i),
        )));
  }),
  _i = c("$ZodLazy", (e, n) => {
    ($.init(e, n),
      T(e._zod, "innerType", () => n.getter()),
      T(e._zod, "pattern", () => e._zod.innerType._zod.pattern),
      T(e._zod, "propValues", () => e._zod.innerType._zod.propValues),
      T(e._zod, "optin", () => e._zod.innerType._zod.optin),
      T(e._zod, "optout", () => e._zod.innerType._zod.optout),
      (e._zod.parse = (r, i) => e._zod.innerType._zod.run(r, i)));
  }),
  mi = c("$ZodCustom", (e, n) => {
    (R.init(e, n),
      $.init(e, n),
      (e._zod.parse = (r, i) => r),
      (e._zod.check = (r) => {
        let i = r.value,
          t = n.fn(i);
        if (t instanceof Promise) return t.then((o) => ks(o, r, i, e));
        ks(t, r, i, e);
      }));
  });
function ks(e, n, r, i) {
  if (!e) {
    let t = {
      code: "custom",
      input: r,
      inst: i,
      path: [...(i._zod.def.path ?? [])],
      continue: !i._zod.def.abort,
    };
    (i._zod.def.params && (t.params = i._zod.def.params), n.issues.push(dr(t)));
  }
}
var ct = {};
ye(ct, {
  ar: () => Ss,
  az: () => Is,
  be: () => Ps,
  ca: () => Ds,
  cs: () => js,
  de: () => Os,
  en: () => tn,
  es: () => Ts,
  fa: () => Ns,
  fi: () => Es,
  fr: () => Us,
  frCA: () => Zs,
  he: () => Rs,
  hu: () => Cs,
  id: () => Ms,
  it: () => Ls,
  ja: () => Vs,
  kh: () => Fs,
  ko: () => qs,
  mk: () => Ws,
  ms: () => Hs,
  nl: () => Bs,
  no: () => Ks,
  ota: () => Js,
  pl: () => Ys,
  pt: () => Gs,
  ru: () => Qs,
  sl: () => el,
  sv: () => tl,
  ta: () => nl,
  th: () => rl,
  tr: () => ol,
  ua: () => il,
  ur: () => al,
  vi: () => sl,
  zhCN: () => ll,
  zhTW: () => ul,
});
var ac = () => {
  let e = {
    string: {
      unit: "\u062D\u0631\u0641",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    file: {
      unit: "\u0628\u0627\u064A\u062A",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    array: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    set: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0645\u062F\u062E\u0644",
      email:
        "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
      url: "\u0631\u0627\u0628\u0637",
      emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
      ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
      cidrv4:
        "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
      cidrv6:
        "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
      base64:
        "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
      base64url:
        "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
      json_string:
        "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
      e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
      jwt: "JWT",
      template_literal: "\u0645\u062F\u062E\u0644",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${t.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${b(t.values[0])}`
          : `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${t.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${o} ${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0635\u0631"}`
          : `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${t.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${t.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${o} ${t.minimum.toString()} ${a.unit}`
          : `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${t.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${t.prefix}"`
          : o.format === "ends_with"
            ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${o.suffix}"`
            : o.format === "includes"
              ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${o.includes}"`
              : o.format === "regex"
                ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${o.pattern}`
                : `${i[o.format] ?? t.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${t.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${t.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${t.keys.length > 1 ? "\u0629" : ""}: ${_(t.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${t.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${t.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function Ss() {
  return { localeError: ac() };
}
var sc = () => {
  let e = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${t.expected}, daxil olan ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${b(t.values[0])}`
          : `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${t.origin ?? "d\u0259y\u0259r"} ${o}${t.maximum.toString()} ${a.unit ?? "element"}`
          : `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${t.origin ?? "d\u0259y\u0259r"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${t.origin} ${o}${t.minimum.toString()} ${a.unit}`
          : `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Yanl\u0131\u015F m\u0259tn: "${o.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`
          : o.format === "ends_with"
            ? `Yanl\u0131\u015F m\u0259tn: "${o.suffix}" il\u0259 bitm\u0259lidir`
            : o.format === "includes"
              ? `Yanl\u0131\u015F m\u0259tn: "${o.includes}" daxil olmal\u0131d\u0131r`
              : o.format === "regex"
                ? `Yanl\u0131\u015F m\u0259tn: ${o.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`
                : `Yanl\u0131\u015F ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${t.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${t.keys.length > 1 ? "lar" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${t.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return "Yanl\u0131\u015F d\u0259y\u0259r";
    }
  };
};
function Is() {
  return { localeError: sc() };
}
function As(e, n, r, i) {
  let t = Math.abs(e),
    o = t % 10,
    a = t % 100;
  return a >= 11 && a <= 19 ? i : o === 1 ? n : o >= 2 && o <= 4 ? r : i;
}
var lc = () => {
  let e = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u043B\u0456\u043A";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0456\u045E";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0443\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0430\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0447\u0430\u0441",
      duration:
        "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
      cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      base64:
        "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
      base64url:
        "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
      json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
      e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0443\u0432\u043E\u0434",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${t.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${b(t.values[0])}`
          : `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        if (a) {
          let s = Number(t.maximum),
            l = As(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${a.verb} ${o}${t.maximum.toString()} ${l}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        if (a) {
          let s = Number(t.minimum),
            l = As(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${a.verb} ${o}${t.minimum.toString()} ${l}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${t.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${t.origin}`;
      default:
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
    }
  };
};
function Ps() {
  return { localeError: lc() };
}
var uc = () => {
  let e = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entrada",
      email: "adre\xE7a electr\xF2nica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adre\xE7a IPv4",
      ipv6: "adre\xE7a IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${t.expected}, s'ha rebut ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Valor inv\xE0lid: s'esperava ${b(t.values[0])}`
          : `Opci\xF3 inv\xE0lida: s'esperava una de ${_(t.values, " o ")}`;
      case "too_big": {
        let o = t.inclusive ? "com a m\xE0xim" : "menys de",
          a = n(t.origin);
        return a
          ? `Massa gran: s'esperava que ${t.origin ?? "el valor"} contingu\xE9s ${o} ${t.maximum.toString()} ${a.unit ?? "elements"}`
          : `Massa gran: s'esperava que ${t.origin ?? "el valor"} fos ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? "com a m\xEDnim" : "m\xE9s de",
          a = n(t.origin);
        return a
          ? `Massa petit: s'esperava que ${t.origin} contingu\xE9s ${o} ${t.minimum.toString()} ${a.unit}`
          : `Massa petit: s'esperava que ${t.origin} fos ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Format inv\xE0lid: ha de comen\xE7ar amb "${o.prefix}"`
          : o.format === "ends_with"
            ? `Format inv\xE0lid: ha d'acabar amb "${o.suffix}"`
            : o.format === "includes"
              ? `Format inv\xE0lid: ha d'incloure "${o.includes}"`
              : o.format === "regex"
                ? `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${o.pattern}`
                : `Format inv\xE0lid per a ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Clau${t.keys.length > 1 ? "s" : ""} no reconeguda${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${t.origin}`;
      default:
        return "Entrada inv\xE0lida";
    }
  };
};
function Ds() {
  return { localeError: uc() };
}
var cc = () => {
  let e = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u010D\xEDslo";
        case "string":
          return "\u0159et\u011Bzec";
        case "boolean":
          return "boolean";
        case "bigint":
          return "bigint";
        case "function":
          return "funkce";
        case "symbol":
          return "symbol";
        case "undefined":
          return "undefined";
        case "object": {
          if (Array.isArray(t)) return "pole";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "regul\xE1rn\xED v\xFDraz",
      email: "e-mailov\xE1 adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a \u010Das ve form\xE1tu ISO",
      date: "datum ve form\xE1tu ISO",
      time: "\u010Das ve form\xE1tu ISO",
      duration: "doba trv\xE1n\xED ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
      base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
      json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
      e164: "\u010D\xEDslo E.164",
      jwt: "JWT",
      template_literal: "vstup",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${t.expected}, obdr\u017Eeno ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${b(t.values[0])}`
          : `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${t.origin ?? "hodnota"} mus\xED m\xEDt ${o}${t.maximum.toString()} ${a.unit ?? "prvk\u016F"}`
          : `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${t.origin ?? "hodnota"} mus\xED b\xFDt ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${t.origin ?? "hodnota"} mus\xED m\xEDt ${o}${t.minimum.toString()} ${a.unit ?? "prvk\u016F"}`
          : `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${t.origin ?? "hodnota"} mus\xED b\xFDt ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${o.prefix}"`
          : o.format === "ends_with"
            ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${o.suffix}"`
            : o.format === "includes"
              ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${o.includes}"`
              : o.format === "regex"
                ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${o.pattern}`
                : `Neplatn\xFD form\xE1t ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${t.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${t.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${t.origin}`;
      default:
        return "Neplatn\xFD vstup";
    }
  };
};
function js() {
  return { localeError: cc() };
}
var dc = () => {
  let e = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "Zahl";
        case "object": {
          if (Array.isArray(t)) return "Array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${t.expected}, erhalten ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ung\xFCltige Eingabe: erwartet ${b(t.values[0])}`
          : `Ung\xFCltige Option: erwartet eine von ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Zu gro\xDF: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ${a.unit ?? "Elemente"} hat`
          : `Zu gro\xDF: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ist`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ${a.unit} hat`
          : `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ung\xFCltiger String: muss mit "${o.prefix}" beginnen`
          : o.format === "ends_with"
            ? `Ung\xFCltiger String: muss mit "${o.suffix}" enden`
            : o.format === "includes"
              ? `Ung\xFCltiger String: muss "${o.includes}" enthalten`
              : o.format === "regex"
                ? `Ung\xFCltiger String: muss dem Muster ${o.pattern} entsprechen`
                : `Ung\xFCltig: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${t.divisor} sein`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${t.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${t.origin}`;
      default:
        return "Ung\xFCltige Eingabe";
    }
  };
};
function Os() {
  return { localeError: dc() };
}
var _c = (e) => {
    let n = typeof e;
    switch (n) {
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(e)) return "array";
        if (e === null) return "null";
        if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
          return e.constructor.name;
      }
    }
    return n;
  },
  mc = () => {
    let e = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
    };
    function n(i) {
      return e[i] ?? null;
    }
    let r = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
    return (i) => {
      switch (i.code) {
        case "invalid_type":
          return `Invalid input: expected ${i.expected}, received ${_c(i.input)}`;
        case "invalid_value":
          return i.values.length === 1
            ? `Invalid input: expected ${b(i.values[0])}`
            : `Invalid option: expected one of ${_(i.values, "|")}`;
        case "too_big": {
          let t = i.inclusive ? "<=" : "<",
            o = n(i.origin);
          return o
            ? `Too big: expected ${i.origin ?? "value"} to have ${t}${i.maximum.toString()} ${o.unit ?? "elements"}`
            : `Too big: expected ${i.origin ?? "value"} to be ${t}${i.maximum.toString()}`;
        }
        case "too_small": {
          let t = i.inclusive ? ">=" : ">",
            o = n(i.origin);
          return o
            ? `Too small: expected ${i.origin} to have ${t}${i.minimum.toString()} ${o.unit}`
            : `Too small: expected ${i.origin} to be ${t}${i.minimum.toString()}`;
        }
        case "invalid_format": {
          let t = i;
          return t.format === "starts_with"
            ? `Invalid string: must start with "${t.prefix}"`
            : t.format === "ends_with"
              ? `Invalid string: must end with "${t.suffix}"`
              : t.format === "includes"
                ? `Invalid string: must include "${t.includes}"`
                : t.format === "regex"
                  ? `Invalid string: must match pattern ${t.pattern}`
                  : `Invalid ${r[t.format] ?? i.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${i.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${i.keys.length > 1 ? "s" : ""}: ${_(i.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${i.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${i.origin}`;
        default:
          return "Invalid input";
      }
    };
  };
function tn() {
  return { localeError: mc() };
}
var pc = () => {
  let e = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "n\xFAmero";
        case "object": {
          if (Array.isArray(t)) return "arreglo";
          if (t === null) return "nulo";
          if (Object.getPrototypeOf(t) !== Object.prototype)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entrada",
      email: "direcci\xF3n de correo electr\xF3nico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duraci\xF3n ISO",
      ipv4: "direcci\xF3n IPv4",
      ipv6: "direcci\xF3n IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${t.expected}, recibido ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entrada inv\xE1lida: se esperaba ${b(t.values[0])}`
          : `Opci\xF3n inv\xE1lida: se esperaba una de ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Demasiado grande: se esperaba que ${t.origin ?? "valor"} tuviera ${o}${t.maximum.toString()} ${a.unit ?? "elementos"}`
          : `Demasiado grande: se esperaba que ${t.origin ?? "valor"} fuera ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Demasiado peque\xF1o: se esperaba que ${t.origin} tuviera ${o}${t.minimum.toString()} ${a.unit}`
          : `Demasiado peque\xF1o: se esperaba que ${t.origin} fuera ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cadena inv\xE1lida: debe comenzar con "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cadena inv\xE1lida: debe terminar en "${o.suffix}"`
            : o.format === "includes"
              ? `Cadena inv\xE1lida: debe incluir "${o.includes}"`
              : o.format === "regex"
                ? `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${o.pattern}`
                : `Inv\xE1lido ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Llave${t.keys.length > 1 ? "s" : ""} desconocida${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${t.origin}`;
      default:
        return "Entrada inv\xE1lida";
    }
  };
};
function Ts() {
  return { localeError: pc() };
}
var fc = () => {
  let e = {
    string: {
      unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    file: {
      unit: "\u0628\u0627\u06CC\u062A",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    array: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    set: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0639\u062F\u062F";
        case "object": {
          if (Array.isArray(t)) return "\u0622\u0631\u0627\u06CC\u0647";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0648\u0631\u0648\u062F\u06CC",
      email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
      url: "URL",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
      time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      duration:
        "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      ipv4: "IPv4 \u0622\u062F\u0631\u0633",
      ipv6: "IPv6 \u0622\u062F\u0631\u0633",
      cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
      cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
      base64: "base64-encoded \u0631\u0634\u062A\u0647",
      base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
      json_string: "JSON \u0631\u0634\u062A\u0647",
      e164: "E.164 \u0639\u062F\u062F",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u06CC",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${t.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${r(t.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${b(t.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`
          : `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${_(t.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${t.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${o}${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`
          : `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${t.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${o}${t.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${t.origin} \u0628\u0627\u06CC\u062F ${o}${t.minimum.toString()} ${a.unit} \u0628\u0627\u0634\u062F`
          : `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${t.origin} \u0628\u0627\u06CC\u062F ${o}${t.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${o.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`
          : o.format === "ends_with"
            ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${o.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`
            : o.format === "includes"
              ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${o.includes}" \u0628\u0627\u0634\u062F`
              : o.format === "regex"
                ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${o.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`
                : `${i[o.format] ?? t.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${t.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${t.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${t.origin}`;
      case "invalid_union":
        return "\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631";
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${t.origin}`;
      default:
        return "\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631";
    }
  };
};
function Ns() {
  return { localeError: fc() };
}
var gc = () => {
  let e = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "s\xE4\xE4nn\xF6llinen lauseke",
      email: "s\xE4hk\xF6postiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${t.expected}, oli ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Virheellinen sy\xF6te: t\xE4ytyy olla ${b(t.values[0])}`
          : `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Liian suuri: ${a.subject} t\xE4ytyy olla ${o}${t.maximum.toString()} ${a.unit}`.trim()
          : `Liian suuri: arvon t\xE4ytyy olla ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Liian pieni: ${a.subject} t\xE4ytyy olla ${o}${t.minimum.toString()} ${a.unit}`.trim()
          : `Liian pieni: arvon t\xE4ytyy olla ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${o.prefix}"`
          : o.format === "ends_with"
            ? `Virheellinen sy\xF6te: t\xE4ytyy loppua "${o.suffix}"`
            : o.format === "includes"
              ? `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${o.includes}"`
              : o.format === "regex"
                ? `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${o.pattern}`
                : `Virheellinen ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${t.divisor} monikerta`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen sy\xF6te";
    }
  };
};
function Es() {
  return { localeError: gc() };
}
var hc = () => {
  let e = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "nombre";
        case "object": {
          if (Array.isArray(t)) return "tableau";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entr\xE9e",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${t.expected} attendu, ${r(t.input)} re\xE7u`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entr\xE9e invalide : ${b(t.values[0])} attendu`
          : `Option invalide : une valeur parmi ${_(t.values, "|")} attendue`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Trop grand : ${t.origin ?? "valeur"} doit ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "\xE9l\xE9ment(s)"}`
          : `Trop grand : ${t.origin ?? "valeur"} doit \xEAtre ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Trop petit : ${t.origin} doit ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Trop petit : ${t.origin} doit \xEAtre ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cha\xEEne invalide : doit commencer par "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cha\xEEne invalide : doit se terminer par "${o.suffix}"`
            : o.format === "includes"
              ? `Cha\xEEne invalide : doit inclure "${o.includes}"`
              : o.format === "regex"
                ? `Cha\xEEne invalide : doit correspondre au mod\xE8le ${o.pattern}`
                : `${i[o.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entr\xE9e invalide";
    }
  };
};
function Us() {
  return { localeError: hc() };
}
var vc = () => {
  let e = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entr\xE9e",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${t.expected}, re\xE7u ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entr\xE9e invalide : attendu ${b(t.values[0])}`
          : `Option invalide : attendu l'une des valeurs suivantes ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "\u2264" : "<",
          a = n(t.origin);
        return a
          ? `Trop grand : attendu que ${t.origin ?? "la valeur"} ait ${o}${t.maximum.toString()} ${a.unit}`
          : `Trop grand : attendu que ${t.origin ?? "la valeur"} soit ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? "\u2265" : ">",
          a = n(t.origin);
        return a
          ? `Trop petit : attendu que ${t.origin} ait ${o}${t.minimum.toString()} ${a.unit}`
          : `Trop petit : attendu que ${t.origin} soit ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cha\xEEne invalide : doit commencer par "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cha\xEEne invalide : doit se terminer par "${o.suffix}"`
            : o.format === "includes"
              ? `Cha\xEEne invalide : doit inclure "${o.includes}"`
              : o.format === "regex"
                ? `Cha\xEEne invalide : doit correspondre au motif ${o.pattern}`
                : `${i[o.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entr\xE9e invalide";
    }
  };
};
function Zs() {
  return { localeError: vc() };
}
var yc = () => {
  let e = {
    string: {
      unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    file: {
      unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    array: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    set: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u05E7\u05DC\u05D8",
      email:
        "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
      url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
      emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
      date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
      time: "\u05D6\u05DE\u05DF ISO",
      duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
      ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
      ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
      cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
      cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
      base64:
        "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
      base64url:
        "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
      json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
      e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
      jwt: "JWT",
      template_literal: "\u05E7\u05DC\u05D8",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${t.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${b(t.values[0])}`
          : `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${t.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.maximum.toString()} ${a.unit ?? "elements"}`
          : `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${t.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${t.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.minimum.toString()} ${a.unit}`
          : `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${t.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${o.prefix}"`
          : o.format === "ends_with"
            ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${o.suffix}"`
            : o.format === "includes"
              ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${o.includes}"`
              : o.format === "regex"
                ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${o.pattern}`
                : `${i[o.format] ?? t.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${t.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${t.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${t.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${t.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${t.origin}`;
      default:
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
    }
  };
};
function Rs() {
  return { localeError: yc() };
}
var bc = () => {
  let e = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "sz\xE1m";
        case "object": {
          if (Array.isArray(t)) return "t\xF6mb";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "bemenet",
      email: "email c\xEDm",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO id\u0151b\xE9lyeg",
      date: "ISO d\xE1tum",
      time: "ISO id\u0151",
      duration: "ISO id\u0151intervallum",
      ipv4: "IPv4 c\xEDm",
      ipv6: "IPv6 c\xEDm",
      cidrv4: "IPv4 tartom\xE1ny",
      cidrv6: "IPv6 tartom\xE1ny",
      base64: "base64-k\xF3dolt string",
      base64url: "base64url-k\xF3dolt string",
      json_string: "JSON string",
      e164: "E.164 sz\xE1m",
      jwt: "JWT",
      template_literal: "bemenet",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${t.expected}, a kapott \xE9rt\xE9k ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${b(t.values[0])}`
          : `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `T\xFAl nagy: ${t.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${o}${t.maximum.toString()} ${a.unit ?? "elem"}`
          : `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${t.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${t.origin} m\xE9rete t\xFAl kicsi ${o}${t.minimum.toString()} ${a.unit}`
          : `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${t.origin} t\xFAl kicsi ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\xC9rv\xE9nytelen string: "${o.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`
          : o.format === "ends_with"
            ? `\xC9rv\xE9nytelen string: "${o.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`
            : o.format === "includes"
              ? `\xC9rv\xE9nytelen string: "${o.includes}" \xE9rt\xE9ket kell tartalmaznia`
              : o.format === "regex"
                ? `\xC9rv\xE9nytelen string: ${o.pattern} mint\xE1nak kell megfelelnie`
                : `\xC9rv\xE9nytelen ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${t.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${t.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${t.origin}`;
      default:
        return "\xC9rv\xE9nytelen bemenet";
    }
  };
};
function Cs() {
  return { localeError: bc() };
}
var wc = () => {
  let e = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${t.expected}, diterima ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input tidak valid: diharapkan ${b(t.values[0])}`
          : `Pilihan tidak valid: diharapkan salah satu dari ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Terlalu besar: diharapkan ${t.origin ?? "value"} memiliki ${o}${t.maximum.toString()} ${a.unit ?? "elemen"}`
          : `Terlalu besar: diharapkan ${t.origin ?? "value"} menjadi ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Terlalu kecil: diharapkan ${t.origin} memiliki ${o}${t.minimum.toString()} ${a.unit}`
          : `Terlalu kecil: diharapkan ${t.origin} menjadi ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `String tidak valid: harus dimulai dengan "${o.prefix}"`
          : o.format === "ends_with"
            ? `String tidak valid: harus berakhir dengan "${o.suffix}"`
            : o.format === "includes"
              ? `String tidak valid: harus menyertakan "${o.includes}"`
              : o.format === "regex"
                ? `String tidak valid: harus sesuai pola ${o.pattern}`
                : `${i[o.format] ?? t.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${t.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${t.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function Ms() {
  return { localeError: wc() };
}
var kc = () => {
  let e = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "numero";
        case "object": {
          if (Array.isArray(t)) return "vettore";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input non valido: atteso ${t.expected}, ricevuto ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input non valido: atteso ${b(t.values[0])}`
          : `Opzione non valida: atteso uno tra ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Troppo grande: ${t.origin ?? "valore"} deve avere ${o}${t.maximum.toString()} ${a.unit ?? "elementi"}`
          : `Troppo grande: ${t.origin ?? "valore"} deve essere ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Troppo piccolo: ${t.origin} deve avere ${o}${t.minimum.toString()} ${a.unit}`
          : `Troppo piccolo: ${t.origin} deve essere ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Stringa non valida: deve iniziare con "${o.prefix}"`
          : o.format === "ends_with"
            ? `Stringa non valida: deve terminare con "${o.suffix}"`
            : o.format === "includes"
              ? `Stringa non valida: deve includere "${o.includes}"`
              : o.format === "regex"
                ? `Stringa non valida: deve corrispondere al pattern ${o.pattern}`
                : `Invalid ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${t.divisor}`;
      case "unrecognized_keys":
        return `Chiav${t.keys.length > 1 ? "i" : "e"} non riconosciut${t.keys.length > 1 ? "e" : "a"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${t.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${t.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function Ls() {
  return { localeError: kc() };
}
var xc = () => {
  let e = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u6570\u5024";
        case "object": {
          if (Array.isArray(t)) return "\u914D\u5217";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u5165\u529B\u5024",
      email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
      url: "URL",
      emoji: "\u7D75\u6587\u5B57",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u6642",
      date: "ISO\u65E5\u4ED8",
      time: "ISO\u6642\u523B",
      duration: "ISO\u671F\u9593",
      ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
      ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
      cidrv4: "IPv4\u7BC4\u56F2",
      cidrv6: "IPv6\u7BC4\u56F2",
      base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      json_string: "JSON\u6587\u5B57\u5217",
      e164: "E.164\u756A\u53F7",
      jwt: "JWT",
      template_literal: "\u5165\u529B\u5024",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${t.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${r(t.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u7121\u52B9\u306A\u5165\u529B: ${b(t.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`
          : `\u7121\u52B9\u306A\u9078\u629E: ${_(t.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u5927\u304D\u3059\u304E\u308B\u5024: ${t.origin ?? "\u5024"}\u306F${t.maximum.toString()}${a.unit ?? "\u8981\u7D20"}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : `\u5927\u304D\u3059\u304E\u308B\u5024: ${t.origin ?? "\u5024"}\u306F${t.maximum.toString()}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${t.origin}\u306F${t.minimum.toString()}${a.unit}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${t.origin}\u306F${t.minimum.toString()}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : o.format === "ends_with"
            ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
            : o.format === "includes"
              ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
              : o.format === "regex"
                ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${o.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
                : `\u7121\u52B9\u306A${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${t.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${t.keys.length > 1 ? "\u7FA4" : ""}: ${_(t.keys, "\u3001")}`;
      case "invalid_key":
        return `${t.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${t.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return "\u7121\u52B9\u306A\u5165\u529B";
    }
  };
};
function Vs() {
  return { localeError: xc() };
}
var $c = () => {
  let e = {
    string: {
      unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    file: {
      unit: "\u1794\u17C3",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    array: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    set: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)"
            : "\u179B\u17C1\u1781";
        case "object": {
          if (Array.isArray(t)) return "\u17A2\u17B6\u179A\u17C1 (Array)";
          if (t === null)
            return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex:
        "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
      email:
        "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
      url: "URL",
      emoji:
        "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
      date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
      time: "\u1798\u17C9\u17C4\u1784 ISO",
      duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
      ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      cidrv4:
        "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      cidrv6:
        "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      base64:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
      base64url:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
      json_string:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
      e164: "\u179B\u17C1\u1781 E.164",
      jwt: "JWT",
      template_literal:
        "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${b(t.values[0])}`
          : `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${o} ${t.maximum.toString()} ${a.unit ?? "\u1792\u17B6\u178F\u17BB"}`
          : `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin} ${o} ${t.minimum.toString()} ${a.unit}`
          : `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin} ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${o.suffix}"`
            : o.format === "includes"
              ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${o.includes}"`
              : o.format === "regex"
                ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${o.pattern}`
                : `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${t.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${t.origin}`;
      case "invalid_union":
        return "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C";
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${t.origin}`;
      default:
        return "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C";
    }
  };
};
function Fs() {
  return { localeError: $c() };
}
var zc = () => {
  let e = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\uC785\uB825",
      email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
      url: "URL",
      emoji: "\uC774\uBAA8\uC9C0",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
      date: "ISO \uB0A0\uC9DC",
      time: "ISO \uC2DC\uAC04",
      duration: "ISO \uAE30\uAC04",
      ipv4: "IPv4 \uC8FC\uC18C",
      ipv6: "IPv6 \uC8FC\uC18C",
      cidrv4: "IPv4 \uBC94\uC704",
      cidrv6: "IPv6 \uBC94\uC704",
      base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      json_string: "JSON \uBB38\uC790\uC5F4",
      e164: "E.164 \uBC88\uD638",
      jwt: "JWT",
      template_literal: "\uC785\uB825",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${t.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${r(t.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        return t.values.length === 1
          ? `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${b(t.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`
          : `\uC798\uBABB\uB41C \uC635\uC158: ${_(t.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        let o = t.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC",
          a =
            o === "\uBBF8\uB9CC"
              ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
              : "\uC5EC\uC57C \uD569\uB2C8\uB2E4",
          s = n(t.origin),
          l = s?.unit ?? "\uC694\uC18C";
        return s
          ? `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${t.maximum.toString()}${l} ${o}${a}`
          : `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${t.maximum.toString()} ${o}${a}`;
      }
      case "too_small": {
        let o = t.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC",
          a =
            o === "\uC774\uC0C1"
              ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
              : "\uC5EC\uC57C \uD569\uB2C8\uB2E4",
          s = n(t.origin),
          l = s?.unit ?? "\uC694\uC18C";
        return s
          ? `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${t.minimum.toString()}${l} ${o}${a}`
          : `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${t.minimum.toString()} ${o}${a}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`
          : o.format === "ends_with"
            ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`
            : o.format === "includes"
              ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`
              : o.format === "regex"
                ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${o.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`
                : `\uC798\uBABB\uB41C ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${t.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${t.origin}`;
      case "invalid_union":
        return "\uC798\uBABB\uB41C \uC785\uB825";
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${t.origin}`;
      default:
        return "\uC798\uBABB\uB41C \uC785\uB825";
    }
  };
};
function qs() {
  return { localeError: zc() };
}
var Sc = () => {
  let e = {
    string: {
      unit: "\u0437\u043D\u0430\u0446\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    file: {
      unit: "\u0431\u0430\u0458\u0442\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    array: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    set: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0431\u0440\u043E\u0458";
        case "object": {
          if (Array.isArray(t)) return "\u043D\u0438\u0437\u0430";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u043D\u0435\u0441",
      email:
        "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u045F\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0443\u043C",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration:
        "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
      cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
      cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
      base64:
        "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      base64url:
        "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      json_string: "JSON \u043D\u0438\u0437\u0430",
      e164: "E.164 \u0431\u0440\u043E\u0458",
      jwt: "JWT",
      template_literal: "\u0432\u043D\u0435\u0441",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Invalid input: expected ${b(t.values[0])}`
          : `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${o}${t.maximum.toString()} ${a.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`
          : `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin} \u0434\u0430 \u0438\u043C\u0430 ${o}${t.minimum.toString()} ${a.unit}`
          : `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${o.pattern}`
                : `Invalid ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${t.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${t.origin}`;
      default:
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
    }
  };
};
function Ws() {
  return { localeError: Sc() };
}
var Ic = () => {
  let e = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "nombor";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${t.expected}, diterima ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input tidak sah: dijangka ${b(t.values[0])}`
          : `Pilihan tidak sah: dijangka salah satu daripada ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Terlalu besar: dijangka ${t.origin ?? "nilai"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "elemen"}`
          : `Terlalu besar: dijangka ${t.origin ?? "nilai"} adalah ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Terlalu kecil: dijangka ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Terlalu kecil: dijangka ${t.origin} adalah ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `String tidak sah: mesti bermula dengan "${o.prefix}"`
          : o.format === "ends_with"
            ? `String tidak sah: mesti berakhir dengan "${o.suffix}"`
            : o.format === "includes"
              ? `String tidak sah: mesti mengandungi "${o.includes}"`
              : o.format === "regex"
                ? `String tidak sah: mesti sepadan dengan corak ${o.pattern}`
                : `${i[o.format] ?? t.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${t.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${t.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function Hs() {
  return { localeError: Ic() };
}
var Ac = () => {
  let e = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "getal";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "invoer",
      email: "emailadres",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum en tijd",
      date: "ISO datum",
      time: "ISO tijd",
      duration: "ISO duur",
      ipv4: "IPv4-adres",
      ipv6: "IPv6-adres",
      cidrv4: "IPv4-bereik",
      cidrv6: "IPv6-bereik",
      base64: "base64-gecodeerde tekst",
      base64url: "base64 URL-gecodeerde tekst",
      json_string: "JSON string",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "invoer",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${t.expected}, ontving ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ongeldige invoer: verwacht ${b(t.values[0])}`
          : `Ongeldige optie: verwacht \xE9\xE9n van ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} ${a.unit ?? "elementen"} bevat`
          : `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} is`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} ${a.unit} bevat`
          : `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} is`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ongeldige tekst: moet met "${o.prefix}" beginnen`
          : o.format === "ends_with"
            ? `Ongeldige tekst: moet op "${o.suffix}" eindigen`
            : o.format === "includes"
              ? `Ongeldige tekst: moet "${o.includes}" bevatten`
              : o.format === "regex"
                ? `Ongeldige tekst: moet overeenkomen met patroon ${o.pattern}`
                : `Ongeldig: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${t.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${t.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Bs() {
  return { localeError: Ac() };
}
var Pc = () => {
  let e = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "tall";
        case "object": {
          if (Array.isArray(t)) return "liste";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${t.expected}, fikk ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ugyldig verdi: forventet ${b(t.values[0])}`
          : `Ugyldig valg: forventet en av ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `For stor(t): forventet ${t.origin ?? "value"} til \xE5 ha ${o}${t.maximum.toString()} ${a.unit ?? "elementer"}`
          : `For stor(t): forventet ${t.origin ?? "value"} til \xE5 ha ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `For lite(n): forventet ${t.origin} til \xE5 ha ${o}${t.minimum.toString()} ${a.unit}`
          : `For lite(n): forventet ${t.origin} til \xE5 ha ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ugyldig streng: m\xE5 starte med "${o.prefix}"`
          : o.format === "ends_with"
            ? `Ugyldig streng: m\xE5 ende med "${o.suffix}"`
            : o.format === "includes"
              ? `Ugyldig streng: m\xE5 inneholde "${o.includes}"`
              : o.format === "regex"
                ? `Ugyldig streng: m\xE5 matche m\xF8nsteret ${o.pattern}`
                : `Ugyldig ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${t.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${t.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Ks() {
  return { localeError: Pc() };
}
var Dc = () => {
  let e = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "numara";
        case "object": {
          if (Array.isArray(t)) return "saf";
          if (t === null) return "gayb";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "giren",
      email: "epostag\xE2h",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO heng\xE2m\u0131",
      date: "ISO tarihi",
      time: "ISO zaman\u0131",
      duration: "ISO m\xFCddeti",
      ipv4: "IPv4 ni\u015F\xE2n\u0131",
      ipv6: "IPv6 ni\u015F\xE2n\u0131",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-\u015Fifreli metin",
      base64url: "base64url-\u015Fifreli metin",
      json_string: "JSON metin",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "giren",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${t.expected}, al\u0131nan ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `F\xE2sit giren: umulan ${b(t.values[0])}`
          : `F\xE2sit tercih: m\xFBteberler ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Fazla b\xFCy\xFCk: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} ${a.unit ?? "elements"} sahip olmal\u0131yd\u0131.`
          : `Fazla b\xFCy\xFCk: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Fazla k\xFC\xE7\xFCk: ${t.origin}, ${o}${t.minimum.toString()} ${a.unit} sahip olmal\u0131yd\u0131.`
          : `Fazla k\xFC\xE7\xFCk: ${t.origin}, ${o}${t.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `F\xE2sit metin: "${o.prefix}" ile ba\u015Flamal\u0131.`
          : o.format === "ends_with"
            ? `F\xE2sit metin: "${o.suffix}" ile bitmeli.`
            : o.format === "includes"
              ? `F\xE2sit metin: "${o.includes}" ihtiv\xE2 etmeli.`
              : o.format === "regex"
                ? `F\xE2sit metin: ${o.pattern} nak\u015F\u0131na uymal\u0131.`
                : `F\xE2sit ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${t.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${t.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return "K\u0131ymet tan\u0131namad\u0131.";
    }
  };
};
function Js() {
  return { localeError: Dc() };
}
var jc = () => {
  let e = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "liczba";
        case "object": {
          if (Array.isArray(t)) return "tablica";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "wyra\u017Cenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
      base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
      json_string: "ci\u0105g znak\xF3w w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wej\u015Bcie",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${t.expected}, otrzymano ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${b(t.values[0])}`
          : `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${o}${t.maximum.toString()} ${a.unit ?? "element\xF3w"}`
          : `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${o}${t.minimum.toString()} ${a.unit ?? "element\xF3w"}`
          : `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${o.prefix}"`
          : o.format === "ends_with"
            ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${o.suffix}"`
            : o.format === "includes"
              ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${o.includes}"`
              : o.format === "regex"
                ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${o.pattern}`
                : `Nieprawid\u0142ow(y/a/e) ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${t.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${t.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${t.origin}`;
      default:
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
    }
  };
};
function Ys() {
  return { localeError: jc() };
}
var Oc = () => {
  let e = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "n\xFAmero";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "nulo";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "padr\xE3o",
      email: "endere\xE7o de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "dura\xE7\xE3o ISO",
      ipv4: "endere\xE7o IPv4",
      ipv6: "endere\xE7o IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${t.expected}, recebido ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entrada inv\xE1lida: esperado ${b(t.values[0])}`
          : `Op\xE7\xE3o inv\xE1lida: esperada uma das ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Muito grande: esperado que ${t.origin ?? "valor"} tivesse ${o}${t.maximum.toString()} ${a.unit ?? "elementos"}`
          : `Muito grande: esperado que ${t.origin ?? "valor"} fosse ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Muito pequeno: esperado que ${t.origin} tivesse ${o}${t.minimum.toString()} ${a.unit}`
          : `Muito pequeno: esperado que ${t.origin} fosse ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Texto inv\xE1lido: deve come\xE7ar com "${o.prefix}"`
          : o.format === "ends_with"
            ? `Texto inv\xE1lido: deve terminar com "${o.suffix}"`
            : o.format === "includes"
              ? `Texto inv\xE1lido: deve incluir "${o.includes}"`
              : o.format === "regex"
                ? `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${o.pattern}`
                : `${i[o.format] ?? t.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Chave${t.keys.length > 1 ? "s" : ""} desconhecida${t.keys.length > 1 ? "s" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${t.origin}`;
      default:
        return "Campo inv\xE1lido";
    }
  };
};
function Gs() {
  return { localeError: Oc() };
}
function Xs(e, n, r, i) {
  let t = Math.abs(e),
    o = t % 10,
    a = t % 100;
  return a >= 11 && a <= 19 ? i : o === 1 ? n : o >= 2 && o <= 4 ? r : i;
}
var Tc = () => {
  let e = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0441\u0438\u0432";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u044F",
      duration:
        "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64:
        "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
      base64url:
        "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
      json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0432\u043E\u0434",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${t.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${b(t.values[0])}`
          : `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        if (a) {
          let s = Number(t.maximum),
            l = Xs(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${o}${t.maximum.toString()} ${l}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        if (a) {
          let s = Number(t.minimum),
            l = Xs(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${o}${t.minimum.toString()} ${l}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin} \u0431\u0443\u0434\u0435\u0442 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${t.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${t.keys.length > 1 ? "\u0438" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${t.origin}`;
      default:
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
    }
  };
};
function Qs() {
  return { localeError: Tc() };
}
var Nc = () => {
  let e = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0161tevilo";
        case "object": {
          if (Array.isArray(t)) return "tabela";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "vnos",
      email: "e-po\u0161tni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in \u010Das",
      date: "ISO datum",
      time: "ISO \u010Das",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 \u0161tevilka",
      jwt: "JWT",
      template_literal: "vnos",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${t.expected}, prejeto ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Neveljaven vnos: pri\u010Dakovano ${b(t.values[0])}`
          : `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Preveliko: pri\u010Dakovano, da bo ${t.origin ?? "vrednost"} imelo ${o}${t.maximum.toString()} ${a.unit ?? "elementov"}`
          : `Preveliko: pri\u010Dakovano, da bo ${t.origin ?? "vrednost"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Premajhno: pri\u010Dakovano, da bo ${t.origin} imelo ${o}${t.minimum.toString()} ${a.unit}`
          : `Premajhno: pri\u010Dakovano, da bo ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Neveljaven niz: mora se za\u010Deti z "${o.prefix}"`
          : o.format === "ends_with"
            ? `Neveljaven niz: mora se kon\u010Dati z "${o.suffix}"`
            : o.format === "includes"
              ? `Neveljaven niz: mora vsebovati "${o.includes}"`
              : o.format === "regex"
                ? `Neveljaven niz: mora ustrezati vzorcu ${o.pattern}`
                : `Neveljaven ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${t.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${t.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${t.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${t.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function el() {
  return { localeError: Nc() };
}
var Ec = () => {
  let e = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "antal";
        case "object": {
          if (Array.isArray(t)) return "lista";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "regulj\xE4rt uttryck",
      email: "e-postadress",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datum och tid",
      date: "ISO-datum",
      time: "ISO-tid",
      duration: "ISO-varaktighet",
      ipv4: "IPv4-intervall",
      ipv6: "IPv6-intervall",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodad str\xE4ng",
      base64url: "base64url-kodad str\xE4ng",
      json_string: "JSON-str\xE4ng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "mall-literal",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${t.expected}, fick ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ogiltig inmatning: f\xF6rv\xE4ntat ${b(t.values[0])}`
          : `Ogiltigt val: f\xF6rv\xE4ntade en av ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `F\xF6r stor(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.maximum.toString()} ${a.unit ?? "element"}`
          : `F\xF6r stor(t): f\xF6rv\xE4ntat ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `F\xF6r lite(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.minimum.toString()} ${a.unit}`
          : `F\xF6r lite(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${o.prefix}"`
          : o.format === "ends_with"
            ? `Ogiltig str\xE4ng: m\xE5ste sluta med "${o.suffix}"`
            : o.format === "includes"
              ? `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${o.includes}"`
              : o.format === "regex"
                ? `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${o.pattern}"`
                : `Ogiltig(t) ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${t.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${t.origin ?? "v\xE4rdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function tl() {
  return { localeError: Ec() };
}
var Uc = () => {
  let e = {
    string: {
      unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    file: {
      unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    array: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    set: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1"
            : "\u0B8E\u0BA3\u0BCD";
        case "object": {
          if (Array.isArray(t)) return "\u0B85\u0BA3\u0BBF";
          if (t === null) return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
      email:
        "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
      time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
      ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
      e164: "E.164 \u0B8E\u0BA3\u0BCD",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${b(t.values[0])}`
          : `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${_(t.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${o}${t.maximum.toString()} ${a.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${o}${t.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin} ${o}${t.minimum.toString()} ${a.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin} ${o}${t.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : o.format === "ends_with"
            ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
            : o.format === "includes"
              ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
              : o.format === "regex"
                ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${o.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
                : `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${t.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${t.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${t.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
    }
  };
};
function nl() {
  return { localeError: Uc() };
}
var Zc = () => {
  let e = {
    string: {
      unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    file: {
      unit: "\u0E44\u0E1A\u0E15\u0E4C",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    array: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    set: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)"
            : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
        case "object": {
          if (Array.isArray(t))
            return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
          if (t === null)
            return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex:
        "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
      email:
        "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
      url: "URL",
      emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
      time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      duration:
        "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
      ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
      cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
      cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
      base64:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
      base64url:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
      json_string:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
      e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
      jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
      template_literal:
        "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${t.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${b(t.values[0])}`
          : `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive
            ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19"
            : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32",
          a = n(t.origin);
        return a
          ? `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.maximum.toString()} ${a.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`
          : `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive
            ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22"
            : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32",
          a = n(t.origin);
        return a
          ? `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.minimum.toString()} ${a.unit}`
          : `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${o.suffix}"`
            : o.format === "includes"
              ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${o.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`
              : o.format === "regex"
                ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${o.pattern}`
                : `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${t.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${t.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${t.origin}`;
      default:
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07";
    }
  };
};
function rl() {
  return { localeError: Zc() };
}
var Rc = (e) => {
    let n = typeof e;
    switch (n) {
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(e)) return "array";
        if (e === null) return "null";
        if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
          return e.constructor.name;
      }
    }
    return n;
  },
  Cc = () => {
    let e = {
      string: { unit: "karakter", verb: "olmal\u0131" },
      file: { unit: "bayt", verb: "olmal\u0131" },
      array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
      set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    };
    function n(i) {
      return e[i] ?? null;
    }
    let r = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO s\xFCre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aral\u0131\u011F\u0131",
      cidrv6: "IPv6 aral\u0131\u011F\u0131",
      base64: "base64 ile \u015Fifrelenmi\u015F metin",
      base64url: "base64url ile \u015Fifrelenmi\u015F metin",
      json_string: "JSON dizesi",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "\u015Eablon dizesi",
    };
    return (i) => {
      switch (i.code) {
        case "invalid_type":
          return `Ge\xE7ersiz de\u011Fer: beklenen ${i.expected}, al\u0131nan ${Rc(i.input)}`;
        case "invalid_value":
          return i.values.length === 1
            ? `Ge\xE7ersiz de\u011Fer: beklenen ${b(i.values[0])}`
            : `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${_(i.values, "|")}`;
        case "too_big": {
          let t = i.inclusive ? "<=" : "<",
            o = n(i.origin);
          return o
            ? `\xC7ok b\xFCy\xFCk: beklenen ${i.origin ?? "de\u011Fer"} ${t}${i.maximum.toString()} ${o.unit ?? "\xF6\u011Fe"}`
            : `\xC7ok b\xFCy\xFCk: beklenen ${i.origin ?? "de\u011Fer"} ${t}${i.maximum.toString()}`;
        }
        case "too_small": {
          let t = i.inclusive ? ">=" : ">",
            o = n(i.origin);
          return o
            ? `\xC7ok k\xFC\xE7\xFCk: beklenen ${i.origin} ${t}${i.minimum.toString()} ${o.unit}`
            : `\xC7ok k\xFC\xE7\xFCk: beklenen ${i.origin} ${t}${i.minimum.toString()}`;
        }
        case "invalid_format": {
          let t = i;
          return t.format === "starts_with"
            ? `Ge\xE7ersiz metin: "${t.prefix}" ile ba\u015Flamal\u0131`
            : t.format === "ends_with"
              ? `Ge\xE7ersiz metin: "${t.suffix}" ile bitmeli`
              : t.format === "includes"
                ? `Ge\xE7ersiz metin: "${t.includes}" i\xE7ermeli`
                : t.format === "regex"
                  ? `Ge\xE7ersiz metin: ${t.pattern} desenine uymal\u0131`
                  : `Ge\xE7ersiz ${r[t.format] ?? i.format}`;
        }
        case "not_multiple_of":
          return `Ge\xE7ersiz say\u0131: ${i.divisor} ile tam b\xF6l\xFCnebilmeli`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar${i.keys.length > 1 ? "lar" : ""}: ${_(i.keys, ", ")}`;
        case "invalid_key":
          return `${i.origin} i\xE7inde ge\xE7ersiz anahtar`;
        case "invalid_union":
          return "Ge\xE7ersiz de\u011Fer";
        case "invalid_element":
          return `${i.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
        default:
          return "Ge\xE7ersiz de\u011Fer";
      }
    };
  };
function ol() {
  return { localeError: Cc() };
}
var Mc = () => {
  let e = {
    string: {
      unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    file: {
      unit: "\u0431\u0430\u0439\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    array: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    set: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0438\u0432";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
      email:
        "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
      date: "\u0434\u0430\u0442\u0430 ISO",
      time: "\u0447\u0430\u0441 ISO",
      duration:
        "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
      ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
      ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
      cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
      cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
      base64:
        "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
      base64url:
        "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
      json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal:
        "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${t.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${b(t.values[0])}`
          : `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`
          : `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin} \u0431\u0443\u0434\u0435 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${t.keys.length > 1 ? "\u0456" : ""}: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${t.origin}`;
      default:
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
    }
  };
};
function il() {
  return { localeError: Mc() };
}
var Lc = () => {
  let e = {
    string: {
      unit: "\u062D\u0631\u0648\u0641",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    file: {
      unit: "\u0628\u0627\u0626\u0679\u0633",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    array: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    set: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0646\u0645\u0628\u0631";
        case "object": {
          if (Array.isArray(t)) return "\u0622\u0631\u06D2";
          if (t === null) return "\u0646\u0644";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0627\u0646 \u067E\u0679",
      email:
        "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      uuidv4:
        "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
      uuidv6:
        "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
      nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
      ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
      xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
      ksuid:
        "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      datetime:
        "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
      date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
      time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
      duration:
        "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
      ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      cidrv4:
        "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
      cidrv6:
        "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
      base64:
        "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      base64url:
        "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      json_string:
        "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
      e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
      jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
      template_literal: "\u0627\u0646 \u067E\u0679",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${t.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${r(t.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${b(t.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`
          : `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${_(t.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u0628\u06C1\u062A \u0628\u0691\u0627: ${t.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${o}${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`
          : `\u0628\u06C1\u062A \u0628\u0691\u0627: ${t.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${o}${t.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${t.origin} \u06A9\u06D2 ${o}${t.minimum.toString()} ${a.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`
          : `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${t.origin} \u06A9\u0627 ${o}${t.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
          : o.format === "ends_with"
            ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
            : o.format === "includes"
              ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
              : o.format === "regex"
                ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${o.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
                : `\u063A\u0644\u0637 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${t.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${t.keys.length > 1 ? "\u0632" : ""}: ${_(t.keys, "\u060C ")}`;
      case "invalid_key":
        return `${t.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${t.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
    }
  };
};
function al() {
  return { localeError: Lc() };
}
var Vc = () => {
  let e = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "s\u1ED1";
        case "object": {
          if (Array.isArray(t)) return "m\u1EA3ng";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0111\u1EA7u v\xE0o",
      email: "\u0111\u1ECBa ch\u1EC9 email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ng\xE0y gi\u1EDD ISO",
      date: "ng\xE0y ISO",
      time: "gi\u1EDD ISO",
      duration: "kho\u1EA3ng th\u1EDDi gian ISO",
      ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
      ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
      cidrv4: "d\u1EA3i IPv4",
      cidrv6: "d\u1EA3i IPv6",
      base64: "chu\u1ED7i m\xE3 h\xF3a base64",
      base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
      json_string: "chu\u1ED7i JSON",
      e164: "s\u1ED1 E.164",
      jwt: "JWT",
      template_literal: "\u0111\u1EA7u v\xE0o",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${t.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${b(t.values[0])}`
          : `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${t.origin ?? "gi\xE1 tr\u1ECB"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "ph\u1EA7n t\u1EED"}`
          : `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${t.origin ?? "gi\xE1 tr\u1ECB"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${o.prefix}"`
          : o.format === "ends_with"
            ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${o.suffix}"`
            : o.format === "includes"
              ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${o.includes}"`
              : o.format === "regex"
                ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${o.pattern}`
                : `${i[o.format] ?? t.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${t.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${t.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${t.origin}`;
      default:
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
    }
  };
};
function sl() {
  return { localeError: Vc() };
}
var Fc = () => {
  let e = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
        case "object": {
          if (Array.isArray(t)) return "\u6570\u7EC4";
          if (t === null) return "\u7A7A\u503C(null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u8F93\u5165",
      email: "\u7535\u5B50\u90AE\u4EF6",
      url: "URL",
      emoji: "\u8868\u60C5\u7B26\u53F7",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u671F\u65F6\u95F4",
      date: "ISO\u65E5\u671F",
      time: "ISO\u65F6\u95F4",
      duration: "ISO\u65F6\u957F",
      ipv4: "IPv4\u5730\u5740",
      ipv6: "IPv6\u5730\u5740",
      cidrv4: "IPv4\u7F51\u6BB5",
      cidrv6: "IPv6\u7F51\u6BB5",
      base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
      base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
      json_string: "JSON\u5B57\u7B26\u4E32",
      e164: "E.164\u53F7\u7801",
      jwt: "JWT",
      template_literal: "\u8F93\u5165",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${t.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${b(t.values[0])}`
          : `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${t.origin ?? "\u503C"} ${o}${t.maximum.toString()} ${a.unit ?? "\u4E2A\u5143\u7D20"}`
          : `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${t.origin ?? "\u503C"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${t.origin} ${o}${t.minimum.toString()} ${a.unit}`
          : `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${o.prefix}" \u5F00\u5934`
          : o.format === "ends_with"
            ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${o.suffix}" \u7ED3\u5C3E`
            : o.format === "includes"
              ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${o.includes}"`
              : o.format === "regex"
                ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${o.pattern}`
                : `\u65E0\u6548${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${t.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${_(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${t.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return "\u65E0\u6548\u8F93\u5165";
    }
  };
};
function ll() {
  return { localeError: Fc() };
}
var qc = () => {
  let e = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
  };
  function n(t) {
    return e[t] ?? null;
  }
  let r = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u8F38\u5165",
      email: "\u90F5\u4EF6\u5730\u5740",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u65E5\u671F\u6642\u9593",
      date: "ISO \u65E5\u671F",
      time: "ISO \u6642\u9593",
      duration: "ISO \u671F\u9593",
      ipv4: "IPv4 \u4F4D\u5740",
      ipv6: "IPv6 \u4F4D\u5740",
      cidrv4: "IPv4 \u7BC4\u570D",
      cidrv6: "IPv6 \u7BC4\u570D",
      base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
      base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
      json_string: "JSON \u5B57\u4E32",
      e164: "E.164 \u6578\u503C",
      jwt: "JWT",
      template_literal: "\u8F38\u5165",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${t.expected}\uFF0C\u4F46\u6536\u5230 ${r(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${b(t.values[0])}`
          : `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${_(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = n(t.origin);
        return a
          ? `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${t.origin ?? "\u503C"} \u61C9\u70BA ${o}${t.maximum.toString()} ${a.unit ?? "\u500B\u5143\u7D20"}`
          : `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${t.origin ?? "\u503C"} \u61C9\u70BA ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = n(t.origin);
        return a
          ? `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${t.origin} \u61C9\u70BA ${o}${t.minimum.toString()} ${a.unit}`
          : `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${t.origin} \u61C9\u70BA ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${o.prefix}" \u958B\u982D`
          : o.format === "ends_with"
            ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${o.suffix}" \u7D50\u5C3E`
            : o.format === "includes"
              ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${o.includes}"`
              : o.format === "regex"
                ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${o.pattern}`
                : `\u7121\u6548\u7684 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${t.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${t.keys.length > 1 ? "\u5011" : ""}\uFF1A${_(t.keys, "\u3001")}`;
      case "invalid_key":
        return `${t.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${t.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
    }
  };
};
function ul() {
  return { localeError: qc() };
}
var pi = Symbol("ZodOutput"),
  fi = Symbol("ZodInput"),
  Ue = class {
    constructor() {
      ((this._map = new WeakMap()), (this._idmap = new Map()));
    }
    add(n, ...r) {
      let i = r[0];
      if ((this._map.set(n, i), i && typeof i == "object" && "id" in i)) {
        if (this._idmap.has(i.id))
          throw new Error(`ID ${i.id} already exists in the registry`);
        this._idmap.set(i.id, n);
      }
      return this;
    }
    remove(n) {
      return (this._map.delete(n), this);
    }
    get(n) {
      let r = n._zod.parent;
      if (r) {
        let i = { ...(this.get(r) ?? {}) };
        return (delete i.id, { ...i, ...this._map.get(n) });
      }
      return this._map.get(n);
    }
    has(n) {
      return this._map.has(n);
    }
  };
function nn() {
  return new Ue();
}
var ae = nn();
function gi(e, n) {
  return new e({ type: "string", ...h(n) });
}
function hi(e, n) {
  return new e({ type: "string", coerce: !0, ...h(n) });
}
function rn(e, n) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function dt(e, n) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function on(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function an(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...h(n),
  });
}
function sn(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...h(n),
  });
}
function ln(e, n) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...h(n),
  });
}
function un(e, n) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function cn(e, n) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function dn(e, n) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function _n(e, n) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function mn(e, n) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function pn(e, n) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function fn(e, n) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function gn(e, n) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function hn(e, n) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function vn(e, n) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function yn(e, n) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function bn(e, n) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function wn(e, n) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function kn(e, n) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function xn(e, n) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function $n(e, n) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...h(n),
  });
}
function vi(e, n) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...h(n),
  });
}
function yi(e, n) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...h(n),
  });
}
function bi(e, n) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...h(n),
  });
}
function wi(e, n) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...h(n),
  });
}
function ki(e, n) {
  return new e({ type: "number", checks: [], ...h(n) });
}
function xi(e, n) {
  return new e({ type: "number", coerce: !0, checks: [], ...h(n) });
}
function $i(e, n) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...h(n),
  });
}
function zi(e, n) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...h(n),
  });
}
function Si(e, n) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...h(n),
  });
}
function Ii(e, n) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...h(n),
  });
}
function Ai(e, n) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...h(n),
  });
}
function Pi(e, n) {
  return new e({ type: "boolean", ...h(n) });
}
function Di(e, n) {
  return new e({ type: "boolean", coerce: !0, ...h(n) });
}
function ji(e, n) {
  return new e({ type: "bigint", ...h(n) });
}
function Oi(e, n) {
  return new e({ type: "bigint", coerce: !0, ...h(n) });
}
function Ti(e, n) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...h(n),
  });
}
function Ni(e, n) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...h(n),
  });
}
function Ei(e, n) {
  return new e({ type: "symbol", ...h(n) });
}
function Ui(e, n) {
  return new e({ type: "undefined", ...h(n) });
}
function Zi(e, n) {
  return new e({ type: "null", ...h(n) });
}
function Ri(e) {
  return new e({ type: "any" });
}
function Ze(e) {
  return new e({ type: "unknown" });
}
function Ci(e, n) {
  return new e({ type: "never", ...h(n) });
}
function Mi(e, n) {
  return new e({ type: "void", ...h(n) });
}
function Li(e, n) {
  return new e({ type: "date", ...h(n) });
}
function Vi(e, n) {
  return new e({ type: "date", coerce: !0, ...h(n) });
}
function Fi(e, n) {
  return new e({ type: "nan", ...h(n) });
}
function ue(e, n) {
  return new Kt({ check: "less_than", ...h(n), value: e, inclusive: !1 });
}
function Q(e, n) {
  return new Kt({ check: "less_than", ...h(n), value: e, inclusive: !0 });
}
function ce(e, n) {
  return new Jt({ check: "greater_than", ...h(n), value: e, inclusive: !1 });
}
function W(e, n) {
  return new Jt({ check: "greater_than", ...h(n), value: e, inclusive: !0 });
}
function qi(e) {
  return ce(0, e);
}
function Wi(e) {
  return ue(0, e);
}
function Hi(e) {
  return Q(0, e);
}
function Bi(e) {
  return W(0, e);
}
function Ie(e, n) {
  return new Wr({ check: "multiple_of", ...h(n), value: e });
}
function Re(e, n) {
  return new Kr({ check: "max_size", ...h(n), maximum: e });
}
function Ae(e, n) {
  return new Jr({ check: "min_size", ...h(n), minimum: e });
}
function _t(e, n) {
  return new Yr({ check: "size_equals", ...h(n), size: e });
}
function Ce(e, n) {
  return new Gr({ check: "max_length", ...h(n), maximum: e });
}
function ve(e, n) {
  return new Xr({ check: "min_length", ...h(n), minimum: e });
}
function Me(e, n) {
  return new Qr({ check: "length_equals", ...h(n), length: e });
}
function mt(e, n) {
  return new eo({
    check: "string_format",
    format: "regex",
    ...h(n),
    pattern: e,
  });
}
function pt(e) {
  return new to({ check: "string_format", format: "lowercase", ...h(e) });
}
function ft(e) {
  return new no({ check: "string_format", format: "uppercase", ...h(e) });
}
function gt(e, n) {
  return new ro({
    check: "string_format",
    format: "includes",
    ...h(n),
    includes: e,
  });
}
function ht(e, n) {
  return new oo({
    check: "string_format",
    format: "starts_with",
    ...h(n),
    prefix: e,
  });
}
function vt(e, n) {
  return new io({
    check: "string_format",
    format: "ends_with",
    ...h(n),
    suffix: e,
  });
}
function Ki(e, n, r) {
  return new ao({ check: "property", property: e, schema: n, ...h(r) });
}
function yt(e, n) {
  return new so({ check: "mime_type", mime: e, ...h(n) });
}
function de(e) {
  return new lo({ check: "overwrite", tx: e });
}
function bt(e) {
  return de((n) => n.normalize(e));
}
function wt() {
  return de((e) => e.trim());
}
function kt() {
  return de((e) => e.toLowerCase());
}
function xt() {
  return de((e) => e.toUpperCase());
}
function $t(e, n, r) {
  return new e({ type: "array", element: n, ...h(r) });
}
function Wc(e, n, r) {
  return new e({ type: "union", options: n, ...h(r) });
}
function Hc(e, n, r, i) {
  return new e({ type: "union", options: r, discriminator: n, ...h(i) });
}
function Bc(e, n, r) {
  return new e({ type: "intersection", left: n, right: r });
}
function Ji(e, n, r, i) {
  let t = r instanceof $,
    o = t ? i : r,
    a = t ? r : null;
  return new e({ type: "tuple", items: n, rest: a, ...h(o) });
}
function Kc(e, n, r, i) {
  return new e({ type: "record", keyType: n, valueType: r, ...h(i) });
}
function Jc(e, n, r, i) {
  return new e({ type: "map", keyType: n, valueType: r, ...h(i) });
}
function Yc(e, n, r) {
  return new e({ type: "set", valueType: n, ...h(r) });
}
function Gc(e, n, r) {
  let i = Array.isArray(n) ? Object.fromEntries(n.map((t) => [t, t])) : n;
  return new e({ type: "enum", entries: i, ...h(r) });
}
function Xc(e, n, r) {
  return new e({ type: "enum", entries: n, ...h(r) });
}
function Qc(e, n, r) {
  return new e({
    type: "literal",
    values: Array.isArray(n) ? n : [n],
    ...h(r),
  });
}
function Yi(e, n) {
  return new e({ type: "file", ...h(n) });
}
function ed(e, n) {
  return new e({ type: "transform", transform: n });
}
function td(e, n) {
  return new e({ type: "optional", innerType: n });
}
function nd(e, n) {
  return new e({ type: "nullable", innerType: n });
}
function rd(e, n, r) {
  return new e({
    type: "default",
    innerType: n,
    get defaultValue() {
      return typeof r == "function" ? r() : r;
    },
  });
}
function od(e, n, r) {
  return new e({ type: "nonoptional", innerType: n, ...h(r) });
}
function id(e, n) {
  return new e({ type: "success", innerType: n });
}
function ad(e, n, r) {
  return new e({
    type: "catch",
    innerType: n,
    catchValue: typeof r == "function" ? r : () => r,
  });
}
function sd(e, n, r) {
  return new e({ type: "pipe", in: n, out: r });
}
function ld(e, n) {
  return new e({ type: "readonly", innerType: n });
}
function ud(e, n, r) {
  return new e({ type: "template_literal", parts: n, ...h(r) });
}
function cd(e, n) {
  return new e({ type: "lazy", getter: n });
}
function dd(e, n) {
  return new e({ type: "promise", innerType: n });
}
function Gi(e, n, r) {
  let i = h(r);
  return (
    i.abort ?? (i.abort = !0),
    new e({ type: "custom", check: "custom", fn: n, ...i })
  );
}
function Xi(e, n, r) {
  return new e({ type: "custom", check: "custom", fn: n, ...h(r) });
}
function Qi(e, n) {
  let { case: r, error: i, truthy: t, falsy: o } = h(n),
    a = new Set(t ?? ["true", "1", "yes", "on", "y", "enabled"]),
    s = new Set(o ?? ["false", "0", "no", "off", "n", "disabled"]),
    l = e.Pipe ?? ut,
    u = e.Boolean ?? st,
    m = e.Unknown ?? he,
    p = new m({
      type: "unknown",
      checks: [
        {
          _zod: {
            check: (f) => {
              if (typeof f.value == "string") {
                let d = f.value;
                (r !== "sensitive" && (d = d.toLowerCase()),
                  a.has(d)
                    ? (f.value = !0)
                    : s.has(d)
                      ? (f.value = !1)
                      : f.issues.push({
                          code: "invalid_value",
                          expected: "stringbool",
                          values: [...a, ...s],
                          input: f.value,
                          inst: p,
                        }));
              } else
                f.issues.push({
                  code: "invalid_type",
                  expected: "string",
                  input: f.value,
                });
            },
            def: { check: "custom" },
            onattach: [],
          },
        },
      ],
      error: i,
    });
  return new l({
    type: "pipe",
    in: p,
    out: new u({ type: "boolean", error: i }),
    error: i,
  });
}
var zn = class {
  constructor(n) {
    ((this._def = n), (this.def = n));
  }
  implement(n) {
    if (typeof n != "function")
      throw new Error("implement() must be called with a function");
    let r = (...i) => {
      let t = this._def.input
        ? Vt(this._def.input, i, void 0, { callee: r })
        : i;
      if (!Array.isArray(t))
        throw new Error(
          "Invalid arguments schema: not an array or tuple schema.",
        );
      let o = n(...t);
      return this._def.output
        ? Vt(this._def.output, o, void 0, { callee: r })
        : o;
    };
    return r;
  }
  implementAsync(n) {
    if (typeof n != "function")
      throw new Error("implement() must be called with a function");
    let r = async (...i) => {
      let t = this._def.input
        ? await qt(this._def.input, i, void 0, { callee: r })
        : i;
      if (!Array.isArray(t))
        throw new Error(
          "Invalid arguments schema: not an array or tuple schema.",
        );
      let o = await n(...t);
      return this._def.output
        ? qt(this._def.output, o, void 0, { callee: r })
        : o;
    };
    return r;
  }
  input(...n) {
    let r = this.constructor;
    return Array.isArray(n[0])
      ? new r({
          type: "function",
          input: new Se({ type: "tuple", items: n[0], rest: n[1] }),
          output: this._def.output,
        })
      : new r({ type: "function", input: n[0], output: this._def.output });
  }
  output(n) {
    let r = this.constructor;
    return new r({ type: "function", input: this._def.input, output: n });
  }
};
function ea(e) {
  return new zn({
    type: "function",
    input: Array.isArray(e?.input)
      ? Ji(Se, e?.input)
      : (e?.input ?? $t(lt, Ze(he))),
    output: e?.output ?? Ze(he),
  });
}
var zt = class {
  constructor(n) {
    ((this.counter = 0),
      (this.metadataRegistry = n?.metadata ?? ae),
      (this.target = n?.target ?? "draft-2020-12"),
      (this.unrepresentable = n?.unrepresentable ?? "throw"),
      (this.override = n?.override ?? (() => {})),
      (this.io = n?.io ?? "output"),
      (this.seen = new Map()));
  }
  process(n, r = { path: [], schemaPath: [] }) {
    var i;
    let t = n._zod.def,
      o = {
        guid: "uuid",
        url: "uri",
        datetime: "date-time",
        json_string: "json-string",
        regex: "",
      },
      a = this.seen.get(n);
    if (a)
      return (
        a.count++,
        r.schemaPath.includes(n) && (a.cycle = r.path),
        a.schema
      );
    let s = { schema: {}, count: 1, cycle: void 0 };
    (this.seen.set(n, s),
      n._zod.toJSONSchema && (s.schema = n._zod.toJSONSchema()));
    let l = { ...r, schemaPath: [...r.schemaPath, n], path: r.path },
      u = n._zod.parent;
    if (u) ((s.ref = u), this.process(u, l), (this.seen.get(u).isParent = !0));
    else {
      let f = s.schema;
      switch (t.type) {
        case "string": {
          let d = f;
          d.type = "string";
          let {
            minimum: v,
            maximum: k,
            format: P,
            patterns: j,
            contentEncoding: S,
          } = n._zod.bag;
          if (
            (typeof v == "number" && (d.minLength = v),
            typeof k == "number" && (d.maxLength = k),
            P && ((d.format = o[P] ?? P), d.format === "" && delete d.format),
            S && (d.contentEncoding = S),
            j && j.size > 0)
          ) {
            let z = [...j];
            z.length === 1
              ? (d.pattern = z[0].source)
              : z.length > 1 &&
                (s.schema.allOf = [
                  ...z.map((w) => ({
                    ...(this.target === "draft-7" ? { type: "string" } : {}),
                    pattern: w.source,
                  })),
                ]);
          }
          break;
        }
        case "number": {
          let d = f,
            {
              minimum: v,
              maximum: k,
              format: P,
              multipleOf: j,
              exclusiveMaximum: S,
              exclusiveMinimum: z,
            } = n._zod.bag;
          (typeof P == "string" && P.includes("int")
            ? (d.type = "integer")
            : (d.type = "number"),
            typeof z == "number" && (d.exclusiveMinimum = z),
            typeof v == "number" &&
              ((d.minimum = v),
              typeof z == "number" &&
                (z >= v ? delete d.minimum : delete d.exclusiveMinimum)),
            typeof S == "number" && (d.exclusiveMaximum = S),
            typeof k == "number" &&
              ((d.maximum = k),
              typeof S == "number" &&
                (S <= k ? delete d.maximum : delete d.exclusiveMaximum)),
            typeof j == "number" && (d.multipleOf = j));
          break;
        }
        case "boolean": {
          let d = f;
          d.type = "boolean";
          break;
        }
        case "bigint": {
          if (this.unrepresentable === "throw")
            throw new Error("BigInt cannot be represented in JSON Schema");
          break;
        }
        case "symbol": {
          if (this.unrepresentable === "throw")
            throw new Error("Symbols cannot be represented in JSON Schema");
          break;
        }
        case "undefined": {
          let d = f;
          d.type = "null";
          break;
        }
        case "null": {
          f.type = "null";
          break;
        }
        case "any":
          break;
        case "unknown":
          break;
        case "never": {
          f.not = {};
          break;
        }
        case "void": {
          if (this.unrepresentable === "throw")
            throw new Error("Void cannot be represented in JSON Schema");
          break;
        }
        case "date": {
          if (this.unrepresentable === "throw")
            throw new Error("Date cannot be represented in JSON Schema");
          break;
        }
        case "array": {
          let d = f,
            { minimum: v, maximum: k } = n._zod.bag;
          (typeof v == "number" && (d.minItems = v),
            typeof k == "number" && (d.maxItems = k),
            (d.type = "array"),
            (d.items = this.process(t.element, {
              ...l,
              path: [...l.path, "items"],
            })));
          break;
        }
        case "object": {
          let d = f;
          ((d.type = "object"), (d.properties = {}));
          let v = t.shape;
          for (let j in v)
            d.properties[j] = this.process(v[j], {
              ...l,
              path: [...l.path, "properties", j],
            });
          let k = new Set(Object.keys(v)),
            P = new Set(
              [...k].filter((j) => {
                let S = t.shape[j]._zod;
                return this.io === "input"
                  ? S.optin === void 0
                  : S.optout === void 0;
              }),
            );
          (P.size > 0 && (d.required = Array.from(P)),
            t.catchall?._zod.def.type === "never"
              ? (d.additionalProperties = !1)
              : t.catchall
                ? t.catchall &&
                  (d.additionalProperties = this.process(t.catchall, {
                    ...l,
                    path: [...l.path, "additionalProperties"],
                  }))
                : this.io === "output" && (d.additionalProperties = !1));
          break;
        }
        case "union": {
          let d = f;
          d.anyOf = t.options.map((v, k) =>
            this.process(v, { ...l, path: [...l.path, "anyOf", k] }),
          );
          break;
        }
        case "intersection": {
          let d = f,
            v = this.process(t.left, { ...l, path: [...l.path, "allOf", 0] }),
            k = this.process(t.right, { ...l, path: [...l.path, "allOf", 1] }),
            P = (S) => "allOf" in S && Object.keys(S).length === 1,
            j = [...(P(v) ? v.allOf : [v]), ...(P(k) ? k.allOf : [k])];
          d.allOf = j;
          break;
        }
        case "tuple": {
          let d = f;
          d.type = "array";
          let v = t.items.map((j, S) =>
            this.process(j, { ...l, path: [...l.path, "prefixItems", S] }),
          );
          if (
            (this.target === "draft-2020-12"
              ? (d.prefixItems = v)
              : (d.items = v),
            t.rest)
          ) {
            let j = this.process(t.rest, { ...l, path: [...l.path, "items"] });
            this.target === "draft-2020-12"
              ? (d.items = j)
              : (d.additionalItems = j);
          }
          t.rest &&
            (d.items = this.process(t.rest, {
              ...l,
              path: [...l.path, "items"],
            }));
          let { minimum: k, maximum: P } = n._zod.bag;
          (typeof k == "number" && (d.minItems = k),
            typeof P == "number" && (d.maxItems = P));
          break;
        }
        case "record": {
          let d = f;
          ((d.type = "object"),
            (d.propertyNames = this.process(t.keyType, {
              ...l,
              path: [...l.path, "propertyNames"],
            })),
            (d.additionalProperties = this.process(t.valueType, {
              ...l,
              path: [...l.path, "additionalProperties"],
            })));
          break;
        }
        case "map": {
          if (this.unrepresentable === "throw")
            throw new Error("Map cannot be represented in JSON Schema");
          break;
        }
        case "set": {
          if (this.unrepresentable === "throw")
            throw new Error("Set cannot be represented in JSON Schema");
          break;
        }
        case "enum": {
          let d = f,
            v = Je(t.entries);
          (v.every((k) => typeof k == "number") && (d.type = "number"),
            v.every((k) => typeof k == "string") && (d.type = "string"),
            (d.enum = v));
          break;
        }
        case "literal": {
          let d = f,
            v = [];
          for (let k of t.values)
            if (k === void 0) {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "Literal `undefined` cannot be represented in JSON Schema",
                );
            } else if (typeof k == "bigint") {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "BigInt literals cannot be represented in JSON Schema",
                );
              v.push(Number(k));
            } else v.push(k);
          if (v.length !== 0)
            if (v.length === 1) {
              let k = v[0];
              ((d.type = k === null ? "null" : typeof k), (d.const = k));
            } else
              (v.every((k) => typeof k == "number") && (d.type = "number"),
                v.every((k) => typeof k == "string") && (d.type = "string"),
                v.every((k) => typeof k == "boolean") && (d.type = "string"),
                v.every((k) => k === null) && (d.type = "null"),
                (d.enum = v));
          break;
        }
        case "file": {
          let d = f,
            v = { type: "string", format: "binary", contentEncoding: "binary" },
            { minimum: k, maximum: P, mime: j } = n._zod.bag;
          (k !== void 0 && (v.minLength = k),
            P !== void 0 && (v.maxLength = P),
            j
              ? j.length === 1
                ? ((v.contentMediaType = j[0]), Object.assign(d, v))
                : (d.anyOf = j.map((S) => ({ ...v, contentMediaType: S })))
              : Object.assign(d, v));
          break;
        }
        case "transform": {
          if (this.unrepresentable === "throw")
            throw new Error("Transforms cannot be represented in JSON Schema");
          break;
        }
        case "nullable": {
          let d = this.process(t.innerType, l);
          f.anyOf = [d, { type: "null" }];
          break;
        }
        case "nonoptional": {
          (this.process(t.innerType, l), (s.ref = t.innerType));
          break;
        }
        case "success": {
          let d = f;
          d.type = "boolean";
          break;
        }
        case "default": {
          (this.process(t.innerType, l),
            (s.ref = t.innerType),
            (f.default = t.defaultValue));
          break;
        }
        case "prefault": {
          (this.process(t.innerType, l),
            (s.ref = t.innerType),
            this.io === "input" && (f._prefault = t.defaultValue));
          break;
        }
        case "catch": {
          (this.process(t.innerType, l), (s.ref = t.innerType));
          let d;
          try {
            d = t.catchValue(void 0);
          } catch {
            throw new Error(
              "Dynamic catch values are not supported in JSON Schema",
            );
          }
          f.default = d;
          break;
        }
        case "nan": {
          if (this.unrepresentable === "throw")
            throw new Error("NaN cannot be represented in JSON Schema");
          break;
        }
        case "template_literal": {
          let d = f,
            v = n._zod.pattern;
          if (!v) throw new Error("Pattern not found in template literal");
          ((d.type = "string"), (d.pattern = v.source));
          break;
        }
        case "pipe": {
          let d =
            this.io === "input"
              ? t.in._zod.def.type === "transform"
                ? t.out
                : t.in
              : t.out;
          (this.process(d, l), (s.ref = d));
          break;
        }
        case "readonly": {
          (this.process(t.innerType, l),
            (s.ref = t.innerType),
            (f.readOnly = !0));
          break;
        }
        case "promise": {
          (this.process(t.innerType, l), (s.ref = t.innerType));
          break;
        }
        case "optional": {
          (this.process(t.innerType, l), (s.ref = t.innerType));
          break;
        }
        case "lazy": {
          let d = n._zod.innerType;
          (this.process(d, l), (s.ref = d));
          break;
        }
        case "custom": {
          if (this.unrepresentable === "throw")
            throw new Error(
              "Custom types cannot be represented in JSON Schema",
            );
          break;
        }
        default:
      }
    }
    let m = this.metadataRegistry.get(n);
    return (
      m && Object.assign(s.schema, m),
      this.io === "input" &&
        V(n) &&
        (delete s.schema.examples, delete s.schema.default),
      this.io === "input" &&
        s.schema._prefault &&
        ((i = s.schema).default ?? (i.default = s.schema._prefault)),
      delete s.schema._prefault,
      this.seen.get(n).schema
    );
  }
  emit(n, r) {
    let i = {
        cycles: r?.cycles ?? "ref",
        reused: r?.reused ?? "inline",
        external: r?.external ?? void 0,
      },
      t = this.seen.get(n);
    if (!t) throw new Error("Unprocessed schema. This is a bug in Zod.");
    let o = (m) => {
        let p = this.target === "draft-2020-12" ? "$defs" : "definitions";
        if (i.external) {
          let k = i.external.registry.get(m[0])?.id;
          if (k) return { ref: i.external.uri(k) };
          let P = m[1].defId ?? m[1].schema.id ?? `schema${this.counter++}`;
          return (
            (m[1].defId = P),
            { defId: P, ref: `${i.external.uri("__shared")}#/${p}/${P}` }
          );
        }
        if (m[1] === t) return { ref: "#" };
        let d = `#/${p}/`,
          v = m[1].schema.id ?? `__schema${this.counter++}`;
        return { defId: v, ref: d + v };
      },
      a = (m) => {
        if (m[1].schema.$ref) return;
        let p = m[1],
          { ref: f, defId: d } = o(m);
        ((p.def = { ...p.schema }), d && (p.defId = d));
        let v = p.schema;
        for (let k in v) delete v[k];
        v.$ref = f;
      };
    for (let m of this.seen.entries()) {
      let p = m[1];
      if (n === m[0]) {
        a(m);
        continue;
      }
      if (i.external) {
        let d = i.external.registry.get(m[0])?.id;
        if (n !== m[0] && d) {
          a(m);
          continue;
        }
      }
      if (this.metadataRegistry.get(m[0])?.id) {
        a(m);
        continue;
      }
      if (p.cycle) {
        if (i.cycles === "throw")
          throw new Error(`Cycle detected: #/${p.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        i.cycles === "ref" && a(m);
        continue;
      }
      if (p.count > 1 && i.reused === "ref") {
        a(m);
        continue;
      }
    }
    let s = (m, p) => {
      let f = this.seen.get(m),
        d = f.def ?? f.schema,
        v = { ...d };
      if (f.ref === null) return;
      let k = f.ref;
      if (((f.ref = null), k)) {
        s(k, p);
        let P = this.seen.get(k).schema;
        P.$ref && p.target === "draft-7"
          ? ((d.allOf = d.allOf ?? []), d.allOf.push(P))
          : (Object.assign(d, P), Object.assign(d, v));
      }
      f.isParent || this.override({ zodSchema: m, jsonSchema: d });
    };
    for (let m of [...this.seen.entries()].reverse())
      s(m[0], { target: this.target });
    let l = {};
    (this.target === "draft-2020-12"
      ? (l.$schema = "https://json-schema.org/draft/2020-12/schema")
      : this.target === "draft-7"
        ? (l.$schema = "http://json-schema.org/draft-07/schema#")
        : console.warn(`Invalid target: ${this.target}`),
      Object.assign(l, t.def));
    let u = i.external?.defs ?? {};
    for (let m of this.seen.entries()) {
      let p = m[1];
      p.def && p.defId && (u[p.defId] = p.def);
    }
    !i.external &&
      Object.keys(u).length > 0 &&
      (this.target === "draft-2020-12" ? (l.$defs = u) : (l.definitions = u));
    try {
      return JSON.parse(JSON.stringify(l));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function ta(e, n) {
  if (e instanceof Ue) {
    let i = new zt(n),
      t = {};
    for (let s of e._idmap.entries()) {
      let [l, u] = s;
      i.process(u);
    }
    let o = {},
      a = { registry: e, uri: n?.uri || ((s) => s), defs: t };
    for (let s of e._idmap.entries()) {
      let [l, u] = s;
      o[l] = i.emit(u, { ...n, external: a });
    }
    if (Object.keys(t).length > 0) {
      let s = i.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = { [s]: t };
    }
    return { schemas: o };
  }
  let r = new zt(n);
  return (r.process(e), r.emit(e, n));
}
function V(e, n) {
  let r = n ?? { seen: new Set() };
  if (r.seen.has(e)) return !1;
  r.seen.add(e);
  let t = e._zod.def;
  switch (t.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return V(t.element, r);
    case "object": {
      for (let o in t.shape) if (V(t.shape[o], r)) return !0;
      return !1;
    }
    case "union": {
      for (let o of t.options) if (V(o, r)) return !0;
      return !1;
    }
    case "intersection":
      return V(t.left, r) || V(t.right, r);
    case "tuple": {
      for (let o of t.items) if (V(o, r)) return !0;
      return !!(t.rest && V(t.rest, r));
    }
    case "record":
      return V(t.keyType, r) || V(t.valueType, r);
    case "map":
      return V(t.keyType, r) || V(t.valueType, r);
    case "set":
      return V(t.valueType, r);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return V(t.innerType, r);
    case "lazy":
      return V(t.getter(), r);
    case "default":
      return V(t.innerType, r);
    case "prefault":
      return V(t.innerType, r);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return V(t.in, r) || V(t.out, r);
    case "success":
      return !1;
    case "catch":
      return !1;
    default:
  }
  throw new Error(`Unknown schema type: ${t.type}`);
}
var cl = {};
var Dn = {};
ye(Dn, {
  ZodISODate: () => In,
  ZodISODateTime: () => Sn,
  ZodISODuration: () => Pn,
  ZodISOTime: () => An,
  date: () => ra,
  datetime: () => na,
  duration: () => ia,
  time: () => oa,
});
var Sn = c("ZodISODateTime", (e, n) => {
  (xo.init(e, n), Z.init(e, n));
});
function na(e) {
  return vi(Sn, e);
}
var In = c("ZodISODate", (e, n) => {
  ($o.init(e, n), Z.init(e, n));
});
function ra(e) {
  return yi(In, e);
}
var An = c("ZodISOTime", (e, n) => {
  (zo.init(e, n), Z.init(e, n));
});
function oa(e) {
  return bi(An, e);
}
var Pn = c("ZodISODuration", (e, n) => {
  (So.init(e, n), Z.init(e, n));
});
function ia(e) {
  return wi(Pn, e);
}
var _l = (e, n) => {
    (nt.init(e, n),
      (e.name = "ZodError"),
      Object.defineProperties(e, {
        format: { value: (r) => ot(e, r) },
        flatten: { value: (r) => rt(e, r) },
        addIssue: { value: (r) => e.issues.push(r) },
        addIssues: { value: (r) => e.issues.push(...r) },
        isEmpty: {
          get() {
            return e.issues.length === 0;
          },
        },
      }));
  },
  md = c("ZodError", _l),
  Le = c("ZodError", _l, { Parent: Error });
var aa = Lt(Le),
  sa = Ft(Le),
  la = Wt(Le),
  ua = Ht(Le);
var I = c(
    "ZodType",
    (e, n) => (
      $.init(e, n),
      (e.def = n),
      Object.defineProperty(e, "_def", { value: n }),
      (e.check = (...r) =>
        e.clone({
          ...n,
          checks: [
            ...(n.checks ?? []),
            ...r.map((i) =>
              typeof i == "function"
                ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } }
                : i,
            ),
          ],
        })),
      (e.clone = (r, i) => B(e, r, i)),
      (e.brand = () => e),
      (e.register = (r, i) => (r.add(e, i), e)),
      (e.parse = (r, i) => aa(e, r, i, { callee: e.parse })),
      (e.safeParse = (r, i) => la(e, r, i)),
      (e.parseAsync = async (r, i) => sa(e, r, i, { callee: e.parseAsync })),
      (e.safeParseAsync = async (r, i) => ua(e, r, i)),
      (e.spa = e.safeParseAsync),
      (e.refine = (r, i) => e.check(Xl(r, i))),
      (e.superRefine = (r) => e.check(Ql(r))),
      (e.overwrite = (r) => e.check(de(r))),
      (e.optional = () => Tn(e)),
      (e.nullable = () => Nn(e)),
      (e.nullish = () => Tn(Nn(e))),
      (e.nonoptional = (r) => Ml(e, r)),
      (e.array = () => Oa(e)),
      (e.or = (r) => Mn([e, r])),
      (e.and = (r) => zl(e, r)),
      (e.transform = (r) => En(e, Ea(r))),
      (e.default = (r) => Zl(e, r)),
      (e.prefault = (r) => Cl(e, r)),
      (e.catch = (r) => Fl(e, r)),
      (e.pipe = (r) => En(e, r)),
      (e.readonly = () => Hl(e)),
      (e.describe = (r) => {
        let i = e.clone();
        return (ae.add(i, { description: r }), i);
      }),
      Object.defineProperty(e, "description", {
        get() {
          return ae.get(e)?.description;
        },
        configurable: !0,
      }),
      (e.meta = (...r) => {
        if (r.length === 0) return ae.get(e);
        let i = e.clone();
        return (ae.add(i, r[0]), i);
      }),
      (e.isOptional = () => e.safeParse(void 0).success),
      (e.isNullable = () => e.safeParse(null).success),
      e
    ),
  ),
  _a = c("_ZodString", (e, n) => {
    (at.init(e, n), I.init(e, n));
    let r = e._zod.bag;
    ((e.format = r.format ?? null),
      (e.minLength = r.minimum ?? null),
      (e.maxLength = r.maximum ?? null),
      (e.regex = (...i) => e.check(mt(...i))),
      (e.includes = (...i) => e.check(gt(...i))),
      (e.startsWith = (...i) => e.check(ht(...i))),
      (e.endsWith = (...i) => e.check(vt(...i))),
      (e.min = (...i) => e.check(ve(...i))),
      (e.max = (...i) => e.check(Ce(...i))),
      (e.length = (...i) => e.check(Me(...i))),
      (e.nonempty = (...i) => e.check(ve(1, ...i))),
      (e.lowercase = (i) => e.check(pt(i))),
      (e.uppercase = (i) => e.check(ft(i))),
      (e.trim = () => e.check(wt())),
      (e.normalize = (...i) => e.check(bt(...i))),
      (e.toLowerCase = () => e.check(kt())),
      (e.toUpperCase = () => e.check(xt())));
  }),
  Un = c("ZodString", (e, n) => {
    (at.init(e, n),
      _a.init(e, n),
      (e.email = (r) => e.check(rn(ma, r))),
      (e.url = (r) => e.check(un(pa, r))),
      (e.jwt = (r) => e.check($n(Pa, r))),
      (e.emoji = (r) => e.check(cn(fa, r))),
      (e.guid = (r) => e.check(dt(jn, r))),
      (e.uuid = (r) => e.check(on(me, r))),
      (e.uuidv4 = (r) => e.check(an(me, r))),
      (e.uuidv6 = (r) => e.check(sn(me, r))),
      (e.uuidv7 = (r) => e.check(ln(me, r))),
      (e.nanoid = (r) => e.check(dn(ga, r))),
      (e.guid = (r) => e.check(dt(jn, r))),
      (e.cuid = (r) => e.check(_n(ha, r))),
      (e.cuid2 = (r) => e.check(mn(va, r))),
      (e.ulid = (r) => e.check(pn(ya, r))),
      (e.base64 = (r) => e.check(wn(Sa, r))),
      (e.base64url = (r) => e.check(kn(Ia, r))),
      (e.xid = (r) => e.check(fn(ba, r))),
      (e.ksuid = (r) => e.check(gn(wa, r))),
      (e.ipv4 = (r) => e.check(hn(ka, r))),
      (e.ipv6 = (r) => e.check(vn(xa, r))),
      (e.cidrv4 = (r) => e.check(yn($a, r))),
      (e.cidrv6 = (r) => e.check(bn(za, r))),
      (e.e164 = (r) => e.check(xn(Aa, r))),
      (e.datetime = (r) => e.check(na(r))),
      (e.date = (r) => e.check(ra(r))),
      (e.time = (r) => e.check(oa(r))),
      (e.duration = (r) => e.check(ia(r))));
  });
function ca(e) {
  return gi(Un, e);
}
var Z = c("ZodStringFormat", (e, n) => {
    (U.init(e, n), _a.init(e, n));
  }),
  ma = c("ZodEmail", (e, n) => {
    (po.init(e, n), Z.init(e, n));
  });
function fd(e) {
  return rn(ma, e);
}
var jn = c("ZodGUID", (e, n) => {
  (_o.init(e, n), Z.init(e, n));
});
function gd(e) {
  return dt(jn, e);
}
var me = c("ZodUUID", (e, n) => {
  (mo.init(e, n), Z.init(e, n));
});
function hd(e) {
  return on(me, e);
}
function vd(e) {
  return an(me, e);
}
function yd(e) {
  return sn(me, e);
}
function bd(e) {
  return ln(me, e);
}
var pa = c("ZodURL", (e, n) => {
  (fo.init(e, n), Z.init(e, n));
});
function wd(e) {
  return un(pa, e);
}
var fa = c("ZodEmoji", (e, n) => {
  (go.init(e, n), Z.init(e, n));
});
function kd(e) {
  return cn(fa, e);
}
var ga = c("ZodNanoID", (e, n) => {
  (ho.init(e, n), Z.init(e, n));
});
function xd(e) {
  return dn(ga, e);
}
var ha = c("ZodCUID", (e, n) => {
  (vo.init(e, n), Z.init(e, n));
});
function $d(e) {
  return _n(ha, e);
}
var va = c("ZodCUID2", (e, n) => {
  (yo.init(e, n), Z.init(e, n));
});
function zd(e) {
  return mn(va, e);
}
var ya = c("ZodULID", (e, n) => {
  (bo.init(e, n), Z.init(e, n));
});
function Sd(e) {
  return pn(ya, e);
}
var ba = c("ZodXID", (e, n) => {
  (wo.init(e, n), Z.init(e, n));
});
function Id(e) {
  return fn(ba, e);
}
var wa = c("ZodKSUID", (e, n) => {
  (ko.init(e, n), Z.init(e, n));
});
function Ad(e) {
  return gn(wa, e);
}
var ka = c("ZodIPv4", (e, n) => {
  (Io.init(e, n), Z.init(e, n));
});
function Pd(e) {
  return hn(ka, e);
}
var xa = c("ZodIPv6", (e, n) => {
  (Ao.init(e, n), Z.init(e, n));
});
function Dd(e) {
  return vn(xa, e);
}
var $a = c("ZodCIDRv4", (e, n) => {
  (Po.init(e, n), Z.init(e, n));
});
function jd(e) {
  return yn($a, e);
}
var za = c("ZodCIDRv6", (e, n) => {
  (Do.init(e, n), Z.init(e, n));
});
function Od(e) {
  return bn(za, e);
}
var Sa = c("ZodBase64", (e, n) => {
  (Oo.init(e, n), Z.init(e, n));
});
function Td(e) {
  return wn(Sa, e);
}
var Ia = c("ZodBase64URL", (e, n) => {
  (To.init(e, n), Z.init(e, n));
});
function Nd(e) {
  return kn(Ia, e);
}
var Aa = c("ZodE164", (e, n) => {
  (No.init(e, n), Z.init(e, n));
});
function Ed(e) {
  return xn(Aa, e);
}
var Pa = c("ZodJWT", (e, n) => {
  (Eo.init(e, n), Z.init(e, n));
});
function Ud(e) {
  return $n(Pa, e);
}
var It = c("ZodNumber", (e, n) => {
  (Xt.init(e, n),
    I.init(e, n),
    (e.gt = (i, t) => e.check(ce(i, t))),
    (e.gte = (i, t) => e.check(W(i, t))),
    (e.min = (i, t) => e.check(W(i, t))),
    (e.lt = (i, t) => e.check(ue(i, t))),
    (e.lte = (i, t) => e.check(Q(i, t))),
    (e.max = (i, t) => e.check(Q(i, t))),
    (e.int = (i) => e.check(da(i))),
    (e.safe = (i) => e.check(da(i))),
    (e.positive = (i) => e.check(ce(0, i))),
    (e.nonnegative = (i) => e.check(W(0, i))),
    (e.negative = (i) => e.check(ue(0, i))),
    (e.nonpositive = (i) => e.check(Q(0, i))),
    (e.multipleOf = (i, t) => e.check(Ie(i, t))),
    (e.step = (i, t) => e.check(Ie(i, t))),
    (e.finite = () => e));
  let r = e._zod.bag;
  ((e.minValue =
    Math.max(
      r.minimum ?? Number.NEGATIVE_INFINITY,
      r.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
    ) ?? null),
    (e.maxValue =
      Math.min(
        r.maximum ?? Number.POSITIVE_INFINITY,
        r.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
      ) ?? null),
    (e.isInt =
      (r.format ?? "").includes("int") ||
      Number.isSafeInteger(r.multipleOf ?? 0.5)),
    (e.isFinite = !0),
    (e.format = r.format ?? null));
});
function ml(e) {
  return ki(It, e);
}
var Ve = c("ZodNumberFormat", (e, n) => {
  (Uo.init(e, n), It.init(e, n));
});
function da(e) {
  return $i(Ve, e);
}
function Zd(e) {
  return zi(Ve, e);
}
function Rd(e) {
  return Si(Ve, e);
}
function Cd(e) {
  return Ii(Ve, e);
}
function Md(e) {
  return Ai(Ve, e);
}
var At = c("ZodBoolean", (e, n) => {
  (st.init(e, n), I.init(e, n));
});
function pl(e) {
  return Pi(At, e);
}
var Pt = c("ZodBigInt", (e, n) => {
  (Qt.init(e, n),
    I.init(e, n),
    (e.gte = (i, t) => e.check(W(i, t))),
    (e.min = (i, t) => e.check(W(i, t))),
    (e.gt = (i, t) => e.check(ce(i, t))),
    (e.gte = (i, t) => e.check(W(i, t))),
    (e.min = (i, t) => e.check(W(i, t))),
    (e.lt = (i, t) => e.check(ue(i, t))),
    (e.lte = (i, t) => e.check(Q(i, t))),
    (e.max = (i, t) => e.check(Q(i, t))),
    (e.positive = (i) => e.check(ce(BigInt(0), i))),
    (e.negative = (i) => e.check(ue(BigInt(0), i))),
    (e.nonpositive = (i) => e.check(Q(BigInt(0), i))),
    (e.nonnegative = (i) => e.check(W(BigInt(0), i))),
    (e.multipleOf = (i, t) => e.check(Ie(i, t))));
  let r = e._zod.bag;
  ((e.minValue = r.minimum ?? null),
    (e.maxValue = r.maximum ?? null),
    (e.format = r.format ?? null));
});
function Ld(e) {
  return ji(Pt, e);
}
var Da = c("ZodBigIntFormat", (e, n) => {
  (Zo.init(e, n), Pt.init(e, n));
});
function Vd(e) {
  return Ti(Da, e);
}
function Fd(e) {
  return Ni(Da, e);
}
var fl = c("ZodSymbol", (e, n) => {
  (Ro.init(e, n), I.init(e, n));
});
function qd(e) {
  return Ei(fl, e);
}
var gl = c("ZodUndefined", (e, n) => {
  (Co.init(e, n), I.init(e, n));
});
function Wd(e) {
  return Ui(gl, e);
}
var hl = c("ZodNull", (e, n) => {
  (Mo.init(e, n), I.init(e, n));
});
function vl(e) {
  return Zi(hl, e);
}
var yl = c("ZodAny", (e, n) => {
  (Lo.init(e, n), I.init(e, n));
});
function Hd() {
  return Ri(yl);
}
var ja = c("ZodUnknown", (e, n) => {
  (he.init(e, n), I.init(e, n));
});
function On() {
  return Ze(ja);
}
var bl = c("ZodNever", (e, n) => {
  (Vo.init(e, n), I.init(e, n));
});
function Zn(e) {
  return Ci(bl, e);
}
var wl = c("ZodVoid", (e, n) => {
  (Fo.init(e, n), I.init(e, n));
});
function Bd(e) {
  return Mi(wl, e);
}
var Rn = c("ZodDate", (e, n) => {
  (qo.init(e, n),
    I.init(e, n),
    (e.min = (i, t) => e.check(W(i, t))),
    (e.max = (i, t) => e.check(Q(i, t))));
  let r = e._zod.bag;
  ((e.minDate = r.minimum ? new Date(r.minimum) : null),
    (e.maxDate = r.maximum ? new Date(r.maximum) : null));
});
function Kd(e) {
  return Li(Rn, e);
}
var kl = c("ZodArray", (e, n) => {
  (lt.init(e, n),
    I.init(e, n),
    (e.element = n.element),
    (e.min = (r, i) => e.check(ve(r, i))),
    (e.nonempty = (r) => e.check(ve(1, r))),
    (e.max = (r, i) => e.check(Ce(r, i))),
    (e.length = (r, i) => e.check(Me(r, i))),
    (e.unwrap = () => e.element));
});
function Oa(e, n) {
  return $t(kl, e, n);
}
function Jd(e) {
  let n = e._zod.def.shape;
  return Ol(Object.keys(n));
}
var Cn = c("ZodObject", (e, n) => {
  (Wo.init(e, n),
    I.init(e, n),
    y.defineLazy(e, "shape", () =>
      Object.fromEntries(Object.entries(e._zod.def.shape)),
    ),
    (e.keyof = () => Dl(Object.keys(e._zod.def.shape))),
    (e.catchall = (r) => e.clone({ ...e._zod.def, catchall: r })),
    (e.passthrough = () => e.clone({ ...e._zod.def, catchall: On() })),
    (e.loose = () => e.clone({ ...e._zod.def, catchall: On() })),
    (e.strict = () => e.clone({ ...e._zod.def, catchall: Zn() })),
    (e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 })),
    (e.extend = (r) => y.extend(e, r)),
    (e.merge = (r) => y.merge(e, r)),
    (e.pick = (r) => y.pick(e, r)),
    (e.omit = (r) => y.omit(e, r)),
    (e.partial = (...r) => y.partial(Ua, e, r[0])),
    (e.required = (...r) => y.required(Za, e, r[0])));
});
function Yd(e, n) {
  let r = {
    type: "object",
    get shape() {
      return (y.assignProp(this, "shape", { ...e }), this.shape);
    },
    ...y.normalizeParams(n),
  };
  return new Cn(r);
}
function Gd(e, n) {
  return new Cn({
    type: "object",
    get shape() {
      return (y.assignProp(this, "shape", { ...e }), this.shape);
    },
    catchall: Zn(),
    ...y.normalizeParams(n),
  });
}
function Xd(e, n) {
  return new Cn({
    type: "object",
    get shape() {
      return (y.assignProp(this, "shape", { ...e }), this.shape);
    },
    catchall: On(),
    ...y.normalizeParams(n),
  });
}
var Ta = c("ZodUnion", (e, n) => {
  (en.init(e, n), I.init(e, n), (e.options = n.options));
});
function Mn(e, n) {
  return new Ta({ type: "union", options: e, ...y.normalizeParams(n) });
}
var xl = c("ZodDiscriminatedUnion", (e, n) => {
  (Ta.init(e, n), Ho.init(e, n));
});
function Qd(e, n, r) {
  return new xl({
    type: "union",
    options: n,
    discriminator: e,
    ...y.normalizeParams(r),
  });
}
var $l = c("ZodIntersection", (e, n) => {
  (Bo.init(e, n), I.init(e, n));
});
function zl(e, n) {
  return new $l({ type: "intersection", left: e, right: n });
}
var Sl = c("ZodTuple", (e, n) => {
  (Se.init(e, n),
    I.init(e, n),
    (e.rest = (r) => e.clone({ ...e._zod.def, rest: r })));
});
function e_(e, n, r) {
  let i = n instanceof $,
    t = i ? r : n,
    o = i ? n : null;
  return new Sl({ type: "tuple", items: e, rest: o, ...y.normalizeParams(t) });
}
var Na = c("ZodRecord", (e, n) => {
  (Ko.init(e, n),
    I.init(e, n),
    (e.keyType = n.keyType),
    (e.valueType = n.valueType));
});
function Il(e, n, r) {
  return new Na({
    type: "record",
    keyType: e,
    valueType: n,
    ...y.normalizeParams(r),
  });
}
function t_(e, n, r) {
  return new Na({
    type: "record",
    keyType: Mn([e, Zn()]),
    valueType: n,
    ...y.normalizeParams(r),
  });
}
var Al = c("ZodMap", (e, n) => {
  (Jo.init(e, n),
    I.init(e, n),
    (e.keyType = n.keyType),
    (e.valueType = n.valueType));
});
function n_(e, n, r) {
  return new Al({
    type: "map",
    keyType: e,
    valueType: n,
    ...y.normalizeParams(r),
  });
}
var Pl = c("ZodSet", (e, n) => {
  (Yo.init(e, n),
    I.init(e, n),
    (e.min = (...r) => e.check(Ae(...r))),
    (e.nonempty = (r) => e.check(Ae(1, r))),
    (e.max = (...r) => e.check(Re(...r))),
    (e.size = (...r) => e.check(_t(...r))));
});
function r_(e, n) {
  return new Pl({ type: "set", valueType: e, ...y.normalizeParams(n) });
}
var St = c("ZodEnum", (e, n) => {
  (Go.init(e, n),
    I.init(e, n),
    (e.enum = n.entries),
    (e.options = Object.values(n.entries)));
  let r = new Set(Object.keys(n.entries));
  ((e.extract = (i, t) => {
    let o = {};
    for (let a of i)
      if (r.has(a)) o[a] = n.entries[a];
      else throw new Error(`Key ${a} not found in enum`);
    return new St({ ...n, checks: [], ...y.normalizeParams(t), entries: o });
  }),
    (e.exclude = (i, t) => {
      let o = { ...n.entries };
      for (let a of i)
        if (r.has(a)) delete o[a];
        else throw new Error(`Key ${a} not found in enum`);
      return new St({ ...n, checks: [], ...y.normalizeParams(t), entries: o });
    }));
});
function Dl(e, n) {
  let r = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new St({ type: "enum", entries: r, ...y.normalizeParams(n) });
}
function o_(e, n) {
  return new St({ type: "enum", entries: e, ...y.normalizeParams(n) });
}
var jl = c("ZodLiteral", (e, n) => {
  (Xo.init(e, n),
    I.init(e, n),
    (e.values = new Set(n.values)),
    Object.defineProperty(e, "value", {
      get() {
        if (n.values.length > 1)
          throw new Error(
            "This schema contains multiple valid literal values. Use `.values` instead.",
          );
        return n.values[0];
      },
    }));
});
function Ol(e, n) {
  return new jl({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...y.normalizeParams(n),
  });
}
var Tl = c("ZodFile", (e, n) => {
  (Qo.init(e, n),
    I.init(e, n),
    (e.min = (r, i) => e.check(Ae(r, i))),
    (e.max = (r, i) => e.check(Re(r, i))),
    (e.mime = (r, i) => e.check(yt(Array.isArray(r) ? r : [r], i))));
});
function i_(e) {
  return Yi(Tl, e);
}
var Nl = c("ZodTransform", (e, n) => {
  (ei.init(e, n),
    I.init(e, n),
    (e._zod.parse = (r, i) => {
      r.addIssue = (o) => {
        if (typeof o == "string") r.issues.push(y.issue(o, r.value, n));
        else {
          let a = o;
          (a.fatal && (a.continue = !1),
            a.code ?? (a.code = "custom"),
            a.input ?? (a.input = r.value),
            a.inst ?? (a.inst = e),
            a.continue ?? (a.continue = !0),
            r.issues.push(y.issue(a)));
        }
      };
      let t = n.transform(r.value, r);
      return t instanceof Promise
        ? t.then((o) => ((r.value = o), r))
        : ((r.value = t), r);
    }));
});
function Ea(e) {
  return new Nl({ type: "transform", transform: e });
}
var Ua = c("ZodOptional", (e, n) => {
  (ti.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function Tn(e) {
  return new Ua({ type: "optional", innerType: e });
}
var El = c("ZodNullable", (e, n) => {
  (ni.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function Nn(e) {
  return new El({ type: "nullable", innerType: e });
}
function a_(e) {
  return Tn(Nn(e));
}
var Ul = c("ZodDefault", (e, n) => {
  (ri.init(e, n),
    I.init(e, n),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeDefault = e.unwrap));
});
function Zl(e, n) {
  return new Ul({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof n == "function" ? n() : n;
    },
  });
}
var Rl = c("ZodPrefault", (e, n) => {
  (oi.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function Cl(e, n) {
  return new Rl({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof n == "function" ? n() : n;
    },
  });
}
var Za = c("ZodNonOptional", (e, n) => {
  (ii.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function Ml(e, n) {
  return new Za({ type: "nonoptional", innerType: e, ...y.normalizeParams(n) });
}
var Ll = c("ZodSuccess", (e, n) => {
  (ai.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function s_(e) {
  return new Ll({ type: "success", innerType: e });
}
var Vl = c("ZodCatch", (e, n) => {
  (si.init(e, n),
    I.init(e, n),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeCatch = e.unwrap));
});
function Fl(e, n) {
  return new Vl({
    type: "catch",
    innerType: e,
    catchValue: typeof n == "function" ? n : () => n,
  });
}
var ql = c("ZodNaN", (e, n) => {
  (li.init(e, n), I.init(e, n));
});
function l_(e) {
  return Fi(ql, e);
}
var Ra = c("ZodPipe", (e, n) => {
  (ut.init(e, n), I.init(e, n), (e.in = n.in), (e.out = n.out));
});
function En(e, n) {
  return new Ra({ type: "pipe", in: e, out: n });
}
var Wl = c("ZodReadonly", (e, n) => {
  (ui.init(e, n), I.init(e, n));
});
function Hl(e) {
  return new Wl({ type: "readonly", innerType: e });
}
var Bl = c("ZodTemplateLiteral", (e, n) => {
  (ci.init(e, n), I.init(e, n));
});
function u_(e, n) {
  return new Bl({
    type: "template_literal",
    parts: e,
    ...y.normalizeParams(n),
  });
}
var Kl = c("ZodLazy", (e, n) => {
  (_i.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.getter()));
});
function Jl(e) {
  return new Kl({ type: "lazy", getter: e });
}
var Yl = c("ZodPromise", (e, n) => {
  (di.init(e, n), I.init(e, n), (e.unwrap = () => e._zod.def.innerType));
});
function c_(e) {
  return new Yl({ type: "promise", innerType: e });
}
var Ln = c("ZodCustom", (e, n) => {
  (mi.init(e, n), I.init(e, n));
});
function Gl(e, n) {
  let r = new R({ check: "custom", ...y.normalizeParams(n) });
  return ((r._zod.check = e), r);
}
function d_(e, n) {
  return Gi(Ln, e ?? (() => !0), n);
}
function Xl(e, n = {}) {
  return Xi(Ln, e, n);
}
function Ql(e, n) {
  let r = Gl(
    (i) => (
      (i.addIssue = (t) => {
        if (typeof t == "string")
          i.issues.push(y.issue(t, i.value, r._zod.def));
        else {
          let o = t;
          (o.fatal && (o.continue = !1),
            o.code ?? (o.code = "custom"),
            o.input ?? (o.input = i.value),
            o.inst ?? (o.inst = r),
            o.continue ?? (o.continue = !r._zod.def.abort),
            i.issues.push(y.issue(o)));
        }
      }),
      e(i.value, i)
    ),
    n,
  );
  return r;
}
function __(e, n = { error: `Input not instance of ${e.name}` }) {
  let r = new Ln({
    type: "custom",
    check: "custom",
    fn: (i) => i instanceof e,
    abort: !0,
    ...y.normalizeParams(n),
  });
  return ((r._zod.bag.Class = e), r);
}
var m_ = (...e) => Qi({ Pipe: Ra, Boolean: At, Unknown: ja }, ...e);
function p_(e) {
  let n = Jl(() => Mn([ca(e), ml(), pl(), vl(), Oa(n), Il(ca(), n)]));
  return n;
}
function f_(e, n) {
  return En(Ea(e), n);
}
var g_ = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom",
  },
  h_ = Object.freeze({ status: "aborted" }),
  v_ = h_;
function y_(e) {
  C({ customError: e });
}
function b_() {
  return C().customError;
}
var Ca = {};
ye(Ca, {
  bigint: () => $_,
  boolean: () => x_,
  date: () => z_,
  number: () => k_,
  string: () => w_,
});
function w_(e) {
  return hi(Un, e);
}
function k_(e) {
  return xi(It, e);
}
function x_(e) {
  return Di(At, e);
}
function $_(e) {
  return Oi(Pt, e);
}
function z_(e) {
  return Vi(Rn, e);
}
C(tn());
je && g.config({ jitless: !0 });
var eu = [
    "ar",
    "bg",
    "ca",
    "co",
    "cs",
    "da",
    "de",
    "dsb",
    "el",
    "en",
    "es",
    "fr",
    "hsb",
    "hu",
    "id",
    "is",
    "it",
    "ja",
    "ko",
    "nb",
    "nl",
    "pl",
    "pt-BR",
    "ro",
    "ru",
    "sk",
    "sl",
    "sv",
    "tr",
    "uk",
    "zh-CN",
    "zh-TW",
  ],
  Vn = [
    "appDesc",
    "restore_purchase_button",
    "get_premium_button",
    "back",
    "rm_notifications_all",
    "waiting_for_media",
    "nomedia_title",
    "nomedia_description",
    "nomedia_reload_button",
    "nomedia_reload_button_tooltip",
    "show_nomedia_button",
    "show_nomedia_button_tooltip",
    "setting_button_tooltip",
    "history_button_tooltip",
    "show_all_history_button",
    "complete_title",
    "hide_complete_button",
    "translate_button_tooltip",
    "help_button_tooltip",
    "open_source_tab_button_tooltip",
    "retry_download_button_tooltip",
    "delete_file_button_tooltip",
    "download_directory_button_tooltip",
    "clear_downloaded_tooltip",
    "show_in_popup_button_tooltip",
    "show_in_sidebar_button_tooltip",
    "video_not_playing_button_tooltip",
    "play",
    "warn_drm_tooltip",
    "version_title",
    "account_title",
    "one_hundred_downloads_title",
    "leave_review_description",
    "leave_review_button",
    "account_status",
    "account_status_premium",
    "free_account",
    "copy_to_clipboard",
    "my_account_button",
    "download_title",
    "show_notification",
    "max_parallel_downloads",
    "saveas_detected_warning",
    "change_saveas_setting",
    "download_directory_title",
    "download_directory_description",
    "change_browser_download_directory",
    "bad_download_subdirectory_warning",
    "download_subdirectory",
    "private_browsing_title",
    "private_browsing_warning",
    "private_browsing_notifications",
    "private_browsing_button",
    "throttle_youtube",
    "prefer_original_audio",
    "prefer_hls",
    "settings_history_title",
    "transient_history_description",
    "history_limit",
    "appearance_title",
    "theme_title",
    "theme_light",
    "theme_dark",
    "theme_system",
    "popup_size_title",
    "popup_size_small",
    "popup_size_medium",
    "popup_size_big",
    "panel_position_title",
    "use_popup",
    "use_sidebar",
    "behavior_title",
    "controls_title",
    "show_in_context_menu",
    "restart_addon",
    "reset_settings",
    "prefered_quality",
    "prefered_quality_highest",
    "prefered_quality_1080p",
    "prefered_quality_720p",
    "prefer_mkv",
    "preview_mode_title",
    "preview_mode_none",
    "preview_mode_video",
    "preview_mode_image",
    "history_title",
    "history_warning",
    "history_warning_2",
    "enable_history",
    "clear_history",
    "disable_history",
    "no_downloads_yet",
    "download_failed",
    "download_failed_description",
    "download_interrupted",
    "download_interrupted_description",
    "download_with_drm_failed_description",
    "no_youtube",
    "no_youtube_description",
    "no_youtube_description_2",
    "premium_required",
    "premium_yt_required_description",
    "premium_hls_required_description",
    "premium_all_required_description",
    "youtube_too_many_downloads",
    "youtube_too_many_downloads_description",
    "stop",
    "cancel",
    "copy_url",
    "always_copy_url",
    "download_button",
    "download_as_button_and_menu",
    "rename_short",
    "always_download_as_menu",
    "download_audio_button",
    "download_audio_and_video_menu",
    "download_audio_only_menu",
    "audio_only_for_this_website",
    "details",
    "report",
    "reporting",
    "reported_thankyou",
    "not_playing_title",
    "not_playing_broken_title",
    "not_playing_broken_description",
    "not_playing_broken_solution_title",
    "not_playing_broken_solution_windows_1",
    "not_playing_broken_solution_mac_1",
    "not_playing_broken_solution_2",
    "not_playing_default_player",
    "not_playing_default_player_solution_windows",
    "not_playing_default_player_solution_mac",
  ],
  Ma = [
    "back",
    "header_help",
    "header_ask_question",
    "activate_title",
    "activate_pending",
    "activate_success",
    "activate_error",
    "activate_no_addon_found",
    "activate_no_method_found",
    "activate_help_me",
    "issue_title",
    "issue_submit",
    "issue_thank_you",
    "issue_enter_email",
    "issue_email_sent",
    "issue_or_digit",
    "issue_just_digit",
    "issue_i_have_a_code",
    "issue_i_have_a_key",
    "issue_key",
    "landing_text1",
    "landing_text2",
    "landing_text3",
    "landing_text4",
    "landing_install_for_google",
    "landing_install_for_mozilla",
    "landing_install_for_microsoft",
    "landing_feature1_title",
    "landing_feature1_description",
    "landing_feature2_title",
    "landing_feature2_description",
    "landing_feature3_title",
    "landing_feature3_description",
    "landing_feature4_title",
    "landing_feature4_description",
    "premium_hero1",
    "premium_hero2",
    "premium_hero3",
    "welcome_text",
    "welcome_pin_message",
  ];
var nh = new Set(eu),
  S_ = g.enum(Vn),
  I_ = g.enum(Ma),
  tu = g.map(S_, g.string()),
  nu = g.map(I_, g.string()),
  rh = new Set(Vn);
var ou = g.templateLiteral(["ded_", g.string()]),
  P_ = g.templateLiteral(["media_hash_", g.number()]),
  ru = g.enum(["download", "download_as", "download_audio", "copy"]),
  D_ = g.enum(["popup", "sidebar"]),
  Va = g.string().brand("directorypath"),
  j_ = g.strictObject({
    downloaded_id: ou,
    media_hash: P_,
    path: g.string(),
    browser_download_id: g.number(),
    download_timestamp: g.number(),
    origin_url: g.nullable(g.url()),
    origin_favicon_url: g.nullable(g.url()),
    has_drm: g.boolean(),
    subdir: g.optional(Va),
  }),
  O_ = g.enum(["SUBSCRIPTION", "LIFETIME", "GOLDEN"]),
  T_ = g.object({
    iat: g.optional(g.number()),
    user_id: g.number(),
    store: g.string().max(256),
    jti: g.string().max(512),
    valid_until: g.number(),
    exp: g.number(),
    developer: g.boolean().optional(),
    entitlement_type: O_.optional(),
  }),
  N_ = T_.extend({ raw: g.string() }),
  E_ = g.enum(["original", "user_language"]),
  U_ = g.enum(["none", "video", "image"]),
  Z_ = g.enum(["system", "light", "dark"]),
  R_ = g.enum(["big", "medium", "small"]),
  C_ = g.strictObject({
    max_length: g.number(),
    template: g.string(),
    force_doc_title: g.optional(g.boolean()),
  }),
  M_ = g.strictObject({
    template: g.string(),
    url: g.string(),
    max_length: g.nullable(g.number()),
    selector: g.nullable(g.string()),
    subdir: g.optional(Va),
    force_doc_title: g.optional(g.boolean()),
    replace: g.optional(
      g.array(g.strictObject({ from: g.string(), to: g.string() })),
    ),
  }),
  La = g.strictObject({
    version: g.number(),
    default_action: ru,
    default_action_per_hostname: g.map(g.string(), ru),
    downloaded: g.map(ou, j_),
    jwt: g.nullable(N_),
    lsd: g.number(),
    dockmode: D_,
    download_directory: Va,
    youtube_throttle: g.boolean(),
    youtube_audio_strategy: E_,
    youtube_prefer_hls: g.boolean(),
    max_concurrent_downloads: g.number(),
    show_desktop_notifications: g.boolean(),
    show_desktop_notifications_private: g.boolean(),
    history_days: g.number(),
    show_transient_history: g.boolean(),
    ui_theme: Z_,
    use_context_menu: g.boolean(),
    dont_ask_for_user_review: g.boolean(),
    successful_downloads_count: g.number(),
    prefered_quality: g.nullable(g.number()),
    prefered_av_muxer: g.enum(["mp4", "mkv"]),
    hide_nomedia_box: g.boolean(),
    popup_size: R_,
    smartnaming: g.strictObject({
      source: g.nullable(g.string()),
      compiled: g.strictObject({ default_: C_, rules: g.array(M_) }),
    }),
    preview_mode: U_,
    last_migration_request: g.number(),
    custom_strings: g.strictObject({ web: nu, addon: tu }),
  }),
  sh = La.readonly();
function iu(e) {
  let n = Fn();
  if (e && typeof e == "object")
    for (let r of Object.keys(La.shape)) {
      let i = La.shape[r];
      if (r in e) {
        let t = e[r],
          o = i.safeParse(t);
        if (o.success) n[r] = o.data;
        else {
          for (let a of o.error.issues)
            (console.warn("Zod issue"),
              console.warn(a.path.join(".")),
              console.warn(a.message));
          (console.warn(o.error.issues),
            console.warn(o.error.type),
            console.warn(o.error.message),
            console.warn(
              `Failed to import past persitent state field: ${r}. Fallback to default. Value was:`,
              t,
            ));
        }
      }
    }
  return n;
}
var L_ = 1710169438e3;
function Fn() {
  return {
    version: 1,
    default_action_per_hostname: new Map(),
    downloaded: new Map(),
    jwt: null,
    lsd: L_,
    default_action: "download",
    hide_nomedia_box: !0,
    dont_ask_for_user_review: !1,
    dockmode: "popup",
    download_directory: Rt,
    youtube_throttle: !0,
    youtube_audio_strategy: "original",
    youtube_prefer_hls: !0,
    max_concurrent_downloads: 6,
    show_desktop_notifications: !0,
    show_desktop_notifications_private: !1,
    history_days: 0,
    show_transient_history: !0,
    ui_theme: "system",
    use_context_menu: !0,
    prefered_quality: 1080,
    prefered_av_muxer: "mp4",
    popup_size: "medium",
    successful_downloads_count: 0,
    smartnaming: { source: null, compiled: er() },
    preview_mode: "video",
    last_migration_request: 0,
    custom_strings: { addon: new Map(), web: new Map() },
  };
}
var qn = "global_persistent_state";
async function au() {
  let e = (await Fa()).lsd,
    n = Fn();
  return ((n.lsd = e), q_(n));
}
async function q_(e) {
  let n = oe(e);
  return Dt.storage.local.set({ [qn]: n });
}
async function Fa() {
  let e = await Dt.storage.local.get(qn);
  if (qn in e) {
    let r = e[qn];
    return iu(re(r));
  }
  let n = Fn();
  {
    let r = await Dt.storage.local.get();
    (typeof r.concurrent_downloads_max == "number" &&
      (n.max_concurrent_downloads = r.concurrent_downloads_max),
      typeof r.show_success_notification == "boolean" &&
        (n.show_desktop_notifications = r.show_success_notification),
      typeof r.show_success_notification_for_icognito == "boolean" &&
        (n.show_desktop_notifications =
          r.show_success_notification_for_icognito),
      typeof r.show_context_menu == "boolean" &&
        (n.use_context_menu = r.show_context_menu),
      typeof r.use_sidebar == "boolean" && (n.dockmode = "sidebar"),
      typeof r.theme == "string" &&
        (r.theme == "light" || r.theme == "dark" || r.theme == "system") &&
        (n.ui_theme = r.theme),
      typeof r.record_download_history == "boolean" &&
        r.record_download_history == !0 &&
        typeof r.history_limit_in_days == "number" &&
        (n.history_days = r.history_limit_in_days),
      typeof r.default_action == "string" &&
        (r.default_action == "copy" && (n.default_action = "copy"),
        r.default_action == "download_audio" &&
          (n.default_action = "download_audio")),
      typeof r.never_show_successfull_dl_message == "boolean" &&
        (n.dont_ask_for_user_review = r.never_show_successfull_dl_message),
      (n.smartnaming.compiled = await rs()),
      await Dt.storage.local.remove([
        "user_sidebar",
        "concurrent_downloads_max",
        "show_success_notification",
        "show_success_notification_for_icognito",
        "show_context_menu",
        "theme",
        "record_download_history",
        "history_limit_in_days",
        "default_action",
        "never_show_successfull_dl_message",
      ]));
  }
  return n;
}
function qa(e, n = 0) {
  return e < 1048576
    ? `${(e / 1024).toFixed(0)}KB`
    : `${(e / 1048576).toFixed(n)}MB`;
}
function Wn() {
  document.documentElement.getAttribute("dockmode") == "popup" &&
    window.close();
}
async function zh(e) {
  let n = await Qa();
  (Tt(e.s_box_account_not_linux, !n),
    Tt(e.s_p_leave_review, n),
    pe == "google" && !Ka && Ot(e.s_section_youtube),
    (e.s_checkbox_youtube_throttle.onchange = () => {
      let t = e.s_checkbox_youtube_throttle.checked;
      N({ name: "mut-settings", data: { youtube_throttle: t } });
    }),
    (e.s_checkbox_youtube_audio_original.onchange = () => {
      let t = e.s_checkbox_youtube_audio_original.checked;
      N({
        name: "mut-settings",
        data: { youtube_audio_strategy: t ? "original" : "user_language" },
      });
    }),
    (e.s_checkbox_youtube_prefer_hls.onchange = () => {
      let t = e.s_checkbox_youtube_prefer_hls.checked;
      N({ name: "mut-settings", data: { youtube_prefer_hls: t } });
    }));
  let r;
  ((e.s_input_subdirectory.oninput = () => {
    (clearTimeout(r),
      (r = setTimeout(() => {
        let t = e.s_input_subdirectory.value,
          o = ns(t);
        (Tt(e.s_span_bad_download_subdirectory, o.isErr()),
          o.isOk() &&
            N({ name: "mut-settings", data: { download_directory: o.value } }));
      }, 1e3)));
  }),
    (e.s_input_concurrent_downloads.onchange = () => {
      let t = parseInt(e.s_input_concurrent_downloads.value);
      N({ name: "mut-settings", data: { max_concurrent_downloads: t } });
    }),
    (e.s_checkbox_show_desktop_notifications.onchange = () => {
      let t = e.s_checkbox_show_desktop_notifications.checked;
      N({ name: "mut-settings", data: { show_desktop_notifications: t } });
    }),
    (e.s_checkbox_show_desktop_notifications_private.onchange = () => {
      let t = e.s_checkbox_show_desktop_notifications_private.checked;
      N({
        name: "mut-settings",
        data: { show_desktop_notifications_private: t },
      });
    }),
    (e.s_prefered_quality_highest.onchange = () => {
      e.s_prefered_quality_highest.checked &&
        N({ name: "mut-settings", data: { prefered_quality: null } });
    }),
    (e.s_prefered_quality_1080p.onchange = () => {
      e.s_prefered_quality_1080p.checked &&
        N({ name: "mut-settings", data: { prefered_quality: 1080 } });
    }),
    (e.s_prefered_quality_720p.onchange = () => {
      e.s_prefered_quality_720p.checked &&
        N({ name: "mut-settings", data: { prefered_quality: 720 } });
    }),
    (e.s_checkbox_always_download_as_mkv.onchange = () => {
      let t = e.s_checkbox_always_download_as_mkv.checked;
      N({ name: "mut-settings", data: { always_download_as_mkv: t } });
    }));
  let i = () => {
    let o = e.s_checkbox_history.checked
      ? parseInt(e.s_input_history.value)
      : 0;
    N({ name: "mut-settings", data: { history_days: o } });
  };
  ((e.s_input_history.onchange = i),
    (e.s_checkbox_history.onchange = i),
    (e.s_checkbox_transient_history.onchange = () => {
      let t = e.s_checkbox_transient_history.checked;
      N({ name: "mut-settings", data: { show_transient_history: t } });
    }),
    (e.s_theme_light.onchange = () => {
      e.s_theme_light.checked &&
        N({ name: "mut-settings", data: { ui_theme: "light" } });
    }),
    (e.s_theme_dark.onchange = () => {
      e.s_theme_dark.checked &&
        N({ name: "mut-settings", data: { ui_theme: "dark" } });
    }),
    (e.s_theme_system.onchange = () => {
      e.s_theme_system.checked &&
        N({ name: "mut-settings", data: { ui_theme: "system" } });
    }),
    (e.s_preview_mode_none.onchange = () => {
      e.s_preview_mode_none.checked &&
        N({ name: "mut-settings", data: { preview_mode: "none" } });
    }),
    (e.s_preview_mode_image.onchange = () => {
      e.s_preview_mode_image.checked &&
        N({ name: "mut-settings", data: { preview_mode: "image" } });
    }),
    (e.s_preview_mode_video.onchange = () => {
      e.s_preview_mode_video.checked &&
        N({ name: "mut-settings", data: { preview_mode: "video" } });
    }),
    (e.s_popup_size_small.onchange = () => {
      e.s_popup_size_small.checked &&
        N({ name: "mut-settings", data: { popup_size: "small" } });
    }),
    (e.s_popup_size_medium.onchange = () => {
      e.s_popup_size_medium.checked &&
        N({ name: "mut-settings", data: { popup_size: "medium" } });
    }),
    (e.s_popup_size_big.onchange = () => {
      e.s_popup_size_big.checked &&
        N({ name: "mut-settings", data: { popup_size: "big" } });
    }),
    (e.s_dock_popup.onchange = () => {
      e.s_dock_popup.checked &&
        (N({ name: "redock", data: { mode: "popup" } }), window.close());
    }),
    (e.s_dock_sidebar.onchange = () => {
      e.s_dock_sidebar.checked &&
        (N({ name: "redock", data: { mode: "sidebar" } }), window.close());
    }),
    (e.s_checkbox_context_menu.onchange = () => {
      let t = e.s_checkbox_context_menu.checked;
      N({ name: "mut-settings", data: { use_context_menu: t } });
    }),
    (e.s_button_restart.onclick = () => {
      ee.default.runtime.reload();
    }),
    (e.s_button_reset.onclick = async () => {
      (await au(), ee.default.runtime.reload());
    }),
    (e.s_button_copy.onclick = async () => {
      let o = ee.default.runtime.getManifest().version,
        a = await ee.default.runtime.getPlatformInfo(),
        s = ee.default.i18n.getUILanguage(),
        l = "";
      ((l += `version: ${o}
`),
        (l += `store: ${pe}
`),
        (l += `lang: ${s}
`),
        (l += `platform: ${a.arch} ${a.os}
`),
        (l += `UA: ${navigator.userAgent}
`));
      let u = await navigator.storage.estimate(),
        m = qa(u.usage || 0),
        p = qa(u.quota || 0),
        f = await navigator.storage.getDirectory(),
        d = 0;
      for await (let k of f.keys()) d++;
      l += `Internal storage: ${m} / ${p}. ${d} files
`;
      let v = await Fa();
      if (v.jwt) {
        let k = v.jwt,
          P = k.developer ? "true" : "false",
          {
            store: j,
            valid_until: S,
            exp: z,
            entitlement_type: w,
            user_id: x,
          } = k;
        ((l += `dev: ${P}
`),
          (l += `jwt_store: ${j}
`),
          (l += `valid_until: ${S}
`),
          (l += `exp: ${z}
`),
          (l += `entitlement_type: ${w}
`),
          (l += `user_id: ${x}
`));
      }
      navigator.clipboard.writeText(l);
    }),
    (e.s_button_browser_download_dir.onclick = () => {
      (Yn(), window.close());
    }),
    (e.s_button_smartnaming.onclick = () => {
      (ee.default.tabs.create({ url: "/content/smartnaming.html" }), Wn());
    }),
    (e.s_button_saveas.onclick = () => {
      (N({ name: "reset-suspicious-saveas", data: null }),
        Yn(),
        window.close());
    }),
    (e.s_button_set_incognito.onclick = () => {
      (Xa(), window.close());
    }),
    (e.s_button_my_account.onclick = () => {
      (ee.default.tabs.create({ url: Ga }), Wn());
    }),
    (e.s_button_restore_purchase.onclick = () => {
      (ee.default.tabs.create({ url: Ja }), Wn());
    }),
    (e.s_button_get_premium.onclick = () => {
      (ee.default.tabs.create({ url: Ya }), Wn());
    }),
    (e.s_span_version.textContent = `v${ee.default.runtime.getManifest().version}`),
    (e.s_button_leave_review.onclick = () => {
      N({ name: "show-review-page", data: null });
    }),
    (await ee.default.extension.isAllowedIncognitoAccess()) ||
      jt(e.s_section_no_private_browsing));
}
export { zh as InitSettings };
/*! Bundled license information:

smol-toml/dist/error.js:
smol-toml/dist/util.js:
smol-toml/dist/date.js:
smol-toml/dist/primitive.js:
smol-toml/dist/extract.js:
smol-toml/dist/struct.js:
smol-toml/dist/parse.js:
smol-toml/dist/stringify.js:
smol-toml/dist/index.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)
*/
