var mu = Object.create;
var qr = Object.defineProperty;
var pu = Object.getOwnPropertyDescriptor;
var fu = Object.getOwnPropertyNames;
var gu = Object.getPrototypeOf,
  hu = Object.prototype.hasOwnProperty;
var Ka = ((e) =>
  typeof require < "u"
    ? require
    : typeof Proxy < "u"
      ? new Proxy(e, { get: (r, n) => (typeof require < "u" ? require : r)[n] })
      : e)(function (e) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + e + '" is not supported');
});
var vu = (e, r) => () => (r || e((r = { exports: {} }).exports, r), r.exports),
  xe = (e, r) => {
    for (var n in r) qr(e, n, { get: r[n], enumerable: !0 });
  },
  yu = (e, r, n, i) => {
    if ((r && typeof r == "object") || typeof r == "function")
      for (let t of fu(r))
        !hu.call(e, t) &&
          t !== n &&
          qr(e, t, {
            get: () => r[t],
            enumerable: !(i = pu(r, t)) || i.enumerable,
          });
    return e;
  };
var Gr = (e, r, n) => (
  (n = e != null ? mu(gu(e)) : {}),
  yu(
    r || !e || !e.__esModule
      ? qr(n, "default", { value: e, enumerable: !0 })
      : n,
    e,
  )
);
var Ut = vu((Xr, rs) => {
  (function (e, r) {
    if (typeof define == "function" && define.amd)
      define("webextension-polyfill", ["module"], r);
    else if (typeof Xr < "u") r(rs);
    else {
      var n = { exports: {} };
      (r(n), (e.browser = n.exports));
    }
  })(
    typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : Xr,
    function (e) {
      "use strict";
      if (
        !(
          globalThis.chrome &&
          globalThis.chrome.runtime &&
          globalThis.chrome.runtime.id
        )
      )
        throw new Error(
          "This script should only be loaded in a browser extension.",
        );
      if (
        globalThis.browser &&
        globalThis.browser.runtime &&
        globalThis.browser.runtime.id
      )
        e.exports = globalThis.browser;
      else {
        let r = "The message port closed before a response was received.",
          n = (i) => {
            let t = {
              alarms: {
                clear: { minArgs: 0, maxArgs: 1 },
                clearAll: { minArgs: 0, maxArgs: 0 },
                get: { minArgs: 0, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
              },
              bookmarks: {
                create: { minArgs: 1, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 1 },
                getChildren: { minArgs: 1, maxArgs: 1 },
                getRecent: { minArgs: 1, maxArgs: 1 },
                getSubTree: { minArgs: 1, maxArgs: 1 },
                getTree: { minArgs: 0, maxArgs: 0 },
                move: { minArgs: 2, maxArgs: 2 },
                remove: { minArgs: 1, maxArgs: 1 },
                removeTree: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              browserAction: {
                disable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 },
                enable: { minArgs: 0, maxArgs: 1, fallbackToNoCallback: !0 },
                getBadgeBackgroundColor: { minArgs: 1, maxArgs: 1 },
                getBadgeText: { minArgs: 1, maxArgs: 1 },
                getPopup: { minArgs: 1, maxArgs: 1 },
                getTitle: { minArgs: 1, maxArgs: 1 },
                openPopup: { minArgs: 0, maxArgs: 0 },
                setBadgeBackgroundColor: {
                  minArgs: 1,
                  maxArgs: 1,
                  fallbackToNoCallback: !0,
                },
                setBadgeText: {
                  minArgs: 1,
                  maxArgs: 1,
                  fallbackToNoCallback: !0,
                },
                setIcon: { minArgs: 1, maxArgs: 1 },
                setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              browsingData: {
                remove: { minArgs: 2, maxArgs: 2 },
                removeCache: { minArgs: 1, maxArgs: 1 },
                removeCookies: { minArgs: 1, maxArgs: 1 },
                removeDownloads: { minArgs: 1, maxArgs: 1 },
                removeFormData: { minArgs: 1, maxArgs: 1 },
                removeHistory: { minArgs: 1, maxArgs: 1 },
                removeLocalStorage: { minArgs: 1, maxArgs: 1 },
                removePasswords: { minArgs: 1, maxArgs: 1 },
                removePluginData: { minArgs: 1, maxArgs: 1 },
                settings: { minArgs: 0, maxArgs: 0 },
              },
              commands: { getAll: { minArgs: 0, maxArgs: 0 } },
              contextMenus: {
                remove: { minArgs: 1, maxArgs: 1 },
                removeAll: { minArgs: 0, maxArgs: 0 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              cookies: {
                get: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 1, maxArgs: 1 },
                getAllCookieStores: { minArgs: 0, maxArgs: 0 },
                remove: { minArgs: 1, maxArgs: 1 },
                set: { minArgs: 1, maxArgs: 1 },
              },
              devtools: {
                inspectedWindow: {
                  eval: { minArgs: 1, maxArgs: 2, singleCallbackArg: !1 },
                },
                panels: {
                  create: { minArgs: 3, maxArgs: 3, singleCallbackArg: !0 },
                  elements: { createSidebarPane: { minArgs: 1, maxArgs: 1 } },
                },
              },
              downloads: {
                cancel: { minArgs: 1, maxArgs: 1 },
                download: { minArgs: 1, maxArgs: 1 },
                erase: { minArgs: 1, maxArgs: 1 },
                getFileIcon: { minArgs: 1, maxArgs: 2 },
                open: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                pause: { minArgs: 1, maxArgs: 1 },
                removeFile: { minArgs: 1, maxArgs: 1 },
                resume: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
                show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              extension: {
                isAllowedFileSchemeAccess: { minArgs: 0, maxArgs: 0 },
                isAllowedIncognitoAccess: { minArgs: 0, maxArgs: 0 },
              },
              history: {
                addUrl: { minArgs: 1, maxArgs: 1 },
                deleteAll: { minArgs: 0, maxArgs: 0 },
                deleteRange: { minArgs: 1, maxArgs: 1 },
                deleteUrl: { minArgs: 1, maxArgs: 1 },
                getVisits: { minArgs: 1, maxArgs: 1 },
                search: { minArgs: 1, maxArgs: 1 },
              },
              i18n: {
                detectLanguage: { minArgs: 1, maxArgs: 1 },
                getAcceptLanguages: { minArgs: 0, maxArgs: 0 },
              },
              identity: { launchWebAuthFlow: { minArgs: 1, maxArgs: 1 } },
              idle: { queryState: { minArgs: 1, maxArgs: 1 } },
              management: {
                get: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
                getSelf: { minArgs: 0, maxArgs: 0 },
                setEnabled: { minArgs: 2, maxArgs: 2 },
                uninstallSelf: { minArgs: 0, maxArgs: 1 },
              },
              notifications: {
                clear: { minArgs: 1, maxArgs: 1 },
                create: { minArgs: 1, maxArgs: 2 },
                getAll: { minArgs: 0, maxArgs: 0 },
                getPermissionLevel: { minArgs: 0, maxArgs: 0 },
                update: { minArgs: 2, maxArgs: 2 },
              },
              pageAction: {
                getPopup: { minArgs: 1, maxArgs: 1 },
                getTitle: { minArgs: 1, maxArgs: 1 },
                hide: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setIcon: { minArgs: 1, maxArgs: 1 },
                setPopup: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                setTitle: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
                show: { minArgs: 1, maxArgs: 1, fallbackToNoCallback: !0 },
              },
              permissions: {
                contains: { minArgs: 1, maxArgs: 1 },
                getAll: { minArgs: 0, maxArgs: 0 },
                remove: { minArgs: 1, maxArgs: 1 },
                request: { minArgs: 1, maxArgs: 1 },
              },
              runtime: {
                getBackgroundPage: { minArgs: 0, maxArgs: 0 },
                getPlatformInfo: { minArgs: 0, maxArgs: 0 },
                openOptionsPage: { minArgs: 0, maxArgs: 0 },
                requestUpdateCheck: { minArgs: 0, maxArgs: 0 },
                sendMessage: { minArgs: 1, maxArgs: 3 },
                sendNativeMessage: { minArgs: 2, maxArgs: 2 },
                setUninstallURL: { minArgs: 1, maxArgs: 1 },
              },
              sessions: {
                getDevices: { minArgs: 0, maxArgs: 1 },
                getRecentlyClosed: { minArgs: 0, maxArgs: 1 },
                restore: { minArgs: 0, maxArgs: 1 },
              },
              storage: {
                local: {
                  clear: { minArgs: 0, maxArgs: 0 },
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                  remove: { minArgs: 1, maxArgs: 1 },
                  set: { minArgs: 1, maxArgs: 1 },
                },
                managed: {
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                },
                sync: {
                  clear: { minArgs: 0, maxArgs: 0 },
                  get: { minArgs: 0, maxArgs: 1 },
                  getBytesInUse: { minArgs: 0, maxArgs: 1 },
                  remove: { minArgs: 1, maxArgs: 1 },
                  set: { minArgs: 1, maxArgs: 1 },
                },
              },
              tabs: {
                captureVisibleTab: { minArgs: 0, maxArgs: 2 },
                create: { minArgs: 1, maxArgs: 1 },
                detectLanguage: { minArgs: 0, maxArgs: 1 },
                discard: { minArgs: 0, maxArgs: 1 },
                duplicate: { minArgs: 1, maxArgs: 1 },
                executeScript: { minArgs: 1, maxArgs: 2 },
                get: { minArgs: 1, maxArgs: 1 },
                getCurrent: { minArgs: 0, maxArgs: 0 },
                getZoom: { minArgs: 0, maxArgs: 1 },
                getZoomSettings: { minArgs: 0, maxArgs: 1 },
                goBack: { minArgs: 0, maxArgs: 1 },
                goForward: { minArgs: 0, maxArgs: 1 },
                highlight: { minArgs: 1, maxArgs: 1 },
                insertCSS: { minArgs: 1, maxArgs: 2 },
                move: { minArgs: 2, maxArgs: 2 },
                query: { minArgs: 1, maxArgs: 1 },
                reload: { minArgs: 0, maxArgs: 2 },
                remove: { minArgs: 1, maxArgs: 1 },
                removeCSS: { minArgs: 1, maxArgs: 2 },
                sendMessage: { minArgs: 2, maxArgs: 3 },
                setZoom: { minArgs: 1, maxArgs: 2 },
                setZoomSettings: { minArgs: 1, maxArgs: 2 },
                update: { minArgs: 1, maxArgs: 2 },
              },
              topSites: { get: { minArgs: 0, maxArgs: 0 } },
              webNavigation: {
                getAllFrames: { minArgs: 1, maxArgs: 1 },
                getFrame: { minArgs: 1, maxArgs: 1 },
              },
              webRequest: {
                handlerBehaviorChanged: { minArgs: 0, maxArgs: 0 },
              },
              windows: {
                create: { minArgs: 0, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 2 },
                getAll: { minArgs: 0, maxArgs: 1 },
                getCurrent: { minArgs: 0, maxArgs: 1 },
                getLastFocused: { minArgs: 0, maxArgs: 1 },
                remove: { minArgs: 1, maxArgs: 1 },
                update: { minArgs: 2, maxArgs: 2 },
              },
            };
            if (Object.keys(t).length === 0)
              throw new Error(
                "api-metadata.json has not been included in browser-polyfill",
              );
            class o extends WeakMap {
              constructor($, D = void 0) {
                (super(D), (this.createItem = $));
              }
              get($) {
                return (
                  this.has($) || this.set($, this.createItem($)),
                  super.get($)
                );
              }
            }
            let a = (g) =>
                g && typeof g == "object" && typeof g.then == "function",
              s =
                (g, $) =>
                (...D) => {
                  i.runtime.lastError
                    ? g.reject(new Error(i.runtime.lastError.message))
                    : $.singleCallbackArg ||
                        (D.length <= 1 && $.singleCallbackArg !== !1)
                      ? g.resolve(D[0])
                      : g.resolve(D);
                },
              u = (g) => (g == 1 ? "argument" : "arguments"),
              l = (g, $) =>
                function (V, ...I) {
                  if (I.length < $.minArgs)
                    throw new Error(
                      `Expected at least ${$.minArgs} ${u($.minArgs)} for ${g}(), got ${I.length}`,
                    );
                  if (I.length > $.maxArgs)
                    throw new Error(
                      `Expected at most ${$.maxArgs} ${u($.maxArgs)} for ${g}(), got ${I.length}`,
                    );
                  return new Promise((C, q) => {
                    if ($.fallbackToNoCallback)
                      try {
                        V[g](...I, s({ resolve: C, reject: q }, $));
                      } catch (E) {
                        (console.warn(
                          `${g} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,
                          E,
                        ),
                          V[g](...I),
                          ($.fallbackToNoCallback = !1),
                          ($.noCallback = !0),
                          C());
                      }
                    else
                      $.noCallback
                        ? (V[g](...I), C())
                        : V[g](...I, s({ resolve: C, reject: q }, $));
                  });
                },
              m = (g, $, D) =>
                new Proxy($, {
                  apply(V, I, C) {
                    return D.call(I, g, ...C);
                  },
                }),
              p = Function.call.bind(Object.prototype.hasOwnProperty),
              d = (g, $ = {}, D = {}) => {
                let V = Object.create(null),
                  I = {
                    has(q, E) {
                      return E in g || E in V;
                    },
                    get(q, E, W) {
                      if (E in V) return V[E];
                      if (!(E in g)) return;
                      let G = g[E];
                      if (typeof G == "function")
                        if (typeof $[E] == "function") G = m(g, g[E], $[E]);
                        else if (p(D, E)) {
                          let De = l(E, D[E]);
                          G = m(g, g[E], De);
                        } else G = G.bind(g);
                      else if (
                        typeof G == "object" &&
                        G !== null &&
                        (p($, E) || p(D, E))
                      )
                        G = d(G, $[E], D[E]);
                      else if (p(D, "*")) G = d(G, $[E], D["*"]);
                      else
                        return (
                          Object.defineProperty(V, E, {
                            configurable: !0,
                            enumerable: !0,
                            get() {
                              return g[E];
                            },
                            set(De) {
                              g[E] = De;
                            },
                          }),
                          G
                        );
                      return ((V[E] = G), G);
                    },
                    set(q, E, W, G) {
                      return (E in V ? (V[E] = W) : (g[E] = W), !0);
                    },
                    defineProperty(q, E, W) {
                      return Reflect.defineProperty(V, E, W);
                    },
                    deleteProperty(q, E) {
                      return Reflect.deleteProperty(V, E);
                    },
                  },
                  C = Object.create(g);
                return new Proxy(C, I);
              },
              _ = (g) => ({
                addListener($, D, ...V) {
                  $.addListener(g.get(D), ...V);
                },
                hasListener($, D) {
                  return $.hasListener(g.get(D));
                },
                removeListener($, D) {
                  $.removeListener(g.get(D));
                },
              }),
              h = new o((g) =>
                typeof g != "function"
                  ? g
                  : function (D) {
                      let V = d(
                        D,
                        {},
                        { getContent: { minArgs: 0, maxArgs: 0 } },
                      );
                      g(V);
                    },
              ),
              w = new o((g) =>
                typeof g != "function"
                  ? g
                  : function (D, V, I) {
                      let C = !1,
                        q,
                        E = new Promise((Fe) => {
                          q = function (ne) {
                            ((C = !0), Fe(ne));
                          };
                        }),
                        W;
                      try {
                        W = g(D, V, q);
                      } catch (Fe) {
                        W = Promise.reject(Fe);
                      }
                      let G = W !== !0 && a(W);
                      if (W !== !0 && !G && !C) return !1;
                      let De = (Fe) => {
                        Fe.then(
                          (ne) => {
                            I(ne);
                          },
                          (ne) => {
                            let Br;
                            (ne &&
                            (ne instanceof Error ||
                              typeof ne.message == "string")
                              ? (Br = ne.message)
                              : (Br = "An unexpected error occurred"),
                              I({
                                __mozWebExtensionPolyfillReject__: !0,
                                message: Br,
                              }));
                          },
                        ).catch((ne) => {
                          console.error(
                            "Failed to send onMessage rejected reply",
                            ne,
                          );
                        });
                      };
                      return (De(G ? W : E), !0);
                    },
              ),
              z = ({ reject: g, resolve: $ }, D) => {
                i.runtime.lastError
                  ? i.runtime.lastError.message === r
                    ? $()
                    : g(new Error(i.runtime.lastError.message))
                  : D && D.__mozWebExtensionPolyfillReject__
                    ? g(new Error(D.message))
                    : $(D);
              },
              S = (g, $, D, ...V) => {
                if (V.length < $.minArgs)
                  throw new Error(
                    `Expected at least ${$.minArgs} ${u($.minArgs)} for ${g}(), got ${V.length}`,
                  );
                if (V.length > $.maxArgs)
                  throw new Error(
                    `Expected at most ${$.maxArgs} ${u($.maxArgs)} for ${g}(), got ${V.length}`,
                  );
                return new Promise((I, C) => {
                  let q = z.bind(null, { resolve: I, reject: C });
                  (V.push(q), D.sendMessage(...V));
                });
              },
              A = {
                devtools: { network: { onRequestFinished: _(h) } },
                runtime: {
                  onMessage: _(w),
                  onMessageExternal: _(w),
                  sendMessage: S.bind(null, "sendMessage", {
                    minArgs: 1,
                    maxArgs: 3,
                  }),
                },
                tabs: {
                  sendMessage: S.bind(null, "sendMessage", {
                    minArgs: 2,
                    maxArgs: 3,
                  }),
                },
              },
              k = {
                clear: { minArgs: 1, maxArgs: 1 },
                get: { minArgs: 1, maxArgs: 1 },
                set: { minArgs: 1, maxArgs: 1 },
              };
            return (
              (t.privacy = {
                network: { "*": k },
                services: { "*": k },
                websites: { "*": k },
              }),
              d(i, A, t)
            );
          };
        e.exports = n(chrome);
      }
    },
  );
});
var O = {};
(function () {
  function e(a) {
    if (
      ((a = a || [0, 97, 115, 109, 1, 0, 0, 0]),
      typeof WebAssembly != "object" ||
        typeof WebAssembly.instantiate != "function")
    )
      return !1;
    try {
      var a = new WebAssembly.Module(new Uint8Array(a));
      if (a instanceof WebAssembly.Module)
        return new WebAssembly.Instance(a) instanceof WebAssembly.Instance;
    } catch {}
    return !1;
  }
  function r() {
    try {
      var a = new WebAssembly.Memory({ initial: 1, maximum: 1, shared: !0 });
      return a.buffer instanceof SharedArrayBuffer;
    } catch {}
    return !1;
  }
  var n = typeof process < "u";
  (O.base ||
    ((O.base = import.meta.url), (O.base = O.base.replace(/\/[^\/]*$/, ""))),
    (O.isWebAssemblySupported = e),
    (O.isThreadingSupported = r));
  function i(a) {
    a = a || {};
    var s = !a.nowasm && e(),
      u = a.yesthreads && s && !a.nothreads && r();
    return s ? (u ? "thr" : "wasm") : "asm";
  }
  ((O.target = i),
    (O.VER = "6.5.7.1"),
    (O.CONFIG = "h264-aac-mp3"),
    (O.DBG = ""),
    (O.factories = {}));
  var t = {};
  ((t.i64tof64 = function (a, s) {
    return (!s && a >= 0) || (s === -1 && a < 0)
      ? a
      : s * 4294967296 + a + (a < 0 ? 4294967296 : 0);
  }),
    (t.f64toi64 = function (a) {
      return [~~a, Math.floor(a / 4294967296)];
    }),
    (t.i64ToBigInt = function (a, s) {
      var u = new DataView(new ArrayBuffer(8));
      return (u.setInt32(0, a, !0), u.setInt32(4, s, !0), u.getBigInt64(0, !0));
    }),
    (t.bigIntToi64 = function (a) {
      var s = new DataView(new ArrayBuffer(8));
      return (s.setBigInt64(0, a, !0), [s.getInt32(0, !0), s.getInt32(4, !0)]);
    }),
    (t.ff_channel_layout = function (a) {
      return a.channel_layout
        ? a.channel_layout
        : a.channels && a.channels !== 1
          ? (1 << a.channels) - 1
          : 4;
    }),
    (t.ff_channels = function (a) {
      if (a.channels) return a.channels;
      if (a.channel_layout) {
        for (var s = 0, u = a.channel_layout; u; ) ((s += u & 1), (u >>= 1));
        return s;
      } else return 1;
    }));
  function o(a, s) {
    typeof s === void 0 && (s = 0);
    var u = s;
    a.forEach(function (l) {
      t[l] = u++;
    });
  }
  ((t.AV_TIME_BASE = 1e6),
    (t.AV_OPT_SEARCH_CHILDREN = 1),
    o(
      [
        "AVMEDIA_TYPE_UNKNOWN",
        "AVMEDIA_TYPE_VIDEO",
        "AVMEDIA_TYPE_AUDIO",
        "AVMEDIA_TYPE_DATA",
        "AVMEDIA_TYPE_SUBTITLE",
        "AVMEDIA_TYPE_ATTACHMENT",
      ],
      -1,
    ),
    o(
      [
        "AV_SAMPLE_FMT_NONE",
        "AV_SAMPLE_FMT_U8",
        "AV_SAMPLE_FMT_S16",
        "AV_SAMPLE_FMT_S32",
        "AV_SAMPLE_FMT_FLT",
        "AV_SAMPLE_FMT_DBL",
        "AV_SAMPLE_FMT_U8P",
        "AV_SAMPLE_FMT_S16P",
        "AV_SAMPLE_FMT_S32P",
        "AV_SAMPLE_FMT_FLTP",
        "AV_SAMPLE_FMT_DBLP",
        "AV_SAMPLE_FMT_S64",
        "AV_SAMPLE_FMT_S64P",
        "AV_SAMPLE_FMT_NB",
      ],
      -1,
    ),
    o(
      [
        "AV_PIX_FMT_NONE",
        "AV_PIX_FMT_YUV420P",
        "AV_PIX_FMT_YUYV422",
        "AV_PIX_FMT_RGB24",
        "AV_PIX_FMT_BGR24",
        "AV_PIX_FMT_YUV422P",
        "AV_PIX_FMT_YUV444P",
        "AV_PIX_FMT_YUV410P",
        "AV_PIX_FMT_YUV411P",
        "AV_PIX_FMT_GRAY8",
        "AV_PIX_FMT_MONOWHITE",
        "AV_PIX_FMT_MONOBLACK",
        "AV_PIX_FMT_PAL8",
        "AV_PIX_FMT_YUVJ420P",
        "AV_PIX_FMT_YUVJ422P",
        "AV_PIX_FMT_YUVJ444P",
        "AV_PIX_FMT_UYVY422",
        "AV_PIX_FMT_UYYVYY411",
        "AV_PIX_FMT_BGR8",
        "AV_PIX_FMT_BGR4",
        "AV_PIX_FMT_BGR4_BYTE",
        "AV_PIX_FMT_RGB8",
        "AV_PIX_FMT_RGB4",
        "AV_PIX_FMT_RGB4_BYTE",
        "AV_PIX_FMT_NV12",
        "AV_PIX_FMT_NV21",
        "AV_PIX_FMT_ARGB",
        "AV_PIX_FMT_RGBA",
        "AV_PIX_FMT_ABGR",
        "AV_PIX_FMT_BGRA",
        "AV_PIX_FMT_GRAY16BE",
        "AV_PIX_FMT_GRAY16LE",
        "AV_PIX_FMT_YUV440P",
        "AV_PIX_FMT_YUVJ440P",
        "AV_PIX_FMT_YUVA420P",
        "AV_PIX_FMT_RGB48BE",
        "AV_PIX_FMT_RGB48LE",
        "AV_PIX_FMT_RGB565BE",
        "AV_PIX_FMT_RGB565LE",
        "AV_PIX_FMT_RGB555BE",
        "AV_PIX_FMT_RGB555LE",
        "AV_PIX_FMT_BGR565BE",
        "AV_PIX_FMT_BGR565LE",
        "AV_PIX_FMT_BGR555BE",
        "AV_PIX_FMT_BGR555LE",
      ],
      -1,
    ),
    (t.AVIO_FLAG_READ = 1),
    (t.AVIO_FLAG_WRITE = 2),
    (t.AVIO_FLAG_READ_WRITE = 3),
    (t.AVIO_FLAG_NONBLOCK = 8),
    (t.AVIO_FLAG_DIRECT = 32768),
    (t.AVFMT_FLAG_NOBUFFER = 64),
    (t.AVFMT_FLAG_FLUSH_PACKETS = 512),
    (t.AVSEEK_FLAG_BACKWARD = 1),
    (t.AVSEEK_FLAG_BYTE = 2),
    (t.AVSEEK_FLAG_ANY = 4),
    (t.AVSEEK_FLAG_FRAME = 8),
    (t.AVDISCARD_NONE = -16),
    (t.AVDISCARD_DEFAULT = 0),
    (t.AVDISCARD_NONREF = 8),
    (t.AVDISCARD_BIDIR = 16),
    (t.AVDISCARD_NONINTRA = 24),
    (t.AVDISCARD_NONKEY = 32),
    (t.AVDISCARD_ALL = 48),
    (t.AV_LOG_QUIET = -8),
    (t.AV_LOG_PANIC = 0),
    (t.AV_LOG_FATAL = 8),
    (t.AV_LOG_ERROR = 16),
    (t.AV_LOG_WARNING = 24),
    (t.AV_LOG_INFO = 32),
    (t.AV_LOG_VERBOSE = 40),
    (t.AV_LOG_DEBUG = 48),
    (t.AV_LOG_TRACE = 56),
    (t.AV_PKT_FLAG_KEY = 1),
    (t.AV_PKT_FLAG_CORRUPT = 2),
    (t.AV_PKT_FLAG_DISCARD = 4),
    (t.AV_PKT_FLAG_TRUSTED = 8),
    (t.AV_PKT_FLAG_DISPOSABLE = 16),
    o(
      [
        "E2BIG",
        "EPERM",
        "EADDRINUSE",
        "EADDRNOTAVAIL",
        "EAFNOSUPPORT",
        "EAGAIN",
        "EALREADY",
        "EBADF",
        "EBADMSG",
        "EBUSY",
        "ECANCELED",
        "ECHILD",
        "ECONNABORTED",
        "ECONNREFUSED",
        "ECONNRESET",
        "EDEADLOCK",
        "EDESTADDRREQ",
        "EDOM",
        "EDQUOT",
        "EEXIST",
        "EFAULT",
        "EFBIG",
        "EHOSTUNREACH",
        "EIDRM",
        "EILSEQ",
        "EINPROGRESS",
        "EINTR",
        "EINVAL",
        "EIO",
        "EISCONN",
        "EISDIR",
        "ELOOP",
        "EMFILE",
        "EMLINK",
        "EMSGSIZE",
        "EMULTIHOP",
        "ENAMETOOLONG",
        "ENETDOWN",
        "ENETRESET",
        "ENETUNREACH",
        "ENFILE",
        "ENOBUFS",
        "ENODEV",
        "ENOENT",
      ],
      1,
    ),
    (t.AVERROR_EOF = -541478725),
    Object.assign(O, t),
    (O.LibAV = function (a) {
      a = a || {};
      var s = a.base || O.base,
        u = i(a),
        l = "h264-aac-mp3";
      u === "asm" && (l = a.variant || O.variant || "h264-aac-mp3");
      var m = !0;
      m && (a.noes6 || O.noes6) && (m = !1);
      var p =
          a.toImport ||
          O.toImport ||
          s + "/libav-6.5.7.1-" + l + "." + u + "." + (m ? "mjs" : "js"),
        d,
        _ = "direct";
      return (
        u === "thr"
          ? (_ = "threads")
          : !n && !a.noworker && typeof Worker < "u" && (_ = "worker"),
        Promise.all([])
          .then(function () {
            if (a.factory || O.factory) return a.factory || O.factory;
            if (O.factories[p]) return O.factories[p];
            if (_ !== "worker")
              return m
                ? import(p).then(function (h) {
                    return ((O.factories[p] = h.default), h.default);
                  })
                : n
                  ? (O.factories[p] = Ka(p))
                  : typeof importScripts < "u"
                    ? (importScripts(p), (O.factories[p] = LibAVFactory))
                    : new Promise(function (h, w) {
                        var z = document.createElement("script");
                        ((z.src = p),
                          z.addEventListener("load", h),
                          z.addEventListener("error", w),
                          (z.async = !0),
                          document.body.appendChild(z));
                      }).then(function () {
                        return (O.factories[p] = LibAVFactory);
                      });
          })
          .then(function (h) {
            return _ === "worker"
              ? ((d = {}),
                (d.worker = new Worker(p, { type: m ? "module" : "classic" })),
                d.worker.postMessage({
                  config: {
                    variant: a.variant || O.variant,
                    wasmurl: a.wasmurl || O.wasmurl,
                  },
                }),
                new Promise(function (w, z) {
                  ((d.on = 1),
                    (d.handlers = {
                      onready: [
                        function () {
                          w();
                        },
                        null,
                      ],
                      onwrite: [
                        function (A) {
                          d.onwrite && d.onwrite.apply(d, A);
                        },
                        null,
                      ],
                      onread: [
                        function (A) {
                          try {
                            var k = null;
                            (d.onread && (k = d.onread.apply(d, A)),
                              k &&
                                k.then &&
                                k.catch &&
                                k.catch(function (g) {
                                  d.ff_reader_dev_send(A[0], null, {
                                    error: g,
                                  });
                                }));
                          } catch (g) {
                            d.ff_reader_dev_send(A[0], null, { error: g });
                          }
                        },
                        null,
                      ],
                      onblockread: [
                        function (A) {
                          try {
                            var k = null;
                            (d.onblockread && (k = d.onblockread.apply(d, A)),
                              k &&
                                k.then &&
                                k.catch &&
                                k.catch(function (g) {
                                  d.ff_block_reader_dev_send(A[0], A[1], null, {
                                    error: g,
                                  });
                                }));
                          } catch (g) {
                            d.ff_block_reader_dev_send(A[0], A[1], null, {
                              error: g,
                            });
                          }
                        },
                        null,
                      ],
                    }),
                    (d.c = function () {
                      for (
                        var A = Array.prototype.slice.call(arguments),
                          k = [],
                          g = 0;
                        g < A.length;
                        g++
                      )
                        A[g] &&
                          A[g].libavjsTransfer &&
                          k.push.apply(k, A[g].libavjsTransfer);
                      return new Promise(function ($, D) {
                        var V = d.on++;
                        ((A = [V].concat(A)),
                          (d.handlers[V] = [$, D]),
                          d.worker.postMessage(A, k));
                      });
                    }));
                  function S(A) {
                    var k = A.data[0],
                      g = d.handlers[k];
                    g &&
                      (A.data[2] ? g[0](A.data[3]) : g[1](A.data[3]),
                      typeof k == "number" && delete d.handlers[k]);
                  }
                  ((d.worker.onmessage = S),
                    (d.terminate = function () {
                      d.worker.terminate();
                    }));
                }))
              : _ === "threads"
                ? Promise.all([])
                    .then(function () {
                      return h({
                        wasmurl: a.wasmurl || O.wasmurl,
                        variant: a.variant || O.variant,
                      });
                    })
                    .then(function (w) {
                      d = w;
                      var z = d.libavjs_create_main_thread(),
                        S = d.PThread.pthreads[z],
                        A = 0,
                        k = 1,
                        g = {},
                        $ = null,
                        D = new Promise(function (I) {
                          $ = I;
                        });
                      d.c = function () {
                        var I = Array.prototype.slice.call(arguments);
                        return new Promise(function (C, q) {
                          var E = k++;
                          ((I = [E].concat(I)),
                            (g[E] = [C, q]),
                            S.postMessage({ c: "libavjs_run", a: I }));
                        });
                      };
                      var V = S.onmessage;
                      return (
                        (S.onmessage = function (I) {
                          if (I.data && I.data.c === "libavjs_ret") {
                            var C = I.data.a,
                              q = g[C[0]];
                            q &&
                              (C[2] ? q[0](C[3]) : q[1](C[3]), delete g[C[0]]);
                          } else if (
                            I.data &&
                            I.data.c === "libavjs_wait_reader"
                          )
                            if (d.readerDevReady(I.data.fd))
                              S.postMessage({
                                c: "libavjs_wait_reader",
                                fd: I.data.fd,
                              });
                            else {
                              var E = d.fdName(I.data.fd),
                                W = d.ff_reader_dev_waiters[E];
                              (W || (W = d.ff_reader_dev_waiters[E] = []),
                                W.push(function () {
                                  S.postMessage({
                                    c: "libavjs_wait_reader",
                                    fd: I.data.fd,
                                  });
                                }));
                            }
                          else if (I.data && I.data.c === "libavjs_ready") $();
                          else return V.apply(this, arguments);
                        }),
                        (d.terminate = function () {
                          d.PThread.unusedWorkers
                            .concat(d.PThread.runningWorkers)
                            .forEach(function (I) {
                              I.terminate();
                            });
                        }),
                        D
                      );
                    })
                : Promise.all([])
                    .then(function () {
                      return h({
                        wasmurl: a.wasmurl || O.wasmurl,
                        variant: a.variant || O.variant,
                      });
                    })
                    .then(function (w) {
                      ((d = w),
                        (d.worker = !1),
                        (d.c = function (z) {
                          var S = Array.prototype.slice.call(arguments, 1);
                          return new Promise(function (A, k) {
                            try {
                              A(d[z].apply(d, S));
                            } catch (g) {
                              k(g);
                            }
                          });
                        }),
                        (d.terminate = function () {}));
                    });
          })
          .then(function () {
            function h(A) {
              A.forEach(function (k) {
                d[k] = function () {
                  return d.c.apply(
                    d,
                    [k].concat(Array.prototype.slice.call(arguments)),
                  );
                };
              });
            }
            function w(A) {
              A.forEach(function (k) {
                var g = (d[k + "_sync"] = d[k]);
                d[k] = function () {
                  var $ = arguments;
                  return new Promise(function (D, V) {
                    try {
                      var I = g.apply(d, $);
                      typeof I == "object" && I !== null && I.then
                        ? I.then(D).catch(V)
                        : D(I);
                    } catch (C) {
                      V(C);
                    }
                  });
                };
              });
            }
            var z = [
                "av_get_bytes_per_sample",
                "av_compare_ts_js",
                "av_opt_set",
                "av_opt_set_int_list_js",
                "av_frame_alloc",
                "av_frame_clone",
                "av_frame_free",
                "av_frame_get_buffer",
                "av_frame_make_writable",
                "av_frame_ref",
                "av_frame_unref",
                "ff_frame_rescale_ts_js",
                "av_log_get_level",
                "av_log_set_level",
                "av_packet_alloc",
                "av_packet_clone",
                "av_packet_free",
                "av_packet_new_side_data",
                "av_packet_ref",
                "av_packet_rescale_ts_js",
                "av_packet_unref",
                "av_strdup",
                "av_buffersink_get_frame",
                "av_buffersink_get_time_base_num",
                "av_buffersink_get_time_base_den",
                "av_buffersink_set_frame_size",
                "ff_buffersink_set_ch_layout",
                "av_buffersrc_add_frame_flags",
                "avfilter_free",
                "avfilter_get_by_name",
                "avfilter_graph_alloc",
                "avfilter_graph_config",
                "avfilter_graph_create_filter_js",
                "avfilter_graph_free",
                "avfilter_graph_parse",
                "avfilter_inout_alloc",
                "avfilter_inout_free",
                "avfilter_link",
                "avcodec_alloc_context3",
                "avcodec_close",
                "avcodec_descriptor_get",
                "avcodec_descriptor_get_by_name",
                "avcodec_descriptor_next",
                "avcodec_find_decoder",
                "avcodec_find_decoder_by_name",
                "avcodec_find_encoder",
                "avcodec_find_encoder_by_name",
                "avcodec_flush_buffers",
                "avcodec_free_context",
                "avcodec_get_name",
                "avcodec_open2",
                "avcodec_open2_js",
                "avcodec_parameters_alloc",
                "avcodec_parameters_copy",
                "avcodec_parameters_free",
                "avcodec_parameters_from_context",
                "avcodec_parameters_to_context",
                "avcodec_receive_frame",
                "avcodec_receive_packet",
                "avcodec_send_frame",
                "avcodec_send_packet",
                "av_find_input_format",
                "avformat_alloc_context",
                "avformat_alloc_output_context2_js",
                "avformat_close_input",
                "avformat_find_stream_info",
                "avformat_flush",
                "avformat_free_context",
                "avformat_new_stream",
                "avformat_open_input",
                "avformat_open_input_js",
                "av_seek_frame",
                "avformat_seek_file",
                "avformat_seek_file_min",
                "avformat_seek_file_max",
                "avformat_seek_file_approx",
                "avformat_write_header",
                "avio_open2_js",
                "avio_close",
                "avio_flush",
                "av_find_best_stream",
                "av_get_sample_fmt_name",
                "av_grow_packet",
                "av_interleaved_write_frame",
                "av_packet_make_writable",
                "av_pix_fmt_desc_get",
                "av_read_frame",
                "av_shrink_packet",
                "av_write_frame",
                "av_write_trailer",
                "av_dict_copy_js",
                "av_dict_free",
                "av_dict_set_js",
                "sws_getContext",
                "sws_freeContext",
                "sws_scale_frame",
                "AVPacketSideData_data",
                "AVPacketSideData_size",
                "AVPacketSideData_type",
                "AVPixFmtDescriptor_comp_depth",
                "ff_error",
                "ff_nothing",
                "calloc",
                "close",
                "dup2",
                "free",
                "malloc",
                "mallinfo_uordblks",
                "open",
                "strerror",
                "libavjs_with_swscale",
                "libavjs_create_main_thread",
                "ffmpeg_main",
                "ffprobe_main",
                "ffmpeg_interrupt",
                "ffmpeg_get_out_time_ms",
                "ffmpeg_get_total_size_bytes",
                "jsfetch_set_read_timeout",
                "jsfetch_set_fetch_timeout",
                "jsfetch_set_initial_retry_delay",
                "jsfetch_set_bypass_cache",
                "AVFrame_channel_layout",
                "AVFrame_channel_layout_s",
                "AVFrame_channel_layouthi",
                "AVFrame_channel_layouthi_s",
                "AVFrame_channels",
                "AVFrame_channels_s",
                "AVFrame_channel_layoutmask",
                "AVFrame_channel_layoutmask_s",
                "AVFrame_ch_layout_nb_channels",
                "AVFrame_ch_layout_nb_channels_s",
                "AVFrame_crop_bottom",
                "AVFrame_crop_bottom_s",
                "AVFrame_crop_left",
                "AVFrame_crop_left_s",
                "AVFrame_crop_right",
                "AVFrame_crop_right_s",
                "AVFrame_crop_top",
                "AVFrame_crop_top_s",
                "AVFrame_data_a",
                "AVFrame_data_a_s",
                "AVFrame_format",
                "AVFrame_format_s",
                "AVFrame_height",
                "AVFrame_height_s",
                "AVFrame_key_frame",
                "AVFrame_key_frame_s",
                "AVFrame_linesize_a",
                "AVFrame_linesize_a_s",
                "AVFrame_nb_samples",
                "AVFrame_nb_samples_s",
                "AVFrame_pict_type",
                "AVFrame_pict_type_s",
                "AVFrame_pts",
                "AVFrame_pts_s",
                "AVFrame_ptshi",
                "AVFrame_ptshi_s",
                "AVFrame_sample_aspect_ratio_num",
                "AVFrame_sample_aspect_ratio_num_s",
                "AVFrame_sample_aspect_ratio_den",
                "AVFrame_sample_aspect_ratio_den_s",
                "AVFrame_sample_aspect_ratio_s",
                "AVFrame_sample_rate",
                "AVFrame_sample_rate_s",
                "AVFrame_time_base_num",
                "AVFrame_time_base_num_s",
                "AVFrame_time_base_den",
                "AVFrame_time_base_den_s",
                "AVFrame_time_base_s",
                "AVFrame_width",
                "AVFrame_width_s",
                "AVPixFmtDescriptor_flags",
                "AVPixFmtDescriptor_flags_s",
                "AVPixFmtDescriptor_log2_chroma_h",
                "AVPixFmtDescriptor_log2_chroma_h_s",
                "AVPixFmtDescriptor_log2_chroma_w",
                "AVPixFmtDescriptor_log2_chroma_w_s",
                "AVPixFmtDescriptor_nb_components",
                "AVPixFmtDescriptor_nb_components_s",
                "AVCodec_name",
                "AVCodec_sample_fmts",
                "AVCodec_sample_fmts_s",
                "AVCodec_sample_fmts_a",
                "AVCodec_sample_fmts_a_s",
                "AVCodec_supported_samplerates",
                "AVCodec_supported_samplerates_s",
                "AVCodec_supported_samplerates_a",
                "AVCodec_supported_samplerates_a_s",
                "AVCodec_type",
                "AVCodec_type_s",
                "AVCodecContext_codec_id",
                "AVCodecContext_codec_id_s",
                "AVCodecContext_codec_type",
                "AVCodecContext_codec_type_s",
                "AVCodecContext_bit_rate",
                "AVCodecContext_bit_rate_s",
                "AVCodecContext_bit_ratehi",
                "AVCodecContext_bit_ratehi_s",
                "AVCodecContext_channel_layout",
                "AVCodecContext_channel_layout_s",
                "AVCodecContext_channel_layouthi",
                "AVCodecContext_channel_layouthi_s",
                "AVCodecContext_channels",
                "AVCodecContext_channels_s",
                "AVCodecContext_channel_layoutmask",
                "AVCodecContext_channel_layoutmask_s",
                "AVCodecContext_ch_layout_nb_channels",
                "AVCodecContext_ch_layout_nb_channels_s",
                "AVCodecContext_extradata",
                "AVCodecContext_extradata_s",
                "AVCodecContext_extradata_size",
                "AVCodecContext_extradata_size_s",
                "AVCodecContext_frame_size",
                "AVCodecContext_frame_size_s",
                "AVCodecContext_framerate_num",
                "AVCodecContext_framerate_num_s",
                "AVCodecContext_framerate_den",
                "AVCodecContext_framerate_den_s",
                "AVCodecContext_framerate_s",
                "AVCodecContext_gop_size",
                "AVCodecContext_gop_size_s",
                "AVCodecContext_height",
                "AVCodecContext_height_s",
                "AVCodecContext_keyint_min",
                "AVCodecContext_keyint_min_s",
                "AVCodecContext_level",
                "AVCodecContext_level_s",
                "AVCodecContext_max_b_frames",
                "AVCodecContext_max_b_frames_s",
                "AVCodecContext_pix_fmt",
                "AVCodecContext_pix_fmt_s",
                "AVCodecContext_profile",
                "AVCodecContext_profile_s",
                "AVCodecContext_rc_max_rate",
                "AVCodecContext_rc_max_rate_s",
                "AVCodecContext_rc_max_ratehi",
                "AVCodecContext_rc_max_ratehi_s",
                "AVCodecContext_rc_min_rate",
                "AVCodecContext_rc_min_rate_s",
                "AVCodecContext_rc_min_ratehi",
                "AVCodecContext_rc_min_ratehi_s",
                "AVCodecContext_sample_aspect_ratio_num",
                "AVCodecContext_sample_aspect_ratio_num_s",
                "AVCodecContext_sample_aspect_ratio_den",
                "AVCodecContext_sample_aspect_ratio_den_s",
                "AVCodecContext_sample_aspect_ratio_s",
                "AVCodecContext_sample_fmt",
                "AVCodecContext_sample_fmt_s",
                "AVCodecContext_sample_rate",
                "AVCodecContext_sample_rate_s",
                "AVCodecContext_time_base_num",
                "AVCodecContext_time_base_num_s",
                "AVCodecContext_time_base_den",
                "AVCodecContext_time_base_den_s",
                "AVCodecContext_time_base_s",
                "AVCodecContext_qmax",
                "AVCodecContext_qmax_s",
                "AVCodecContext_qmin",
                "AVCodecContext_qmin_s",
                "AVCodecContext_width",
                "AVCodecContext_width_s",
                "AVCodecDescriptor_id",
                "AVCodecDescriptor_id_s",
                "AVCodecDescriptor_long_name",
                "AVCodecDescriptor_long_name_s",
                "AVCodecDescriptor_mime_types_a",
                "AVCodecDescriptor_mime_types_a_s",
                "AVCodecDescriptor_name",
                "AVCodecDescriptor_name_s",
                "AVCodecDescriptor_props",
                "AVCodecDescriptor_props_s",
                "AVCodecDescriptor_type",
                "AVCodecDescriptor_type_s",
                "AVCodecParameters_bit_rate",
                "AVCodecParameters_bit_rate_s",
                "AVCodecParameters_channel_layoutmask",
                "AVCodecParameters_channel_layoutmask_s",
                "AVCodecParameters_channels",
                "AVCodecParameters_channels_s",
                "AVCodecParameters_ch_layout_nb_channels",
                "AVCodecParameters_ch_layout_nb_channels_s",
                "AVCodecParameters_chroma_location",
                "AVCodecParameters_chroma_location_s",
                "AVCodecParameters_codec_id",
                "AVCodecParameters_codec_id_s",
                "AVCodecParameters_codec_tag",
                "AVCodecParameters_codec_tag_s",
                "AVCodecParameters_codec_type",
                "AVCodecParameters_codec_type_s",
                "AVCodecParameters_color_primaries",
                "AVCodecParameters_color_primaries_s",
                "AVCodecParameters_color_range",
                "AVCodecParameters_color_range_s",
                "AVCodecParameters_color_space",
                "AVCodecParameters_color_space_s",
                "AVCodecParameters_color_trc",
                "AVCodecParameters_color_trc_s",
                "AVCodecParameters_extradata",
                "AVCodecParameters_extradata_s",
                "AVCodecParameters_extradata_size",
                "AVCodecParameters_extradata_size_s",
                "AVCodecParameters_format",
                "AVCodecParameters_format_s",
                "AVCodecParameters_framerate_num",
                "AVCodecParameters_framerate_num_s",
                "AVCodecParameters_framerate_den",
                "AVCodecParameters_framerate_den_s",
                "AVCodecParameters_framerate_s",
                "AVCodecParameters_height",
                "AVCodecParameters_height_s",
                "AVCodecParameters_level",
                "AVCodecParameters_level_s",
                "AVCodecParameters_profile",
                "AVCodecParameters_profile_s",
                "AVCodecParameters_sample_rate",
                "AVCodecParameters_sample_rate_s",
                "AVCodecParameters_width",
                "AVCodecParameters_width_s",
                "AVPacket_data",
                "AVPacket_data_s",
                "AVPacket_dts",
                "AVPacket_dts_s",
                "AVPacket_dtshi",
                "AVPacket_dtshi_s",
                "AVPacket_duration",
                "AVPacket_duration_s",
                "AVPacket_durationhi",
                "AVPacket_durationhi_s",
                "AVPacket_flags",
                "AVPacket_flags_s",
                "AVPacket_pos",
                "AVPacket_pos_s",
                "AVPacket_poshi",
                "AVPacket_poshi_s",
                "AVPacket_pts",
                "AVPacket_pts_s",
                "AVPacket_ptshi",
                "AVPacket_ptshi_s",
                "AVPacket_side_data",
                "AVPacket_side_data_s",
                "AVPacket_side_data_elems",
                "AVPacket_side_data_elems_s",
                "AVPacket_size",
                "AVPacket_size_s",
                "AVPacket_stream_index",
                "AVPacket_stream_index_s",
                "AVPacket_time_base_num",
                "AVPacket_time_base_num_s",
                "AVPacket_time_base_den",
                "AVPacket_time_base_den_s",
                "AVPacket_time_base_s",
                "AVFormatContext_duration",
                "AVFormatContext_duration_s",
                "AVFormatContext_durationhi",
                "AVFormatContext_durationhi_s",
                "AVFormatContext_flags",
                "AVFormatContext_flags_s",
                "AVFormatContext_nb_streams",
                "AVFormatContext_nb_streams_s",
                "AVFormatContext_oformat",
                "AVFormatContext_oformat_s",
                "AVFormatContext_pb",
                "AVFormatContext_pb_s",
                "AVFormatContext_start_time",
                "AVFormatContext_start_time_s",
                "AVFormatContext_start_timehi",
                "AVFormatContext_start_timehi_s",
                "AVFormatContext_streams_a",
                "AVFormatContext_streams_a_s",
                "AVStream_codecpar",
                "AVStream_codecpar_s",
                "AVStream_discard",
                "AVStream_discard_s",
                "AVStream_duration",
                "AVStream_duration_s",
                "AVStream_durationhi",
                "AVStream_durationhi_s",
                "AVStream_time_base_num",
                "AVStream_time_base_num_s",
                "AVStream_time_base_den",
                "AVStream_time_base_den_s",
                "AVStream_time_base_s",
                "AVFilterInOut_filter_ctx",
                "AVFilterInOut_filter_ctx_s",
                "AVFilterInOut_name",
                "AVFilterInOut_name_s",
                "AVFilterInOut_next",
                "AVFilterInOut_next_s",
                "AVFilterInOut_pad_idx",
                "AVFilterInOut_pad_idx_s",
                "ff_init_encoder",
                "ff_init_decoder",
                "ff_free_encoder",
                "ff_free_decoder",
                "ff_encode_multi",
                "ff_decode_multi",
                "ff_set_packet",
                "ff_init_muxer",
                "ff_free_muxer",
                "ff_init_demuxer_file",
                "ff_write_multi",
                "ff_read_frame_multi",
                "ff_read_multi",
                "ff_init_filter_graph",
                "ff_filter_multi",
                "ff_decode_filter_multi",
                "ff_copyout_frame",
                "ff_copyout_frame_video",
                "ff_frame_video_packed_size",
                "ff_copyout_frame_video_packed",
                "ff_copyout_frame_video_imagedata",
                "ff_copyout_frame_ptr",
                "ff_copyin_frame",
                "ff_copyout_packet",
                "ff_copyout_packet_ptr",
                "ff_copyin_packet",
                "ff_copyout_codecpar",
                "ff_copyin_codecpar",
                "ff_malloc_int32_list",
                "ff_malloc_int64_list",
                "ffmpeg",
                "ffprobe",
                "av_frame_free_js",
                "av_packet_free_js",
                "avformat_close_input_js",
                "avcodec_free_context_js",
                "avcodec_parameters_free_js",
                "avfilter_graph_free_js",
                "avfilter_inout_free_js",
                "av_dict_free_js",
              ],
              S = [
                "readFile",
                "writeFile",
                "unlink",
                "unmount",
                "mkdev",
                "createLazyFile",
                "mkreaderdev",
                "mkblockreaderdev",
                "mkreadaheadfile",
                "unlinkreadaheadfile",
                "mkwriterdev",
                "mkstreamwriterdev",
                "mountwriterfs",
                "mkfsfhfile",
                "unlinkfsfhfile",
                "mkworkerfsfile",
                "unlinkworkerfsfile",
                "ff_reader_dev_send",
                "ff_block_reader_dev_send",
                "ff_reader_dev_waiting",
                "copyin_u8",
                "copyout_u8",
                "copyin_s16",
                "copyout_s16",
                "copyin_s32",
                "copyout_s32",
                "copyin_f32",
                "copyout_f32",
              ];
            return (
              (d.libavjsMode = _),
              _ === "worker"
                ? (h(z), h(S))
                : _ === "threads"
                  ? (h(z), w(S))
                  : (w(z), w(S)),
              Object.assign(d, t),
              d
            );
          })
      );
    }));
})();
var {
    base: om,
    isWebAssemblySupported: im,
    isThreadingSupported: am,
    target: sm,
    VER: lm,
    CONFIG: um,
    DBG: cm,
    factories: _m,
    i64tof64: dm,
    f64toi64: mm,
    i64ToBigInt: pm,
    bigIntToi64: fm,
    ff_channel_layout: gm,
    ff_channels: hm,
    AV_TIME_BASE: vm,
    AV_OPT_SEARCH_CHILDREN: ym,
    AVMEDIA_TYPE_UNKNOWN: bm,
    AVMEDIA_TYPE_VIDEO: wm,
    AVMEDIA_TYPE_AUDIO: xm,
    AVMEDIA_TYPE_DATA: Am,
    AVMEDIA_TYPE_SUBTITLE: km,
    AVMEDIA_TYPE_ATTACHMENT: $m,
    AV_SAMPLE_FMT_NONE: zm,
    AV_SAMPLE_FMT_U8: Sm,
    AV_SAMPLE_FMT_S16: Im,
    AV_SAMPLE_FMT_S32: Pm,
    AV_SAMPLE_FMT_FLT: Dm,
    AV_SAMPLE_FMT_DBL: Em,
    AV_SAMPLE_FMT_U8P: Vm,
    AV_SAMPLE_FMT_S16P: Tm,
    AV_SAMPLE_FMT_S32P: Om,
    AV_SAMPLE_FMT_FLTP: jm,
    AV_SAMPLE_FMT_DBLP: Nm,
    AV_SAMPLE_FMT_S64: Mm,
    AV_SAMPLE_FMT_S64P: Um,
    AV_SAMPLE_FMT_NB: Rm,
    AV_PIX_FMT_NONE: Cm,
    AV_PIX_FMT_YUV420P: Lm,
    AV_PIX_FMT_YUYV422: Fm,
    AV_PIX_FMT_RGB24: Zm,
    AV_PIX_FMT_BGR24: Bm,
    AV_PIX_FMT_YUV422P: qm,
    AV_PIX_FMT_YUV444P: Gm,
    AV_PIX_FMT_YUV410P: Hm,
    AV_PIX_FMT_YUV411P: Wm,
    AV_PIX_FMT_GRAY8: Ym,
    AV_PIX_FMT_MONOWHITE: Km,
    AV_PIX_FMT_MONOBLACK: Xm,
    AV_PIX_FMT_PAL8: Jm,
    AV_PIX_FMT_YUVJ420P: Qm,
    AV_PIX_FMT_YUVJ422P: ep,
    AV_PIX_FMT_YUVJ444P: tp,
    AV_PIX_FMT_UYVY422: rp,
    AV_PIX_FMT_UYYVYY411: np,
    AV_PIX_FMT_BGR8: op,
    AV_PIX_FMT_BGR4: ip,
    AV_PIX_FMT_BGR4_BYTE: ap,
    AV_PIX_FMT_RGB8: sp,
    AV_PIX_FMT_RGB4: lp,
    AV_PIX_FMT_RGB4_BYTE: up,
    AV_PIX_FMT_NV12: cp,
    AV_PIX_FMT_NV21: _p,
    AV_PIX_FMT_ARGB: dp,
    AV_PIX_FMT_RGBA: mp,
    AV_PIX_FMT_ABGR: pp,
    AV_PIX_FMT_BGRA: fp,
    AV_PIX_FMT_GRAY16BE: gp,
    AV_PIX_FMT_GRAY16LE: hp,
    AV_PIX_FMT_YUV440P: vp,
    AV_PIX_FMT_YUVJ440P: yp,
    AV_PIX_FMT_YUVA420P: bp,
    AV_PIX_FMT_RGB48BE: wp,
    AV_PIX_FMT_RGB48LE: xp,
    AV_PIX_FMT_RGB565BE: Ap,
    AV_PIX_FMT_RGB565LE: kp,
    AV_PIX_FMT_RGB555BE: $p,
    AV_PIX_FMT_RGB555LE: zp,
    AV_PIX_FMT_BGR565BE: Sp,
    AV_PIX_FMT_BGR565LE: Ip,
    AV_PIX_FMT_BGR555BE: Pp,
    AV_PIX_FMT_BGR555LE: Dp,
    AVIO_FLAG_READ: Ep,
    AVIO_FLAG_WRITE: Vp,
    AVIO_FLAG_READ_WRITE: Tp,
    AVIO_FLAG_NONBLOCK: Op,
    AVIO_FLAG_DIRECT: jp,
    AVFMT_FLAG_NOBUFFER: Np,
    AVFMT_FLAG_FLUSH_PACKETS: Mp,
    AVSEEK_FLAG_BACKWARD: Up,
    AVSEEK_FLAG_BYTE: Rp,
    AVSEEK_FLAG_ANY: Cp,
    AVSEEK_FLAG_FRAME: Lp,
    AVDISCARD_NONE: Fp,
    AVDISCARD_DEFAULT: Zp,
    AVDISCARD_NONREF: Bp,
    AVDISCARD_BIDIR: qp,
    AVDISCARD_NONINTRA: Gp,
    AVDISCARD_NONKEY: Hp,
    AVDISCARD_ALL: Wp,
    AV_LOG_QUIET: Yp,
    AV_LOG_PANIC: Kp,
    AV_LOG_FATAL: Xp,
    AV_LOG_ERROR: Jp,
    AV_LOG_WARNING: Qp,
    AV_LOG_INFO: ef,
    AV_LOG_VERBOSE: tf,
    AV_LOG_DEBUG: rf,
    AV_LOG_TRACE: nf,
    AV_PKT_FLAG_KEY: of,
    AV_PKT_FLAG_CORRUPT: af,
    AV_PKT_FLAG_DISCARD: sf,
    AV_PKT_FLAG_TRUSTED: lf,
    AV_PKT_FLAG_DISPOSABLE: uf,
    E2BIG: cf,
    EPERM: _f,
    EADDRINUSE: df,
    EADDRNOTAVAIL: mf,
    EAFNOSUPPORT: pf,
    EAGAIN: ff,
    EALREADY: gf,
    EBADF: hf,
    EBADMSG: vf,
    EBUSY: yf,
    ECANCELED: bf,
    ECHILD: wf,
    ECONNABORTED: xf,
    ECONNREFUSED: Af,
    ECONNRESET: kf,
    EDEADLOCK: $f,
    EDESTADDRREQ: zf,
    EDOM: Sf,
    EDQUOT: If,
    EEXIST: Pf,
    EFAULT: Df,
    EFBIG: Ef,
    EHOSTUNREACH: Vf,
    EIDRM: Tf,
    EILSEQ: Of,
    EINPROGRESS: jf,
    EINTR: Nf,
    EINVAL: Mf,
    EIO: Uf,
    EISCONN: Rf,
    EISDIR: Cf,
    ELOOP: Lf,
    EMFILE: Ff,
    EMLINK: Zf,
    EMSGSIZE: Bf,
    EMULTIHOP: qf,
    ENAMETOOLONG: Gf,
    ENETDOWN: Hf,
    ENETRESET: Wf,
    ENETUNREACH: Yf,
    ENFILE: Kf,
    ENOBUFS: Xf,
    ENODEV: Jf,
    ENOENT: Qf,
    AVERROR_EOF: eg,
    LibAV: tg,
  } = O,
  Vt = O;
var Tt = class {
  constructor() {
    this.filename_writable_map = new Map();
  }
  async open(r) {
    let i = await (
        await navigator.storage.getDirectory()
      ).getFileHandle(r, { create: !0 }),
      t = await i.createSyncAccessHandle();
    this.filename_writable_map.set(r, { writable: t, handle: i, size: 0 });
  }
  async onwrite(r, n, i) {
    let t = this.filename_writable_map.get(r);
    if (!t) {
      console.error("Onwrite called for unknown file");
      return;
    }
    (await t.writable.write(i, { at: n }), (t.size += i.length));
  }
  async close(r) {
    let n = this.filename_writable_map.get(r);
    if (!n) return (console.error("Finish called for unknown file"), 0);
    await n.writable.close();
    let i = this.filename_writable_map.get(r)?.size;
    return (this.filename_writable_map.delete(r), i || 0);
  }
  async remove(r) {
    await (await navigator.storage.getDirectory()).removeEntry(r);
  }
};
function ge(e) {
  var r = String(e);
  if (r === "[object Object]")
    try {
      r = JSON.stringify(e);
    } catch {}
  return r;
}
var bu = (function () {
    function e() {}
    return (
      (e.prototype.isSome = function () {
        return !1;
      }),
      (e.prototype.isNone = function () {
        return !0;
      }),
      (e.prototype[Symbol.iterator] = function () {
        return {
          next: function () {
            return { done: !0, value: void 0 };
          },
        };
      }),
      (e.prototype.unwrapOr = function (r) {
        return r;
      }),
      (e.prototype.expect = function (r) {
        throw new Error("".concat(r));
      }),
      (e.prototype.unwrap = function () {
        throw new Error("Tried to unwrap None");
      }),
      (e.prototype.map = function (r) {
        return this;
      }),
      (e.prototype.mapOr = function (r, n) {
        return r;
      }),
      (e.prototype.mapOrElse = function (r, n) {
        return r();
      }),
      (e.prototype.or = function (r) {
        return r;
      }),
      (e.prototype.orElse = function (r) {
        return r();
      }),
      (e.prototype.andThen = function (r) {
        return this;
      }),
      (e.prototype.toResult = function (r) {
        return H(r);
      }),
      (e.prototype.toString = function () {
        return "None";
      }),
      (e.prototype.toAsyncOption = function () {
        return new Ze(Y);
      }),
      e
    );
  })(),
  Y = new bu();
Object.freeze(Y);
var wu = (function () {
    function e(r) {
      if (!(this instanceof e)) return new e(r);
      this.value = r;
    }
    return (
      (e.prototype.isSome = function () {
        return !0;
      }),
      (e.prototype.isNone = function () {
        return !1;
      }),
      (e.prototype[Symbol.iterator] = function () {
        var r = Object(this.value);
        return Symbol.iterator in r
          ? r[Symbol.iterator]()
          : {
              next: function () {
                return { done: !0, value: void 0 };
              },
            };
      }),
      (e.prototype.unwrapOr = function (r) {
        return this.value;
      }),
      (e.prototype.expect = function (r) {
        return this.value;
      }),
      (e.prototype.unwrap = function () {
        return this.value;
      }),
      (e.prototype.map = function (r) {
        return J(r(this.value));
      }),
      (e.prototype.mapOr = function (r, n) {
        return n(this.value);
      }),
      (e.prototype.mapOrElse = function (r, n) {
        return n(this.value);
      }),
      (e.prototype.or = function (r) {
        return this;
      }),
      (e.prototype.orElse = function (r) {
        return this;
      }),
      (e.prototype.andThen = function (r) {
        return r(this.value);
      }),
      (e.prototype.toResult = function (r) {
        return U(this.value);
      }),
      (e.prototype.toAsyncOption = function () {
        return new Ze(this);
      }),
      (e.prototype.safeUnwrap = function () {
        return this.value;
      }),
      (e.prototype.toString = function () {
        return "Some(".concat(ge(this.value), ")");
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })(),
  J = wu,
  Ot;
(function (e) {
  function r() {
    for (var t = [], o = 0; o < arguments.length; o++) t[o] = arguments[o];
    for (var a = [], s = 0, u = t; s < u.length; s++) {
      var l = u[s];
      if (l.isSome()) a.push(l.value);
      else return l;
    }
    return J(a);
  }
  e.all = r;
  function n() {
    for (var t = [], o = 0; o < arguments.length; o++) t[o] = arguments[o];
    for (var a = 0, s = t; a < s.length; a++) {
      var u = s[a];
      if (u.isSome()) return u;
    }
    return Y;
  }
  e.any = n;
  function i(t) {
    return t instanceof J || t === Y;
  }
  e.isOption = i;
})(Ot || (Ot = {}));
var Ee = function (e, r, n) {
    if (n || arguments.length === 2)
      for (var i = 0, t = r.length, o; i < t; i++)
        (o || !(i in r)) &&
          (o || (o = Array.prototype.slice.call(r, 0, i)), (o[i] = r[i]));
    return e.concat(o || Array.prototype.slice.call(r));
  },
  xu = (function () {
    function e(r) {
      if (!(this instanceof e)) return new e(r);
      this.error = r;
      var n = new Error().stack
        .split(
          `
`,
        )
        .slice(2);
      (n && n.length > 0 && n[0].includes("ErrImpl") && n.shift(),
        (this._stack = n.join(`
`)));
    }
    return (
      (e.prototype.isOk = function () {
        return !1;
      }),
      (e.prototype.isErr = function () {
        return !0;
      }),
      (e.prototype[Symbol.iterator] = function () {
        return {
          next: function () {
            return { done: !0, value: void 0 };
          },
        };
      }),
      (e.prototype.else = function (r) {
        return r;
      }),
      (e.prototype.unwrapOr = function (r) {
        return r;
      }),
      (e.prototype.expect = function (r) {
        throw new Error(
          ""
            .concat(r, " - Error: ")
            .concat(
              ge(this.error),
              `
`,
            )
            .concat(this._stack),
          { cause: this.error },
        );
      }),
      (e.prototype.expectErr = function (r) {
        return this.error;
      }),
      (e.prototype.unwrap = function () {
        throw new Error(
          "Tried to unwrap Error: "
            .concat(
              ge(this.error),
              `
`,
            )
            .concat(this._stack),
          { cause: this.error },
        );
      }),
      (e.prototype.unwrapErr = function () {
        return this.error;
      }),
      (e.prototype.map = function (r) {
        return this;
      }),
      (e.prototype.andThen = function (r) {
        return this;
      }),
      (e.prototype.mapErr = function (r) {
        return new H(r(this.error));
      }),
      (e.prototype.mapOr = function (r, n) {
        return r;
      }),
      (e.prototype.mapOrElse = function (r, n) {
        return r(this.error);
      }),
      (e.prototype.or = function (r) {
        return r;
      }),
      (e.prototype.orElse = function (r) {
        return r(this.error);
      }),
      (e.prototype.toOption = function () {
        return Y;
      }),
      (e.prototype.toString = function () {
        return "Err(".concat(ge(this.error), ")");
      }),
      Object.defineProperty(e.prototype, "stack", {
        get: function () {
          return ""
            .concat(
              this,
              `
`,
            )
            .concat(this._stack);
        },
        enumerable: !1,
        configurable: !0,
      }),
      (e.prototype.toAsyncResult = function () {
        return new Be(this);
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })();
var H = xu,
  Au = (function () {
    function e(r) {
      if (!(this instanceof e)) return new e(r);
      this.value = r;
    }
    return (
      (e.prototype.isOk = function () {
        return !0;
      }),
      (e.prototype.isErr = function () {
        return !1;
      }),
      (e.prototype[Symbol.iterator] = function () {
        var r = Object(this.value);
        return Symbol.iterator in r
          ? r[Symbol.iterator]()
          : {
              next: function () {
                return { done: !0, value: void 0 };
              },
            };
      }),
      (e.prototype.else = function (r) {
        return this.value;
      }),
      (e.prototype.unwrapOr = function (r) {
        return this.value;
      }),
      (e.prototype.expect = function (r) {
        return this.value;
      }),
      (e.prototype.expectErr = function (r) {
        throw new Error(r);
      }),
      (e.prototype.unwrap = function () {
        return this.value;
      }),
      (e.prototype.unwrapErr = function () {
        throw new Error("Tried to unwrap Ok: ".concat(ge(this.value)), {
          cause: this.value,
        });
      }),
      (e.prototype.map = function (r) {
        return new U(r(this.value));
      }),
      (e.prototype.andThen = function (r) {
        return r(this.value);
      }),
      (e.prototype.mapErr = function (r) {
        return this;
      }),
      (e.prototype.mapOr = function (r, n) {
        return n(this.value);
      }),
      (e.prototype.mapOrElse = function (r, n) {
        return n(this.value);
      }),
      (e.prototype.or = function (r) {
        return this;
      }),
      (e.prototype.orElse = function (r) {
        return this;
      }),
      (e.prototype.toOption = function () {
        return J(this.value);
      }),
      (e.prototype.safeUnwrap = function () {
        return this.value;
      }),
      (e.prototype.toString = function () {
        return "Ok(".concat(ge(this.value), ")");
      }),
      (e.prototype.toAsyncResult = function () {
        return new Be(this);
      }),
      (e.EMPTY = new e(void 0)),
      e
    );
  })();
var U = Au,
  jt;
(function (e) {
  function r(s) {
    for (var u = [], l = 1; l < arguments.length; l++) u[l - 1] = arguments[l];
    for (
      var m = s === void 0 ? [] : Array.isArray(s) ? s : Ee([s], u, !0),
        p = [],
        d = 0,
        _ = m;
      d < _.length;
      d++
    ) {
      var h = _[d];
      if (h.isOk()) p.push(h.value);
      else return h;
    }
    return new U(p);
  }
  e.all = r;
  function n(s) {
    for (var u = [], l = 1; l < arguments.length; l++) u[l - 1] = arguments[l];
    for (
      var m = s === void 0 ? [] : Array.isArray(s) ? s : Ee([s], u, !0),
        p = [],
        d = 0,
        _ = m;
      d < _.length;
      d++
    ) {
      var h = _[d];
      if (h.isOk()) return h;
      p.push(h.error);
    }
    return new H(p);
  }
  e.any = n;
  function i(s) {
    try {
      return new U(s());
    } catch (u) {
      return new H(u);
    }
  }
  e.wrap = i;
  function t(s) {
    try {
      return s()
        .then(function (u) {
          return new U(u);
        })
        .catch(function (u) {
          return new H(u);
        });
    } catch (u) {
      return Promise.resolve(new H(u));
    }
  }
  e.wrapAsync = t;
  function o(s) {
    return s.reduce(
      function (u, l) {
        var m = u[0],
          p = u[1];
        return l.isOk()
          ? [Ee(Ee([], m, !0), [l.value], !1), p]
          : [m, Ee(Ee([], p, !0), [l.error], !1)];
      },
      [[], []],
    );
  }
  e.partition = o;
  function a(s) {
    return s instanceof H || s instanceof U;
  }
  e.isResult = a;
})(jt || (jt = {}));
var Nt = function (e, r, n, i) {
    function t(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function s(m) {
        try {
          l(i.next(m));
        } catch (p) {
          a(p);
        }
      }
      function u(m) {
        try {
          l(i.throw(m));
        } catch (p) {
          a(p);
        }
      }
      function l(m) {
        m.done ? o(m.value) : t(m.value).then(s, u);
      }
      l((i = i.apply(e, r || [])).next());
    });
  },
  Mt = function (e, r) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      i,
      t,
      o,
      a;
    return (
      (a = { next: s(0), throw: s(1), return: s(2) }),
      typeof Symbol == "function" &&
        (a[Symbol.iterator] = function () {
          return this;
        }),
      a
    );
    function s(l) {
      return function (m) {
        return u([l, m]);
      };
    }
    function u(l) {
      if (i) throw new TypeError("Generator is already executing.");
      for (; a && ((a = 0), l[0] && (n = 0)), n; )
        try {
          if (
            ((i = 1),
            t &&
              (o =
                l[0] & 2
                  ? t.return
                  : l[0]
                    ? t.throw || ((o = t.return) && o.call(t), 0)
                    : t.next) &&
              !(o = o.call(t, l[1])).done)
          )
            return o;
          switch (((t = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
            case 0:
            case 1:
              o = l;
              break;
            case 4:
              return (n.label++, { value: l[1], done: !1 });
            case 5:
              (n.label++, (t = l[1]), (l = [0]));
              continue;
            case 7:
              ((l = n.ops.pop()), n.trys.pop());
              continue;
            default:
              if (
                ((o = n.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (l[0] === 6 || l[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
                n.label = l[1];
                break;
              }
              if (l[0] === 6 && n.label < o[1]) {
                ((n.label = o[1]), (o = l));
                break;
              }
              if (o && n.label < o[2]) {
                ((n.label = o[2]), n.ops.push(l));
                break;
              }
              (o[2] && n.ops.pop(), n.trys.pop());
              continue;
          }
          l = r.call(e, n);
        } catch (m) {
          ((l = [6, m]), (t = 0));
        } finally {
          i = o = 0;
        }
      if (l[0] & 5) throw l[1];
      return { value: l[0] ? l[1] : void 0, done: !0 };
    }
  },
  Be = (function () {
    function e(r) {
      this.promise = Promise.resolve(r);
    }
    return (
      (e.prototype.andThen = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Nt(n, void 0, void 0, function () {
            var t;
            return Mt(this, function (o) {
              return i.isErr()
                ? [2, i]
                : ((t = r(i.value)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.map = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Nt(n, void 0, void 0, function () {
            var t;
            return Mt(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isErr() ? [2, i] : ((t = U), [4, r(i.value)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.mapErr = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Nt(n, void 0, void 0, function () {
            var t;
            return Mt(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isOk() ? [2, i] : ((t = H), [4, r(i.error)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.or = function (r) {
        return this.orElse(function () {
          return r;
        });
      }),
      (e.prototype.orElse = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Nt(n, void 0, void 0, function () {
            var t;
            return Mt(this, function (o) {
              return i.isOk()
                ? [2, i]
                : ((t = r(i.error)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.toOption = function () {
        return new Ze(
          this.promise.then(function (r) {
            return r.toOption();
          }),
        );
      }),
      (e.prototype.thenInternal = function (r) {
        return new e(this.promise.then(r));
      }),
      e
    );
  })();
var Hr = function (e, r, n, i) {
    function t(o) {
      return o instanceof n
        ? o
        : new n(function (a) {
            a(o);
          });
    }
    return new (n || (n = Promise))(function (o, a) {
      function s(m) {
        try {
          l(i.next(m));
        } catch (p) {
          a(p);
        }
      }
      function u(m) {
        try {
          l(i.throw(m));
        } catch (p) {
          a(p);
        }
      }
      function l(m) {
        m.done ? o(m.value) : t(m.value).then(s, u);
      }
      l((i = i.apply(e, r || [])).next());
    });
  },
  Wr = function (e, r) {
    var n = {
        label: 0,
        sent: function () {
          if (o[0] & 1) throw o[1];
          return o[1];
        },
        trys: [],
        ops: [],
      },
      i,
      t,
      o,
      a;
    return (
      (a = { next: s(0), throw: s(1), return: s(2) }),
      typeof Symbol == "function" &&
        (a[Symbol.iterator] = function () {
          return this;
        }),
      a
    );
    function s(l) {
      return function (m) {
        return u([l, m]);
      };
    }
    function u(l) {
      if (i) throw new TypeError("Generator is already executing.");
      for (; a && ((a = 0), l[0] && (n = 0)), n; )
        try {
          if (
            ((i = 1),
            t &&
              (o =
                l[0] & 2
                  ? t.return
                  : l[0]
                    ? t.throw || ((o = t.return) && o.call(t), 0)
                    : t.next) &&
              !(o = o.call(t, l[1])).done)
          )
            return o;
          switch (((t = 0), o && (l = [l[0] & 2, o.value]), l[0])) {
            case 0:
            case 1:
              o = l;
              break;
            case 4:
              return (n.label++, { value: l[1], done: !1 });
            case 5:
              (n.label++, (t = l[1]), (l = [0]));
              continue;
            case 7:
              ((l = n.ops.pop()), n.trys.pop());
              continue;
            default:
              if (
                ((o = n.trys),
                !(o = o.length > 0 && o[o.length - 1]) &&
                  (l[0] === 6 || l[0] === 2))
              ) {
                n = 0;
                continue;
              }
              if (l[0] === 3 && (!o || (l[1] > o[0] && l[1] < o[3]))) {
                n.label = l[1];
                break;
              }
              if (l[0] === 6 && n.label < o[1]) {
                ((n.label = o[1]), (o = l));
                break;
              }
              if (o && n.label < o[2]) {
                ((n.label = o[2]), n.ops.push(l));
                break;
              }
              (o[2] && n.ops.pop(), n.trys.pop());
              continue;
          }
          l = r.call(e, n);
        } catch (m) {
          ((l = [6, m]), (t = 0));
        } finally {
          i = o = 0;
        }
      if (l[0] & 5) throw l[1];
      return { value: l[0] ? l[1] : void 0, done: !0 };
    }
  },
  Ze = (function () {
    function e(r) {
      this.promise = Promise.resolve(r);
    }
    return (
      (e.prototype.andThen = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Hr(n, void 0, void 0, function () {
            var t;
            return Wr(this, function (o) {
              return i.isNone()
                ? [2, i]
                : ((t = r(i.value)), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.map = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Hr(n, void 0, void 0, function () {
            var t;
            return Wr(this, function (o) {
              switch (o.label) {
                case 0:
                  return i.isNone() ? [2, i] : ((t = J), [4, r(i.value)]);
                case 1:
                  return [2, t.apply(void 0, [o.sent()])];
              }
            });
          });
        });
      }),
      (e.prototype.or = function (r) {
        return this.orElse(function () {
          return r;
        });
      }),
      (e.prototype.orElse = function (r) {
        var n = this;
        return this.thenInternal(function (i) {
          return Hr(n, void 0, void 0, function () {
            var t;
            return Wr(this, function (o) {
              return i.isSome()
                ? [2, i]
                : ((t = r()), [2, t instanceof e ? t.promise : t]);
            });
          });
        });
      }),
      (e.prototype.toResult = function (r) {
        return new Be(
          this.promise.then(function (n) {
            return n.toResult(r);
          }),
        );
      }),
      (e.prototype.thenInternal = function (r) {
        return new e(this.promise.then(r));
      }),
      e
    );
  })();
var Xa = ["mp4", "webm", "mkv"],
  Ja = ["mp3", "m4a", "ogg"],
  Qa = [...Xa, ...Ja];
function Yr(e) {
  return Xa.includes(e);
}
function Kr(e) {
  return Ja.includes(e);
}
function es(e, r) {
  return Yr(e) ? qe(e, r) : ku(e);
}
function ku(e) {
  if (e == "mp3") return "mp3";
  if (e == "m4a") return "mp3";
  if (e == "ogg") return "mp3";
  throw new Error("Unreachable");
}
function qe(e, r) {
  if (e == "mp4") return r;
  if (e == "webm") return "mkv";
  if (e == "mkv") return "mkv";
  throw new Error("Unreachable");
}
function ts(e, r) {
  if (e.prefered_entry.isSome() && e.playlist[e.prefered_entry.value])
    return e.prefered_entry.value;
  if (r)
    for (let n of Qa) {
      let i = 0;
      for (let { quality: t, demuxer: o } of e.playlist) {
        if (n == o && t.size.isSome() && t.size.value.height == r) return i;
        i++;
      }
    }
  else return 0;
  return 0;
}
var ns = Gr(Ut(), 1),
  Nu = Gr(Ut(), 1);
var Ou = (e, r) => typeof e[r] == "string";
function le(e) {
  try {
    if (Ou(e, "__serializer_tag")) {
      if (e.__serializer_tag === "primitive") return U(e.__serializer_value);
      if (e.__serializer_tag === "regex") {
        let i = new RegExp(e.__serializer_value);
        return U(i);
      } else if (e.__serializer_tag === "array") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = le(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return U(i);
      } else if (e.__serializer_tag === "map") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = le(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return U(new Map(i));
      } else if (e.__serializer_tag === "set") {
        let i = [];
        for (let t of e.__serializer_value) {
          let o = le(t);
          if (o.isErr()) return o;
          i.push(o.unwrap());
        }
        return U(new Set(i));
      } else if (e.__serializer_tag === "result_ok") {
        let i = e.__serializer_value,
          t = le(i);
        return t.isErr() ? t : U(U(t.unwrap()));
      } else if (e.__serializer_tag === "result_err") {
        let i = e.__serializer_value,
          t = le(i);
        return t.isErr() ? t : U(H(t.unwrap()));
      } else if (e.__serializer_tag === "option_some") {
        let i = e.__serializer_value,
          t = le(i);
        return t.isErr() ? t : U(J(t.unwrap()));
      } else if (e.__serializer_tag === "option_none") return U(Y);
    }
    let r = typeof e;
    if (
      r === "string" ||
      r === "number" ||
      r === "boolean" ||
      r === "undefined" ||
      Array.isArray(e) ||
      e == null
    )
      return H("This object was not serialized with Serialize");
    let n = {};
    for (let i of Object.keys(e))
      if (typeof i == "string") {
        let t = le(e[i]);
        if (t.isErr()) return t;
        n[i] = t.unwrap();
      }
    return U(n);
  } catch {
    return H("Failed to inspect object. Not JSON?");
  }
}
var Rt = "";
function en() {
  return { default_: { max_length: 64, template: "%title" }, rules: [] };
}
function he(e) {
  let r = e
    .trim()
    .normalize("NFC")
    .replace(/^\.+/gu, "")
    .replace(/[^\p{L}\p{N}\p{M}\-\s_\.]/gu, "")
    .replace(/-+/gu, "-")
    .replace(/\s+/gu, " ")
    .replace(/^(\s|-)+/gu, "")
    .substring(0, 190)
    .replace(/(\s|-)+$/gu, "");
  return r.length == 0 ? "no-name" : r;
}
function tn(e, r) {
  let {
      template: n,
      selector: i,
      max_length: t,
      replace: o,
      subdir: a,
    } = r.smartnaming_rule,
    s,
    u;
  if (
    ((s = e.title
      .or(r.title)
      .or(e.filename)
      .map((p) => p.trim())
      .unwrapOr(void 0)),
    r.url.isSome())
  ) {
    let p = r.url.value.host.split(".").slice(-2);
    (p.pop(), (u = p[0]));
  }
  let l = n,
    m = (p, d) => {
      d
        ? (l = l.replace(p, d))
        : ((l = l.replace(` ${p}`, "")),
          (l = l.replace(`-${p}`, "")),
          (l = l.replace(`_${p}`, "")),
          (l = l.replace(`${p}`, "")));
    };
  (m("%title", s),
    m("%hostname", u),
    m("%selector", i),
    (l = l || s || u || ""),
    (l = he(l).substring(0, t)));
  for (let p of o) l = l.replaceAll(p.from, p.to);
  return ((l = he(l).substring(0, t)), { basename: l, subdir: a });
}
async function os() {
  let e = en(),
    r = await ns.storage.local.get("smartnaming");
  if (typeof r.smartnaming == "object") {
    let n = le(r.smartnaming);
    if (n.isOk())
      for (let [i, t] of n.value.entries())
        if (i == "*")
          ((e.default_.max_length = t.max_length),
            (e.default_.template = t.template));
        else {
          let o = {
            max_length: t.max_length,
            url: i,
            selector: null,
            template: t.template,
          };
          (t.selector && (o.selector = t.selector), e.rules.push(o));
        }
  }
  return e;
}
function te(e) {
  if (e.__serde_tag == "primitive") return e.__serde_val;
  if (e.__serde_tag == "object") {
    let r = {};
    for (let [n, i] of Object.entries(e.__serde_val)) {
      let t = i;
      r[n] = te(t);
    }
    return r;
  } else {
    if (e.__serde_tag == "map")
      return new Map(e.__serde_val.map(([r, n]) => [te(r), te(n)]));
    if (e.__serde_tag == "set") return new Set(e.__serde_val.map(te));
    if (e.__serde_tag == "url") return new URL(e.__serde_val);
    if (e.__serde_tag == "array") return e.__serde_val.map(te);
    if (e.__serde_tag == "headers") return new Headers(e.__serde_val);
    if (e.__serde_tag == "regex")
      return new RegExp(e.__serde_val[0], e.__serde_val[1]);
    if (e.__serde_tag == "some") return J(te(e.__serde_val));
    if (e.__serde_tag == "none") return Y;
    if (e.__serde_tag == "ok") return U(te(e.__serde_val));
    if (e.__serde_tag == "err") return H(te(e.__serde_val));
    throw new Error("Unreachable");
  }
}
function oe(e) {
  if (typeof e == "string") return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e == "number") return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e == "boolean")
    return { __serde_tag: "primitive", __serde_val: e };
  if (typeof e > "u") return { __serde_tag: "primitive", __serde_val: e };
  if (e == null) return { __serde_tag: "primitive", __serde_val: e };
  if (Array.isArray(e))
    return { __serde_tag: "array", __serde_val: e.map((r) => oe(r)) };
  if (e instanceof URL) return { __serde_tag: "url", __serde_val: e.href };
  if (e instanceof Headers) {
    let r = [];
    return (
      e.forEach((n, i) => {
        r.push([i, n]);
      }),
      { __serde_tag: "headers", __serde_val: r }
    );
  } else {
    if (e instanceof Set)
      return { __serde_tag: "set", __serde_val: [...e.values()].map(oe) };
    if (e instanceof Map)
      return {
        __serde_tag: "map",
        __serde_val: [...e.entries()].map(([r, n]) => [oe(r), oe(n)]),
      };
    if (e instanceof RegExp)
      return { __serde_tag: "regex", __serde_val: [e.source, e.flags] };
    if (Ot.isOption(e))
      return e.isSome()
        ? { __serde_tag: "some", __serde_val: oe(e.value) }
        : { __serde_tag: "none" };
    if (jt.isResult(e))
      return e.isOk()
        ? { __serde_tag: "ok", __serde_val: oe(e.value) }
        : { __serde_tag: "err", __serde_val: oe(e.error) };
    if (typeof e == "object") {
      let r = {};
      for (let [n, i] of Object.entries(e)) r[n] = oe(i);
      return { __serde_tag: "object", __serde_val: r };
    } else throw new Error("Unreachable");
  }
}
function ve(e) {
  return te(oe(e));
}
function Mu(e, r, n, i, t, o, a, s) {
  t = he(t);
  let u = `download_${crypto.randomUUID()}`,
    l = ve(e.sent_headers),
    m = e.playlist[a].index;
  return r || Kr(e.playlist[a].demuxer)
    ? {
        download_id: u,
        headers: l,
        good_basename: t,
        subdir: o,
        save_as: n,
        will_use_jsfetch: !0,
        muxer: "mp3",
        strategy: "mpd_audio_only",
        url: e.master_url,
        entry: m,
        duration: e.duration,
        extension: "mp3",
        is_youtube: e.is_youtube,
        throttle: s,
        cache: e.cache,
      }
    : {
        download_id: u,
        headers: l,
        good_basename: t,
        subdir: o,
        save_as: n,
        will_use_jsfetch: !0,
        muxer: i,
        strategy: "mpd_audio_video_one_source",
        url: e.master_url,
        entry: m,
        duration: e.duration,
        extension: i,
        is_youtube: e.is_youtube,
        throttle: s,
        cache: e.cache,
      };
}
function Uu(e, r, n, i, t, o, a, s) {
  t = he(t);
  let u = `download_${crypto.randomUUID()}`,
    l = e.playlist[a],
    m = ve(e.sent_headers);
  if (l.av.video == !1)
    return {
      download_id: u,
      headers: m,
      good_basename: t,
      subdir: o,
      save_as: n,
      will_use_jsfetch: !1,
      strategy: "youtube_audio_only",
      muxer: "mp3",
      url: l.av.audio.url,
      content_length: l.av.audio.content_length,
      extension: "mp3",
      is_youtube: e.is_youtube,
      throttle: s,
      cache: e.cache,
    };
  if (r)
    return l.av.audio
      ? {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "youtube_audio_only",
          muxer: "mp3",
          url: l.av.audio.url,
          content_length: l.av.audio.content_length,
          extension: "mp3",
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        }
      : {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "youtube_audio_only",
          muxer: "mp3",
          url: l.av.video.url,
          content_length: l.av.video.content_length,
          extension: "mp3",
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        };
  {
    let p = l.demuxer,
      d = qe(p, i);
    return l.av.audio
      ? {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          muxer: d,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "youtube_audio_video_two_sources",
          url: l.av.video.url,
          content_length: l.av.video.content_length,
          url_audio: l.av.audio.url,
          audio_content_length: l.av.audio.content_length,
          extension: d,
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        }
      : {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          muxer: d,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "youtube_audio_video_one_source",
          url: l.av.video.url,
          content_length: l.av.video.content_length,
          extension: d,
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        };
  }
}
function Ru(e, r, n, i, t, o, a, s) {
  t = he(t);
  let u = `download_${crypto.randomUUID()}`,
    l = e.playlist[a],
    m = ve(e.sent_headers),
    p = e.duration;
  if (l.av.video == !1)
    return {
      download_id: u,
      headers: m,
      good_basename: t,
      subdir: o,
      duration: p,
      save_as: n,
      will_use_jsfetch: !1,
      strategy: "m3u8_audio_only",
      muxer: "mp3",
      url: l.av.audio,
      extension: "mp3",
      is_youtube: e.is_youtube,
      throttle: s,
      cache: e.cache,
    };
  if (r)
    return l.av.audio
      ? {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          duration: p,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "m3u8_audio_only",
          muxer: "mp3",
          url: l.av.audio,
          extension: "mp3",
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        }
      : {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          duration: p,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "m3u8_audio_only",
          muxer: "mp3",
          url: l.av.video,
          extension: "mp3",
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        };
  {
    let d = l.demuxer,
      _ = qe(d, i);
    return l.av.audio
      ? {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          muxer: _,
          duration: p,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "m3u8_audio_video_two_sources",
          url: l.av.video,
          url_audio: l.av.audio,
          extension: _,
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        }
      : {
          download_id: u,
          headers: m,
          good_basename: t,
          subdir: o,
          muxer: _,
          duration: p,
          save_as: n,
          will_use_jsfetch: !1,
          strategy: "m3u8_audio_video_one_source",
          url: l.av.video,
          extension: _,
          is_youtube: e.is_youtube,
          throttle: s,
          cache: e.cache,
        };
  }
}
function Cu(e, r, n, i, t, o, a) {
  t = he(t);
  let s = `download_${crypto.randomUUID()}`,
    u = ve(e.sent_headers),
    l = e.url,
    m = e.duration;
  if (r || Kr(e.demuxer))
    return {
      save_as: n,
      subdir: o,
      duration: m,
      will_use_jsfetch: !1,
      download_id: s,
      headers: u,
      strategy: "m3u8_audio_only",
      muxer: "mp3",
      url: l,
      good_basename: t,
      extension: "mp3",
      is_youtube: e.is_youtube,
      throttle: a,
      cache: e.cache,
    };
  {
    let p = qe(e.demuxer, i);
    return {
      download_id: s,
      headers: u,
      subdir: o,
      duration: m,
      will_use_jsfetch: !1,
      save_as: n,
      strategy: "m3u8_audio_video_one_source",
      muxer: p,
      url: l,
      good_basename: t,
      extension: p,
      is_youtube: e.is_youtube,
      throttle: a,
      cache: e.cache,
    };
  }
}
function Lu(e, r, n, i, t, o, a) {
  t = he(t);
  let s = `download_${crypto.randomUUID()}`,
    u = e.extension == "flv" && e.size.isNone(),
    l =
      (e.libav_demuxer.isSome() &&
        Yr(e.libav_demuxer.value) &&
        e.supports_byte_ranges) ||
      u;
  if (r)
    return {
      save_as: n,
      download_id: s,
      subdir: o,
      will_use_jsfetch: !0,
      headers: ve(e.sent_headers),
      strategy: "http_strip_audio_jsfetch",
      url: e.url,
      good_basename: t,
      muxer: "mp3",
      extension: "mp3",
      is_youtube: e.is_youtube,
      size: e.size,
      throttle: a,
      cache: e.cache,
    };
  if (l) {
    let m,
      p = "";
    return (
      e.libav_demuxer.isSome()
        ? ((m = es(e.libav_demuxer.value, i)), (p = m))
        : ((m = i), (p = i)),
      {
        save_as: n,
        download_id: s,
        subdir: o,
        will_use_jsfetch: !0,
        headers: ve(e.sent_headers),
        strategy: "http_audio_video_one_source_jsfetch",
        url: e.url,
        good_basename: t,
        muxer: m,
        extension: p,
        size: e.size,
        is_youtube: e.is_youtube,
        throttle: a,
        cache: e.cache,
      }
    );
  } else
    return {
      save_as: n,
      download_id: s,
      subdir: o,
      will_use_jsfetch: !1,
      headers: ve(e.sent_headers),
      strategy: "http_audio_video_one_source",
      url: e.url,
      good_basename: t,
      size: e.size,
      extension: e.extension,
      is_youtube: e.is_youtube,
      throttle: a,
      cache: e.cache,
    };
}
function rn(e, r, n, i, t, o, a, s) {
  if (e.type == "http") return Lu(e, r, n, i, t, o, s);
  if (e.type == "m3u8") return Cu(e, r, n, i, t, o, s);
  if (e.type == "m3u8_playlist") return Ru(e, r, n, i, t, o, a, s);
  if (e.type == "youtube_format") {
    if (typeof a == "number") return Uu(e, r, n, i, t, o, a, s);
    throw "Missing playlist_entry";
  } else if (e.type == "mpd_playlist") {
    if (typeof a == "number") return Mu(e, r, n, i, t, o, a, s);
    throw "Missing playlist_entry";
  } else throw new Error("Unreachable");
}
var He = "google";
var $h = He != "mozilla",
  nn = He == "mozilla";
var zh = atob(
  "LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFOURtQkJNNitRZ1BDRlhJK2dBTFMreXkvdytBaQplMjdMbXRTWmExWjFWMlV1YWt6UmxzTGgrOFZMdE9KekdwVlcyenQ0bUpSMzVFWFRlYUhOQ0g0bEFBPT0KLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tCg==",
);
var ie = "https://v10.downloadhelper.net:443",
  Sh = `${ie}/v2/entitlements/validate`,
  Ih = `${ie}/v2/entitlements/activate`,
  Ph = `${ie}/v2/entitlements/migrate`,
  Dh = `${ie}/v2/reports`,
  Eh = `${ie}/issue`,
  Vh = `${ie}/premium`,
  Th = `${ie}/manage-subscription`,
  Oh = `${ie}/welcome/${He}`,
  jh = `${ie}/changelog/${He}`,
  Nh = `${ie}/goodbye/${He}`;
var Et = Gr(Ut(), 1);
var v = {};
xe(v, {
  $brand: () => Ct,
  $input: () => yi,
  $output: () => vi,
  NEVER: () => Sd,
  ZodAny: () => bl,
  ZodArray: () => Al,
  ZodBase64: () => Da,
  ZodBase64URL: () => Ea,
  ZodBigInt: () => Dt,
  ZodBigIntFormat: () => Oa,
  ZodBoolean: () => Pt,
  ZodCIDRv4: () => Ia,
  ZodCIDRv6: () => Pa,
  ZodCUID: () => wa,
  ZodCUID2: () => xa,
  ZodCatch: () => Zl,
  ZodCustom: () => Lr,
  ZodDate: () => Ur,
  ZodDefault: () => Ml,
  ZodDiscriminatedUnion: () => kl,
  ZodE164: () => Va,
  ZodEmail: () => ha,
  ZodEmoji: () => ya,
  ZodEnum: () => St,
  ZodError: () => x_,
  ZodFile: () => Ol,
  ZodGUID: () => Er,
  ZodIPv4: () => za,
  ZodIPv6: () => Sa,
  ZodISODate: () => Sr,
  ZodISODateTime: () => zr,
  ZodISODuration: () => Pr,
  ZodISOTime: () => Ir,
  ZodIntersection: () => $l,
  ZodIssueCode: () => $d,
  ZodJWT: () => Ta,
  ZodKSUID: () => $a,
  ZodLazy: () => Yl,
  ZodLiteral: () => Vl,
  ZodMap: () => Pl,
  ZodNaN: () => ql,
  ZodNanoID: () => ba,
  ZodNever: () => wl,
  ZodNonOptional: () => La,
  ZodNull: () => vl,
  ZodNullable: () => Nl,
  ZodNumber: () => It,
  ZodNumberFormat: () => Le,
  ZodObject: () => Rr,
  ZodOptional: () => Ca,
  ZodPipe: () => Fa,
  ZodPrefault: () => Rl,
  ZodPromise: () => Xl,
  ZodReadonly: () => Gl,
  ZodRealError: () => Ce,
  ZodRecord: () => Ua,
  ZodSet: () => Dl,
  ZodString: () => Nr,
  ZodStringFormat: () => R,
  ZodSuccess: () => Fl,
  ZodSymbol: () => gl,
  ZodTemplateLiteral: () => Wl,
  ZodTransform: () => jl,
  ZodTuple: () => Sl,
  ZodType: () => T,
  ZodULID: () => Aa,
  ZodURL: () => va,
  ZodUUID: () => pe,
  ZodUndefined: () => hl,
  ZodUnion: () => Ma,
  ZodUnknown: () => ja,
  ZodVoid: () => xl,
  ZodXID: () => ka,
  _ZodString: () => ga,
  _default: () => Ul,
  any: () => td,
  array: () => Na,
  base64: () => F_,
  base64url: () => Z_,
  bigint: () => K_,
  boolean: () => fl,
  catch: () => Bl,
  check: () => Jl,
  cidrv4: () => C_,
  cidrv6: () => L_,
  clone: () => Q,
  coerce: () => Za,
  config: () => F,
  core: () => me,
  cuid: () => T_,
  cuid2: () => O_,
  custom: () => bd,
  date: () => nd,
  discriminatedUnion: () => ld,
  e164: () => B_,
  email: () => k_,
  emoji: () => E_,
  endsWith: () => yt,
  enum: () => El,
  file: () => pd,
  flattenError: () => ot,
  float32: () => G_,
  float64: () => H_,
  formatError: () => it,
  function: () => oa,
  getErrorMap: () => Pd,
  globalRegistry: () => se,
  gt: () => _e,
  gte: () => X,
  guid: () => $_,
  includes: () => ht,
  instanceof: () => wd,
  int: () => fa,
  int32: () => W_,
  int64: () => X_,
  intersection: () => zl,
  ipv4: () => U_,
  ipv6: () => R_,
  iso: () => Dr,
  json: () => Ad,
  jwt: () => q_,
  keyof: () => od,
  ksuid: () => M_,
  lazy: () => Kl,
  length: () => Re,
  literal: () => Tl,
  locales: () => _t,
  looseObject: () => sd,
  lowercase: () => ft,
  lt: () => ce,
  lte: () => re,
  map: () => _d,
  maxLength: () => Ue,
  maxSize: () => Me,
  mime: () => bt,
  minLength: () => we,
  minSize: () => Pe,
  multipleOf: () => Ie,
  nan: () => hd,
  nanoid: () => V_,
  nativeEnum: () => md,
  negative: () => Yi,
  never: () => Mr,
  nonnegative: () => Xi,
  nonoptional: () => Ll,
  nonpositive: () => Ki,
  normalize: () => wt,
  null: () => yl,
  nullable: () => Or,
  nullish: () => fd,
  number: () => pl,
  object: () => id,
  optional: () => Tr,
  overwrite: () => de,
  parse: () => ca,
  parseAsync: () => _a,
  partialRecord: () => cd,
  pipe: () => jr,
  positive: () => Wi,
  prefault: () => Cl,
  preprocess: () => kd,
  prettifyError: () => hn,
  promise: () => yd,
  property: () => Ji,
  readonly: () => Hl,
  record: () => Il,
  refine: () => Ql,
  regex: () => pt,
  regexes: () => ze,
  registry: () => nr,
  safeParse: () => da,
  safeParseAsync: () => ma,
  set: () => dd,
  setErrorMap: () => Id,
  size: () => mt,
  startsWith: () => vt,
  strictObject: () => ad,
  string: () => pa,
  stringbool: () => xd,
  success: () => gd,
  superRefine: () => eu,
  symbol: () => Q_,
  templateLiteral: () => vd,
  toJSONSchema: () => ia,
  toLowerCase: () => At,
  toUpperCase: () => kt,
  transform: () => Ra,
  treeifyError: () => gn,
  trim: () => xt,
  tuple: () => ud,
  uint32: () => Y_,
  uint64: () => J_,
  ulid: () => j_,
  undefined: () => ed,
  union: () => Cr,
  unknown: () => Vr,
  uppercase: () => gt,
  url: () => D_,
  uuid: () => z_,
  uuidv4: () => S_,
  uuidv6: () => I_,
  uuidv7: () => P_,
  void: () => rd,
  xid: () => N_,
});
var me = {};
xe(me, {
  $ZodAny: () => qo,
  $ZodArray: () => ut,
  $ZodAsyncError: () => ae,
  $ZodBase64: () => No,
  $ZodBase64URL: () => Mo,
  $ZodBigInt: () => er,
  $ZodBigIntFormat: () => Lo,
  $ZodBoolean: () => lt,
  $ZodCIDRv4: () => To,
  $ZodCIDRv6: () => Oo,
  $ZodCUID: () => xo,
  $ZodCUID2: () => Ao,
  $ZodCatch: () => _i,
  $ZodCheck: () => L,
  $ZodCheckBigIntFormat: () => Xn,
  $ZodCheckEndsWith: () => uo,
  $ZodCheckGreaterThan: () => Kt,
  $ZodCheckIncludes: () => so,
  $ZodCheckLengthEquals: () => no,
  $ZodCheckLessThan: () => Yt,
  $ZodCheckLowerCase: () => io,
  $ZodCheckMaxLength: () => to,
  $ZodCheckMaxSize: () => Jn,
  $ZodCheckMimeType: () => _o,
  $ZodCheckMinLength: () => ro,
  $ZodCheckMinSize: () => Qn,
  $ZodCheckMultipleOf: () => Yn,
  $ZodCheckNumberFormat: () => Kn,
  $ZodCheckOverwrite: () => mo,
  $ZodCheckProperty: () => co,
  $ZodCheckRegex: () => oo,
  $ZodCheckSizeEquals: () => eo,
  $ZodCheckStartsWith: () => lo,
  $ZodCheckStringFormat: () => Oe,
  $ZodCheckUpperCase: () => ao,
  $ZodCustom: () => hi,
  $ZodDate: () => Wo,
  $ZodDefault: () => si,
  $ZodDiscriminatedUnion: () => Ko,
  $ZodE164: () => Uo,
  $ZodEmail: () => vo,
  $ZodEmoji: () => bo,
  $ZodEnum: () => ti,
  $ZodError: () => nt,
  $ZodFile: () => ni,
  $ZodFunction: () => $r,
  $ZodGUID: () => go,
  $ZodIPv4: () => Eo,
  $ZodIPv6: () => Vo,
  $ZodISODate: () => Io,
  $ZodISODateTime: () => So,
  $ZodISODuration: () => Do,
  $ZodISOTime: () => Po,
  $ZodIntersection: () => Xo,
  $ZodJWT: () => Ro,
  $ZodKSUID: () => zo,
  $ZodLazy: () => gi,
  $ZodLiteral: () => ri,
  $ZodMap: () => Qo,
  $ZodNaN: () => di,
  $ZodNanoID: () => wo,
  $ZodNever: () => Go,
  $ZodNonOptional: () => ui,
  $ZodNull: () => Bo,
  $ZodNullable: () => ai,
  $ZodNumber: () => Qt,
  $ZodNumberFormat: () => Co,
  $ZodObject: () => Yo,
  $ZodOptional: () => ii,
  $ZodPipe: () => ct,
  $ZodPrefault: () => li,
  $ZodPromise: () => fi,
  $ZodReadonly: () => mi,
  $ZodRealError: () => Te,
  $ZodRecord: () => Jo,
  $ZodRegistry: () => je,
  $ZodSet: () => ei,
  $ZodString: () => st,
  $ZodStringFormat: () => M,
  $ZodSuccess: () => ci,
  $ZodSymbol: () => Fo,
  $ZodTemplateLiteral: () => pi,
  $ZodTransform: () => oi,
  $ZodTuple: () => Se,
  $ZodType: () => P,
  $ZodULID: () => ko,
  $ZodURL: () => yo,
  $ZodUUID: () => ho,
  $ZodUndefined: () => Zo,
  $ZodUnion: () => tr,
  $ZodUnknown: () => be,
  $ZodVoid: () => Ho,
  $ZodXID: () => $o,
  $brand: () => Ct,
  $constructor: () => c,
  $input: () => yi,
  $output: () => vi,
  Doc: () => at,
  JSONSchema: () => _l,
  JSONSchemaGenerator: () => zt,
  _any: () => Fi,
  _array: () => $t,
  _base64: () => wr,
  _base64url: () => xr,
  _bigint: () => ji,
  _boolean: () => Ti,
  _catch: () => f_,
  _cidrv4: () => yr,
  _cidrv6: () => br,
  _coercedBigint: () => Ni,
  _coercedBoolean: () => Oi,
  _coercedDate: () => Gi,
  _coercedNumber: () => Si,
  _coercedString: () => wi,
  _cuid: () => dr,
  _cuid2: () => mr,
  _custom: () => ta,
  _date: () => qi,
  _default: () => d_,
  _discriminatedUnion: () => t_,
  _e164: () => Ar,
  _email: () => or,
  _emoji: () => cr,
  _endsWith: () => yt,
  _enum: () => a_,
  _file: () => ea,
  _float32: () => Pi,
  _float64: () => Di,
  _gt: () => _e,
  _gte: () => X,
  _guid: () => dt,
  _includes: () => ht,
  _int: () => Ii,
  _int32: () => Ei,
  _int64: () => Mi,
  _intersection: () => r_,
  _ipv4: () => hr,
  _ipv6: () => vr,
  _isoDate: () => Ai,
  _isoDateTime: () => xi,
  _isoDuration: () => $i,
  _isoTime: () => ki,
  _jwt: () => kr,
  _ksuid: () => gr,
  _lazy: () => y_,
  _length: () => Re,
  _literal: () => l_,
  _lowercase: () => ft,
  _lt: () => ce,
  _lte: () => re,
  _map: () => o_,
  _max: () => re,
  _maxLength: () => Ue,
  _maxSize: () => Me,
  _mime: () => bt,
  _min: () => X,
  _minLength: () => we,
  _minSize: () => Pe,
  _multipleOf: () => Ie,
  _nan: () => Hi,
  _nanoid: () => _r,
  _nativeEnum: () => s_,
  _negative: () => Yi,
  _never: () => Zi,
  _nonnegative: () => Xi,
  _nonoptional: () => m_,
  _nonpositive: () => Ki,
  _normalize: () => wt,
  _null: () => Li,
  _nullable: () => __,
  _number: () => zi,
  _optional: () => c_,
  _overwrite: () => de,
  _parse: () => Ft,
  _parseAsync: () => Bt,
  _pipe: () => g_,
  _positive: () => Wi,
  _promise: () => b_,
  _property: () => Ji,
  _readonly: () => h_,
  _record: () => n_,
  _refine: () => ra,
  _regex: () => pt,
  _safeParse: () => Gt,
  _safeParseAsync: () => Ht,
  _set: () => i_,
  _size: () => mt,
  _startsWith: () => vt,
  _string: () => bi,
  _stringbool: () => na,
  _success: () => p_,
  _symbol: () => Ri,
  _templateLiteral: () => v_,
  _toLowerCase: () => At,
  _toUpperCase: () => kt,
  _transform: () => u_,
  _trim: () => xt,
  _tuple: () => Qi,
  _uint32: () => Vi,
  _uint64: () => Ui,
  _ulid: () => pr,
  _undefined: () => Ci,
  _union: () => e_,
  _unknown: () => Ne,
  _uppercase: () => gt,
  _url: () => ur,
  _uuid: () => ir,
  _uuidv4: () => ar,
  _uuidv6: () => sr,
  _uuidv7: () => lr,
  _void: () => Bi,
  _xid: () => fr,
  clone: () => Q,
  config: () => F,
  flattenError: () => ot,
  formatError: () => it,
  function: () => oa,
  globalConfig: () => We,
  globalRegistry: () => se,
  isValidBase64: () => jo,
  isValidBase64URL: () => ks,
  isValidJWT: () => $s,
  locales: () => _t,
  parse: () => Zt,
  parseAsync: () => qt,
  prettifyError: () => hn,
  regexes: () => ze,
  registry: () => nr,
  safeParse: () => vn,
  safeParseAsync: () => yn,
  toDotPath: () => as,
  toJSONSchema: () => ia,
  treeifyError: () => gn,
  util: () => b,
  version: () => po,
});
function c(e, r, n) {
  function i(s, u) {
    var l;
    (Object.defineProperty(s, "_zod", { value: s._zod ?? {}, enumerable: !1 }),
      (l = s._zod).traits ?? (l.traits = new Set()),
      s._zod.traits.add(e),
      r(s, u));
    for (let m in a.prototype)
      m in s || Object.defineProperty(s, m, { value: a.prototype[m].bind(s) });
    ((s._zod.constr = a), (s._zod.def = u));
  }
  let t = n?.Parent ?? Object;
  class o extends t {}
  Object.defineProperty(o, "name", { value: e });
  function a(s) {
    var u;
    let l = n?.Parent ? new o() : this;
    (i(l, s), (u = l._zod).deferred ?? (u.deferred = []));
    for (let m of l._zod.deferred) m();
    return l;
  }
  return (
    Object.defineProperty(a, "init", { value: i }),
    Object.defineProperty(a, Symbol.hasInstance, {
      value: (s) =>
        n?.Parent && s instanceof n.Parent ? !0 : s?._zod?.traits?.has(e),
    }),
    Object.defineProperty(a, "name", { value: e }),
    a
  );
}
var Ct = Symbol("zod_brand"),
  ae = class extends Error {
    constructor() {
      super(
        "Encountered Promise during synchronous parse. Use .parseAsync() instead.",
      );
    }
  },
  We = {};
function F(e) {
  return (e && Object.assign(We, e), We);
}
var b = {};
xe(b, {
  BIGINT_FORMAT_RANGES: () => pn,
  Class: () => an,
  NUMBER_FORMAT_RANGES: () => mn,
  aborted: () => ke,
  allowsEval: () => cn,
  assert: () => Gu,
  assertEqual: () => Fu,
  assertIs: () => Bu,
  assertNever: () => qu,
  assertNotEqual: () => Zu,
  assignProp: () => un,
  cached: () => Xe,
  cleanEnum: () => oc,
  cleanRegex: () => Je,
  clone: () => Q,
  createTransparentProxy: () => Xu,
  defineLazy: () => j,
  esc: () => Ae,
  escapeRegex: () => ue,
  extend: () => ec,
  finalizeIssue: () => ee,
  floatSafeRemainder: () => ln,
  getElementAtPath: () => Hu,
  getEnumValues: () => Ke,
  getLengthableOrigin: () => rt,
  getParsedType: () => Ku,
  getSizableOrigin: () => tt,
  isObject: () => Ve,
  isPlainObject: () => Qe,
  issue: () => fn,
  joinValues: () => f,
  jsonStringifyReplacer: () => sn,
  merge: () => tc,
  normalizeParams: () => y,
  nullish: () => ye,
  numKeys: () => Yu,
  omit: () => Qu,
  optionalKeys: () => dn,
  partial: () => rc,
  pick: () => Ju,
  prefixIssues: () => K,
  primitiveTypes: () => _n,
  promiseAllObject: () => Wu,
  propertyKeyTypes: () => et,
  randomString: () => Lt,
  required: () => nc,
  stringifyPrimitive: () => x,
  unwrapMessage: () => Ye,
});
function Fu(e) {
  return e;
}
function Zu(e) {
  return e;
}
function Bu(e) {}
function qu(e) {
  throw new Error();
}
function Gu(e) {}
function Ke(e) {
  let r = Object.values(e).filter((i) => typeof i == "number");
  return Object.entries(e)
    .filter(([i, t]) => r.indexOf(+i) === -1)
    .map(([i, t]) => t);
}
function f(e, r = "|") {
  return e.map((n) => x(n)).join(r);
}
function sn(e, r) {
  return typeof r == "bigint" ? r.toString() : r;
}
function Xe(e) {
  return {
    get value() {
      {
        let n = e();
        return (Object.defineProperty(this, "value", { value: n }), n);
      }
      throw new Error("cached value already set");
    },
  };
}
function ye(e) {
  return e == null;
}
function Je(e) {
  let r = e.startsWith("^") ? 1 : 0,
    n = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(r, n);
}
function ln(e, r) {
  let n = (e.toString().split(".")[1] || "").length,
    i = (r.toString().split(".")[1] || "").length,
    t = n > i ? n : i,
    o = Number.parseInt(e.toFixed(t).replace(".", "")),
    a = Number.parseInt(r.toFixed(t).replace(".", ""));
  return (o % a) / 10 ** t;
}
function j(e, r, n) {
  Object.defineProperty(e, r, {
    get() {
      {
        let t = n();
        return ((e[r] = t), t);
      }
      throw new Error("cached value already set");
    },
    set(t) {
      Object.defineProperty(e, r, { value: t });
    },
    configurable: !0,
  });
}
function un(e, r, n) {
  Object.defineProperty(e, r, {
    value: n,
    writable: !0,
    enumerable: !0,
    configurable: !0,
  });
}
function Hu(e, r) {
  return r ? r.reduce((n, i) => n?.[i], e) : e;
}
function Wu(e) {
  let r = Object.keys(e),
    n = r.map((i) => e[i]);
  return Promise.all(n).then((i) => {
    let t = {};
    for (let o = 0; o < r.length; o++) t[r[o]] = i[o];
    return t;
  });
}
function Lt(e = 10) {
  let r = "abcdefghijklmnopqrstuvwxyz",
    n = "";
  for (let i = 0; i < e; i++) n += r[Math.floor(Math.random() * r.length)];
  return n;
}
function Ae(e) {
  return JSON.stringify(e);
}
function Ve(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
var cn = Xe(() => {
  try {
    let e = Function;
    return (new e(""), !0);
  } catch {
    return !1;
  }
});
function Qe(e) {
  if (Ve(e) === !1) return !1;
  let r = e.constructor;
  if (r === void 0) return !0;
  let n = r.prototype;
  return !(
    Ve(n) === !1 ||
    Object.prototype.hasOwnProperty.call(n, "isPrototypeOf") === !1
  );
}
function Yu(e) {
  let r = 0;
  for (let n in e) Object.prototype.hasOwnProperty.call(e, n) && r++;
  return r;
}
var Ku = (e) => {
    let r = typeof e;
    switch (r) {
      case "undefined":
        return "undefined";
      case "string":
        return "string";
      case "number":
        return Number.isNaN(e) ? "nan" : "number";
      case "boolean":
        return "boolean";
      case "function":
        return "function";
      case "bigint":
        return "bigint";
      case "symbol":
        return "symbol";
      case "object":
        return Array.isArray(e)
          ? "array"
          : e === null
            ? "null"
            : e.then &&
                typeof e.then == "function" &&
                e.catch &&
                typeof e.catch == "function"
              ? "promise"
              : typeof Map < "u" && e instanceof Map
                ? "map"
                : typeof Set < "u" && e instanceof Set
                  ? "set"
                  : typeof Date < "u" && e instanceof Date
                    ? "date"
                    : typeof File < "u" && e instanceof File
                      ? "file"
                      : "object";
      default:
        throw new Error(`Unknown data type: ${r}`);
    }
  },
  et = new Set(["string", "number", "symbol"]),
  _n = new Set([
    "string",
    "number",
    "bigint",
    "boolean",
    "symbol",
    "undefined",
  ]);
function ue(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Q(e, r, n) {
  let i = new e._zod.constr(r ?? e._zod.def);
  return ((!r || n?.parent) && (i._zod.parent = e), i);
}
function y(e) {
  let r = e;
  if (!r) return {};
  if (typeof r == "string") return { error: () => r };
  if (r?.message !== void 0) {
    if (r?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    r.error = r.message;
  }
  return (
    delete r.message,
    typeof r.error == "string" ? { ...r, error: () => r.error } : r
  );
}
function Xu(e) {
  let r;
  return new Proxy(
    {},
    {
      get(n, i, t) {
        return (r ?? (r = e()), Reflect.get(r, i, t));
      },
      set(n, i, t, o) {
        return (r ?? (r = e()), Reflect.set(r, i, t, o));
      },
      has(n, i) {
        return (r ?? (r = e()), Reflect.has(r, i));
      },
      deleteProperty(n, i) {
        return (r ?? (r = e()), Reflect.deleteProperty(r, i));
      },
      ownKeys(n) {
        return (r ?? (r = e()), Reflect.ownKeys(r));
      },
      getOwnPropertyDescriptor(n, i) {
        return (r ?? (r = e()), Reflect.getOwnPropertyDescriptor(r, i));
      },
      defineProperty(n, i, t) {
        return (r ?? (r = e()), Reflect.defineProperty(r, i, t));
      },
    },
  );
}
function x(e) {
  return typeof e == "bigint"
    ? e.toString() + "n"
    : typeof e == "string"
      ? `"${e}"`
      : `${e}`;
}
function dn(e) {
  return Object.keys(e).filter(
    (r) => e[r]._zod.optin === "optional" && e[r]._zod.optout === "optional",
  );
}
var mn = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 34028234663852886e22],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
  },
  pn = {
    int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
    uint64: [BigInt(0), BigInt("18446744073709551615")],
  };
function Ju(e, r) {
  let n = {},
    i = e._zod.def;
  for (let t in r) {
    if (!(t in i.shape)) throw new Error(`Unrecognized key: "${t}"`);
    r[t] && (n[t] = i.shape[t]);
  }
  return Q(e, { ...e._zod.def, shape: n, checks: [] });
}
function Qu(e, r) {
  let n = { ...e._zod.def.shape },
    i = e._zod.def;
  for (let t in r) {
    if (!(t in i.shape)) throw new Error(`Unrecognized key: "${t}"`);
    r[t] && delete n[t];
  }
  return Q(e, { ...e._zod.def, shape: n, checks: [] });
}
function ec(e, r) {
  let n = {
    ...e._zod.def,
    get shape() {
      let i = { ...e._zod.def.shape, ...r };
      return (un(this, "shape", i), i);
    },
    checks: [],
  };
  return Q(e, n);
}
function tc(e, r) {
  return Q(e, {
    ...e._zod.def,
    get shape() {
      let n = { ...e._zod.def.shape, ...r._zod.def.shape };
      return (un(this, "shape", n), n);
    },
    catchall: r._zod.def.catchall,
    checks: [],
  });
}
function rc(e, r, n) {
  let i = r._zod.def.shape,
    t = { ...i };
  if (n)
    for (let o in n) {
      if (!(o in i)) throw new Error(`Unrecognized key: "${o}"`);
      n[o] && (t[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o]);
    }
  else
    for (let o in i)
      t[o] = e ? new e({ type: "optional", innerType: i[o] }) : i[o];
  return Q(r, { ...r._zod.def, shape: t, checks: [] });
}
function nc(e, r, n) {
  let i = r._zod.def.shape,
    t = { ...i };
  if (n)
    for (let o in n) {
      if (!(o in t)) throw new Error(`Unrecognized key: "${o}"`);
      n[o] && (t[o] = new e({ type: "nonoptional", innerType: i[o] }));
    }
  else for (let o in i) t[o] = new e({ type: "nonoptional", innerType: i[o] });
  return Q(r, { ...r._zod.def, shape: t, checks: [] });
}
function ke(e, r = 0) {
  for (let n = r; n < e.issues.length; n++)
    if (e.issues[n].continue !== !0) return !0;
  return !1;
}
function K(e, r) {
  return r.map((n) => {
    var i;
    return ((i = n).path ?? (i.path = []), n.path.unshift(e), n);
  });
}
function Ye(e) {
  return typeof e == "string" ? e : e?.message;
}
function ee(e, r, n) {
  let i = { ...e, path: e.path ?? [] };
  if (!e.message) {
    let t =
      Ye(e.inst?._zod.def?.error?.(e)) ??
      Ye(r?.error?.(e)) ??
      Ye(n.customError?.(e)) ??
      Ye(n.localeError?.(e)) ??
      "Invalid input";
    i.message = t;
  }
  return (
    delete i.inst,
    delete i.continue,
    r?.reportInput || delete i.input,
    i
  );
}
function tt(e) {
  return e instanceof Set
    ? "set"
    : e instanceof Map
      ? "map"
      : e instanceof File
        ? "file"
        : "unknown";
}
function rt(e) {
  return Array.isArray(e)
    ? "array"
    : typeof e == "string"
      ? "string"
      : "unknown";
}
function fn(...e) {
  let [r, n, i] = e;
  return typeof r == "string"
    ? { message: r, code: "custom", input: n, inst: i }
    : { ...r };
}
function oc(e) {
  return Object.entries(e)
    .filter(([r, n]) => Number.isNaN(Number.parseInt(r, 10)))
    .map((r) => r[1]);
}
var an = class {
  constructor(...r) {}
};
var is = (e, r) => {
    ((e.name = "$ZodError"),
      Object.defineProperty(e, "_zod", { value: e._zod, enumerable: !1 }),
      Object.defineProperty(e, "issues", { value: r, enumerable: !1 }),
      Object.defineProperty(e, "message", {
        get() {
          return JSON.stringify(r, sn, 2);
        },
        enumerable: !0,
      }));
  },
  nt = c("$ZodError", is),
  Te = c("$ZodError", is, { Parent: Error });
function ot(e, r = (n) => n.message) {
  let n = {},
    i = [];
  for (let t of e.issues)
    t.path.length > 0
      ? ((n[t.path[0]] = n[t.path[0]] || []), n[t.path[0]].push(r(t)))
      : i.push(r(t));
  return { formErrors: i, fieldErrors: n };
}
function it(e, r) {
  let n =
      r ||
      function (o) {
        return o.message;
      },
    i = { _errors: [] },
    t = (o) => {
      for (let a of o.issues)
        if (a.code === "invalid_union" && a.errors.length)
          a.errors.map((s) => t({ issues: s }));
        else if (a.code === "invalid_key") t({ issues: a.issues });
        else if (a.code === "invalid_element") t({ issues: a.issues });
        else if (a.path.length === 0) i._errors.push(n(a));
        else {
          let s = i,
            u = 0;
          for (; u < a.path.length; ) {
            let l = a.path[u];
            (u === a.path.length - 1
              ? ((s[l] = s[l] || { _errors: [] }), s[l]._errors.push(n(a)))
              : (s[l] = s[l] || { _errors: [] }),
              (s = s[l]),
              u++);
          }
        }
    };
  return (t(e), i);
}
function gn(e, r) {
  let n =
      r ||
      function (o) {
        return o.message;
      },
    i = { errors: [] },
    t = (o, a = []) => {
      var s, u;
      for (let l of o.issues)
        if (l.code === "invalid_union" && l.errors.length)
          l.errors.map((m) => t({ issues: m }, l.path));
        else if (l.code === "invalid_key") t({ issues: l.issues }, l.path);
        else if (l.code === "invalid_element") t({ issues: l.issues }, l.path);
        else {
          let m = [...a, ...l.path];
          if (m.length === 0) {
            i.errors.push(n(l));
            continue;
          }
          let p = i,
            d = 0;
          for (; d < m.length; ) {
            let _ = m[d],
              h = d === m.length - 1;
            (typeof _ == "string"
              ? (p.properties ?? (p.properties = {}),
                (s = p.properties)[_] ?? (s[_] = { errors: [] }),
                (p = p.properties[_]))
              : (p.items ?? (p.items = []),
                (u = p.items)[_] ?? (u[_] = { errors: [] }),
                (p = p.items[_])),
              h && p.errors.push(n(l)),
              d++);
          }
        }
    };
  return (t(e), i);
}
function as(e) {
  let r = [];
  for (let n of e)
    typeof n == "number"
      ? r.push(`[${n}]`)
      : typeof n == "symbol"
        ? r.push(`[${JSON.stringify(String(n))}]`)
        : /[^\w$]/.test(n)
          ? r.push(`[${JSON.stringify(n)}]`)
          : (r.length && r.push("."), r.push(n));
  return r.join("");
}
function hn(e) {
  let r = [],
    n = [...e.issues].sort((i, t) => i.path.length - t.path.length);
  for (let i of n)
    (r.push(`\u2716 ${i.message}`),
      i.path?.length && r.push(`  \u2192 at ${as(i.path)}`));
  return r.join(`
`);
}
var Ft = (e) => (r, n, i, t) => {
    let o = i ? Object.assign(i, { async: !1 }) : { async: !1 },
      a = r._zod.run({ value: n, issues: [] }, o);
    if (a instanceof Promise) throw new ae();
    if (a.issues.length) {
      let s = new (t?.Err ?? e)(a.issues.map((u) => ee(u, o, F())));
      throw (Error.captureStackTrace(s, t?.callee), s);
    }
    return a.value;
  },
  Zt = Ft(Te),
  Bt = (e) => async (r, n, i, t) => {
    let o = i ? Object.assign(i, { async: !0 }) : { async: !0 },
      a = r._zod.run({ value: n, issues: [] }, o);
    if ((a instanceof Promise && (a = await a), a.issues.length)) {
      let s = new (t?.Err ?? e)(a.issues.map((u) => ee(u, o, F())));
      throw (Error.captureStackTrace(s, t?.callee), s);
    }
    return a.value;
  },
  qt = Bt(Te),
  Gt = (e) => (r, n, i) => {
    let t = i ? { ...i, async: !1 } : { async: !1 },
      o = r._zod.run({ value: n, issues: [] }, t);
    if (o instanceof Promise) throw new ae();
    return o.issues.length
      ? {
          success: !1,
          error: new (e ?? nt)(o.issues.map((a) => ee(a, t, F()))),
        }
      : { success: !0, data: o.value };
  },
  vn = Gt(Te),
  Ht = (e) => async (r, n, i) => {
    let t = i ? Object.assign(i, { async: !0 }) : { async: !0 },
      o = r._zod.run({ value: n, issues: [] }, t);
    return (
      o instanceof Promise && (o = await o),
      o.issues.length
        ? { success: !1, error: new e(o.issues.map((a) => ee(a, t, F()))) }
        : { success: !0, data: o.value }
    );
  },
  yn = Ht(Te);
var ze = {};
xe(ze, {
  _emoji: () => ss,
  base64: () => On,
  base64url: () => Wt,
  bigint: () => Ln,
  boolean: () => Bn,
  browserEmail: () => mc,
  cidrv4: () => Vn,
  cidrv6: () => Tn,
  cuid: () => bn,
  cuid2: () => wn,
  date: () => Mn,
  datetime: () => Rn,
  domain: () => pc,
  duration: () => zn,
  e164: () => Nn,
  email: () => In,
  emoji: () => Pn,
  extendedDuration: () => ac,
  guid: () => Sn,
  hostname: () => jn,
  html5Email: () => cc,
  integer: () => Fn,
  ipv4: () => Dn,
  ipv6: () => En,
  ksuid: () => kn,
  lowercase: () => Hn,
  nanoid: () => $n,
  null: () => qn,
  number: () => Zn,
  rfc5322Email: () => _c,
  string: () => Cn,
  time: () => Un,
  ulid: () => xn,
  undefined: () => Gn,
  unicodeEmail: () => dc,
  uppercase: () => Wn,
  uuid: () => $e,
  uuid4: () => sc,
  uuid6: () => lc,
  uuid7: () => uc,
  xid: () => An,
});
var bn = /^[cC][^\s-]{8,}$/,
  wn = /^[0-9a-z]+$/,
  xn = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/,
  An = /^[0-9a-vA-V]{20}$/,
  kn = /^[A-Za-z0-9]{27}$/,
  $n = /^[a-zA-Z0-9_-]{21}$/,
  zn =
    /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/,
  ac =
    /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
  Sn =
    /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/,
  $e = (e) =>
    e
      ? new RegExp(
          `^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`,
        )
      : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/,
  sc = $e(4),
  lc = $e(6),
  uc = $e(7),
  In =
    /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
  cc =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  _c =
    /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  dc = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u,
  mc =
    /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/,
  ss = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Pn() {
  return new RegExp(ss, "u");
}
var Dn =
    /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  En =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/,
  Vn =
    /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/,
  Tn =
    /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  On =
    /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/,
  Wt = /^[A-Za-z0-9_-]*$/,
  jn = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/,
  pc = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/,
  Nn = /^\+(?:[0-9]){6,14}[0-9]$/,
  ls =
    "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
  Mn = new RegExp(`^${ls}$`);
function us(e) {
  let r = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d";
  return (
    e.precision
      ? (r = `${r}\\.\\d{${e.precision}}`)
      : e.precision == null && (r = `${r}(\\.\\d+)?`),
    r
  );
}
function Un(e) {
  return new RegExp(`^${us(e)}$`);
}
function Rn(e) {
  let r = `${ls}T${us(e)}`,
    n = [];
  return (
    n.push(e.local ? "Z?" : "Z"),
    e.offset && n.push("([+-]\\d{2}:?\\d{2})"),
    (r = `${r}(${n.join("|")})`),
    new RegExp(`^${r}$`)
  );
}
var Cn = (e) => {
    let r = e
      ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}`
      : "[\\s\\S]*";
    return new RegExp(`^${r}$`);
  },
  Ln = /^\d+n?$/,
  Fn = /^\d+$/,
  Zn = /^-?\d+(?:\.\d+)?/i,
  Bn = /true|false/i,
  qn = /null/i;
var Gn = /undefined/i;
var Hn = /^[^A-Z]*$/,
  Wn = /^[^a-z]*$/;
var L = c("$ZodCheck", (e, r) => {
    var n;
    (e._zod ?? (e._zod = {}),
      (e._zod.def = r),
      (n = e._zod).onattach ?? (n.onattach = []));
  }),
  _s = { number: "number", bigint: "bigint", object: "date" },
  Yt = c("$ZodCheckLessThan", (e, r) => {
    L.init(e, r);
    let n = _s[typeof r.value];
    (e._zod.onattach.push((i) => {
      let t = i._zod.bag,
        o =
          (r.inclusive ? t.maximum : t.exclusiveMaximum) ??
          Number.POSITIVE_INFINITY;
      r.value < o &&
        (r.inclusive ? (t.maximum = r.value) : (t.exclusiveMaximum = r.value));
    }),
      (e._zod.check = (i) => {
        (r.inclusive ? i.value <= r.value : i.value < r.value) ||
          i.issues.push({
            origin: n,
            code: "too_big",
            maximum: r.value,
            input: i.value,
            inclusive: r.inclusive,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Kt = c("$ZodCheckGreaterThan", (e, r) => {
    L.init(e, r);
    let n = _s[typeof r.value];
    (e._zod.onattach.push((i) => {
      let t = i._zod.bag,
        o =
          (r.inclusive ? t.minimum : t.exclusiveMinimum) ??
          Number.NEGATIVE_INFINITY;
      r.value > o &&
        (r.inclusive ? (t.minimum = r.value) : (t.exclusiveMinimum = r.value));
    }),
      (e._zod.check = (i) => {
        (r.inclusive ? i.value >= r.value : i.value > r.value) ||
          i.issues.push({
            origin: n,
            code: "too_small",
            minimum: r.value,
            input: i.value,
            inclusive: r.inclusive,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Yn = c("$ZodCheckMultipleOf", (e, r) => {
    (L.init(e, r),
      e._zod.onattach.push((n) => {
        var i;
        (i = n._zod.bag).multipleOf ?? (i.multipleOf = r.value);
      }),
      (e._zod.check = (n) => {
        if (typeof n.value != typeof r.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        (typeof n.value == "bigint"
          ? n.value % r.value === BigInt(0)
          : ln(n.value, r.value) === 0) ||
          n.issues.push({
            origin: typeof n.value,
            code: "not_multiple_of",
            divisor: r.value,
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Kn = c("$ZodCheckNumberFormat", (e, r) => {
    (L.init(e, r), (r.format = r.format || "float64"));
    let n = r.format?.includes("int"),
      i = n ? "int" : "number",
      [t, o] = mn[r.format];
    (e._zod.onattach.push((a) => {
      let s = a._zod.bag;
      ((s.format = r.format),
        (s.minimum = t),
        (s.maximum = o),
        n && (s.pattern = Fn));
    }),
      (e._zod.check = (a) => {
        let s = a.value;
        if (n) {
          if (!Number.isInteger(s)) {
            a.issues.push({
              expected: i,
              format: r.format,
              code: "invalid_type",
              input: s,
              inst: e,
            });
            return;
          }
          if (!Number.isSafeInteger(s)) {
            s > 0
              ? a.issues.push({
                  input: s,
                  code: "too_big",
                  maximum: Number.MAX_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: i,
                  continue: !r.abort,
                })
              : a.issues.push({
                  input: s,
                  code: "too_small",
                  minimum: Number.MIN_SAFE_INTEGER,
                  note: "Integers must be within the safe integer range.",
                  inst: e,
                  origin: i,
                  continue: !r.abort,
                });
            return;
          }
        }
        (s < t &&
          a.issues.push({
            origin: "number",
            input: s,
            code: "too_small",
            minimum: t,
            inclusive: !0,
            inst: e,
            continue: !r.abort,
          }),
          s > o &&
            a.issues.push({
              origin: "number",
              input: s,
              code: "too_big",
              maximum: o,
              inst: e,
            }));
      }));
  }),
  Xn = c("$ZodCheckBigIntFormat", (e, r) => {
    L.init(e, r);
    let [n, i] = pn[r.format];
    (e._zod.onattach.push((t) => {
      let o = t._zod.bag;
      ((o.format = r.format), (o.minimum = n), (o.maximum = i));
    }),
      (e._zod.check = (t) => {
        let o = t.value;
        (o < n &&
          t.issues.push({
            origin: "bigint",
            input: o,
            code: "too_small",
            minimum: n,
            inclusive: !0,
            inst: e,
            continue: !r.abort,
          }),
          o > i &&
            t.issues.push({
              origin: "bigint",
              input: o,
              code: "too_big",
              maximum: i,
              inst: e,
            }));
      }));
  }),
  Jn = c("$ZodCheckMaxSize", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        r.maximum < i && (n._zod.bag.maximum = r.maximum);
      }),
      (e._zod.check = (n) => {
        let i = n.value;
        i.size <= r.maximum ||
          n.issues.push({
            origin: tt(i),
            code: "too_big",
            maximum: r.maximum,
            input: i,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Qn = c("$ZodCheckMinSize", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        r.minimum > i && (n._zod.bag.minimum = r.minimum);
      }),
      (e._zod.check = (n) => {
        let i = n.value;
        i.size >= r.minimum ||
          n.issues.push({
            origin: tt(i),
            code: "too_small",
            minimum: r.minimum,
            input: i,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  eo = c("$ZodCheckSizeEquals", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.size !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag;
        ((i.minimum = r.size), (i.maximum = r.size), (i.size = r.size));
      }),
      (e._zod.check = (n) => {
        let i = n.value,
          t = i.size;
        if (t === r.size) return;
        let o = t > r.size;
        n.issues.push({
          origin: tt(i),
          ...(o
            ? { code: "too_big", maximum: r.size }
            : { code: "too_small", minimum: r.size }),
          input: n.value,
          inst: e,
          continue: !r.abort,
        });
      }));
  }),
  to = c("$ZodCheckMaxLength", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        r.maximum < i && (n._zod.bag.maximum = r.maximum);
      }),
      (e._zod.check = (n) => {
        let i = n.value;
        if (i.length <= r.maximum) return;
        let o = rt(i);
        n.issues.push({
          origin: o,
          code: "too_big",
          maximum: r.maximum,
          inclusive: !0,
          input: i,
          inst: e,
          continue: !r.abort,
        });
      }));
  }),
  ro = c("$ZodCheckMinLength", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        r.minimum > i && (n._zod.bag.minimum = r.minimum);
      }),
      (e._zod.check = (n) => {
        let i = n.value;
        if (i.length >= r.minimum) return;
        let o = rt(i);
        n.issues.push({
          origin: o,
          code: "too_small",
          minimum: r.minimum,
          inclusive: !0,
          input: i,
          inst: e,
          continue: !r.abort,
        });
      }));
  }),
  no = c("$ZodCheckLengthEquals", (e, r) => {
    (L.init(e, r),
      (e._zod.when = (n) => {
        let i = n.value;
        return !ye(i) && i.length !== void 0;
      }),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag;
        ((i.minimum = r.length), (i.maximum = r.length), (i.length = r.length));
      }),
      (e._zod.check = (n) => {
        let i = n.value,
          t = i.length;
        if (t === r.length) return;
        let o = rt(i),
          a = t > r.length;
        n.issues.push({
          origin: o,
          ...(a
            ? { code: "too_big", maximum: r.length }
            : { code: "too_small", minimum: r.length }),
          input: n.value,
          inst: e,
          continue: !r.abort,
        });
      }));
  }),
  Oe = c("$ZodCheckStringFormat", (e, r) => {
    var n;
    (L.init(e, r),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        ((t.format = r.format),
          r.pattern &&
            (t.patterns ?? (t.patterns = new Set()),
            t.patterns.add(r.pattern)));
      }),
      (n = e._zod).check ??
        (n.check = (i) => {
          if (!r.pattern) throw new Error("Not implemented.");
          ((r.pattern.lastIndex = 0),
            !r.pattern.test(i.value) &&
              i.issues.push({
                origin: "string",
                code: "invalid_format",
                format: r.format,
                input: i.value,
                ...(r.pattern ? { pattern: r.pattern.toString() } : {}),
                inst: e,
                continue: !r.abort,
              }));
        }));
  }),
  oo = c("$ZodCheckRegex", (e, r) => {
    (Oe.init(e, r),
      (e._zod.check = (n) => {
        ((r.pattern.lastIndex = 0),
          !r.pattern.test(n.value) &&
            n.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: n.value,
              pattern: r.pattern.toString(),
              inst: e,
              continue: !r.abort,
            }));
      }));
  }),
  io = c("$ZodCheckLowerCase", (e, r) => {
    (r.pattern ?? (r.pattern = Hn), Oe.init(e, r));
  }),
  ao = c("$ZodCheckUpperCase", (e, r) => {
    (r.pattern ?? (r.pattern = Wn), Oe.init(e, r));
  }),
  so = c("$ZodCheckIncludes", (e, r) => {
    L.init(e, r);
    let n = ue(r.includes),
      i = new RegExp(
        typeof r.position == "number" ? `^.{${r.position}}${n}` : n,
      );
    ((r.pattern = i),
      e._zod.onattach.push((t) => {
        let o = t._zod.bag;
        (o.patterns ?? (o.patterns = new Set()), o.patterns.add(i));
      }),
      (e._zod.check = (t) => {
        t.value.includes(r.includes, r.position) ||
          t.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: r.includes,
            input: t.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  lo = c("$ZodCheckStartsWith", (e, r) => {
    L.init(e, r);
    let n = new RegExp(`^${ue(r.prefix)}.*`);
    (r.pattern ?? (r.pattern = n),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        (t.patterns ?? (t.patterns = new Set()), t.patterns.add(n));
      }),
      (e._zod.check = (i) => {
        i.value.startsWith(r.prefix) ||
          i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: r.prefix,
            input: i.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  uo = c("$ZodCheckEndsWith", (e, r) => {
    L.init(e, r);
    let n = new RegExp(`.*${ue(r.suffix)}$`);
    (r.pattern ?? (r.pattern = n),
      e._zod.onattach.push((i) => {
        let t = i._zod.bag;
        (t.patterns ?? (t.patterns = new Set()), t.patterns.add(n));
      }),
      (e._zod.check = (i) => {
        i.value.endsWith(r.suffix) ||
          i.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: r.suffix,
            input: i.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  });
function cs(e, r, n) {
  e.issues.length && r.issues.push(...K(n, e.issues));
}
var co = c("$ZodCheckProperty", (e, r) => {
    (L.init(e, r),
      (e._zod.check = (n) => {
        let i = r.schema._zod.run(
          { value: n.value[r.property], issues: [] },
          {},
        );
        if (i instanceof Promise) return i.then((t) => cs(t, n, r.property));
        cs(i, n, r.property);
      }));
  }),
  _o = c("$ZodCheckMimeType", (e, r) => {
    L.init(e, r);
    let n = new Set(r.mime);
    (e._zod.onattach.push((i) => {
      i._zod.bag.mime = r.mime;
    }),
      (e._zod.check = (i) => {
        n.has(i.value.type) ||
          i.issues.push({
            code: "invalid_value",
            values: r.mime,
            input: i.value.type,
            path: ["type"],
            inst: e,
          });
      }));
  }),
  mo = c("$ZodCheckOverwrite", (e, r) => {
    (L.init(e, r),
      (e._zod.check = (n) => {
        n.value = r.tx(n.value);
      }));
  });
var at = class {
  constructor(r = []) {
    ((this.content = []), (this.indent = 0), this && (this.args = r));
  }
  indented(r) {
    ((this.indent += 1), r(this), (this.indent -= 1));
  }
  write(r) {
    if (typeof r == "function") {
      (r(this, { execution: "sync" }), r(this, { execution: "async" }));
      return;
    }
    let i = r
        .split(
          `
`,
        )
        .filter((a) => a),
      t = Math.min(...i.map((a) => a.length - a.trimStart().length)),
      o = i.map((a) => a.slice(t)).map((a) => " ".repeat(this.indent * 2) + a);
    for (let a of o) this.content.push(a);
  }
  compile() {
    let r = Function,
      n = this?.args,
      t = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new r(
      ...n,
      t.join(`
`),
    );
  }
};
var po = { major: 4, minor: 0, patch: 0 };
var P = c("$ZodType", (e, r) => {
    var n;
    (e ?? (e = {}),
      (e._zod.id = r.type + "_" + Lt(10)),
      (e._zod.def = r),
      (e._zod.bag = e._zod.bag || {}),
      (e._zod.version = po));
    let i = [...(e._zod.def.checks ?? [])];
    e._zod.traits.has("$ZodCheck") && i.unshift(e);
    for (let t of i) for (let o of t._zod.onattach) o(e);
    if (i.length === 0)
      ((n = e._zod).deferred ?? (n.deferred = []),
        e._zod.deferred?.push(() => {
          e._zod.run = e._zod.parse;
        }));
    else {
      let t = (o, a, s) => {
        let u = ke(o),
          l;
        for (let m of a) {
          if (m._zod.when) {
            if (!m._zod.when(o)) continue;
          } else if (u) continue;
          let p = o.issues.length,
            d = m._zod.check(o);
          if (d instanceof Promise && s?.async === !1) throw new ae();
          if (l || d instanceof Promise)
            l = (l ?? Promise.resolve()).then(async () => {
              (await d, o.issues.length !== p && (u || (u = ke(o, p))));
            });
          else {
            if (o.issues.length === p) continue;
            u || (u = ke(o, p));
          }
        }
        return l ? l.then(() => o) : o;
      };
      e._zod.run = (o, a) => {
        let s = e._zod.parse(o, a);
        if (s instanceof Promise) {
          if (a.async === !1) throw new ae();
          return s.then((u) => t(u, i, a));
        }
        return t(s, i, a);
      };
    }
    e["~standard"] = {
      validate: (t) => {
        try {
          let o = vn(e, t);
          return o.success ? { value: o.data } : { issues: o.error?.issues };
        } catch {
          return yn(e, t).then((a) =>
            a.success ? { value: a.data } : { issues: a.error?.issues },
          );
        }
      },
      vendor: "zod",
      version: 1,
    };
  }),
  st = c("$ZodString", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern =
        [...(e?._zod.bag?.patterns ?? [])].pop() ?? Cn(e._zod.bag)),
      (e._zod.parse = (n, i) => {
        if (r.coerce)
          try {
            n.value = String(n.value);
          } catch {}
        return (
          typeof n.value == "string" ||
            n.issues.push({
              expected: "string",
              code: "invalid_type",
              input: n.value,
              inst: e,
            }),
          n
        );
      }));
  }),
  M = c("$ZodStringFormat", (e, r) => {
    (Oe.init(e, r), st.init(e, r));
  }),
  go = c("$ZodGUID", (e, r) => {
    (r.pattern ?? (r.pattern = Sn), M.init(e, r));
  }),
  ho = c("$ZodUUID", (e, r) => {
    if (r.version) {
      let i = { v1: 1, v2: 2, v3: 3, v4: 4, v5: 5, v6: 6, v7: 7, v8: 8 }[
        r.version
      ];
      if (i === void 0) throw new Error(`Invalid UUID version: "${r.version}"`);
      r.pattern ?? (r.pattern = $e(i));
    } else r.pattern ?? (r.pattern = $e());
    M.init(e, r);
  }),
  vo = c("$ZodEmail", (e, r) => {
    (r.pattern ?? (r.pattern = In), M.init(e, r));
  }),
  yo = c("$ZodURL", (e, r) => {
    (M.init(e, r),
      (e._zod.check = (n) => {
        try {
          let i = new URL(n.value);
          (r.hostname &&
            ((r.hostname.lastIndex = 0),
            r.hostname.test(i.hostname) ||
              n.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: jn.source,
                input: n.value,
                inst: e,
                continue: !r.abort,
              })),
            r.protocol &&
              ((r.protocol.lastIndex = 0),
              r.protocol.test(
                i.protocol.endsWith(":") ? i.protocol.slice(0, -1) : i.protocol,
              ) ||
                n.issues.push({
                  code: "invalid_format",
                  format: "url",
                  note: "Invalid protocol",
                  pattern: r.protocol.source,
                  input: n.value,
                  inst: e,
                  continue: !r.abort,
                })));
          return;
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "url",
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
        }
      }));
  }),
  bo = c("$ZodEmoji", (e, r) => {
    (r.pattern ?? (r.pattern = Pn()), M.init(e, r));
  }),
  wo = c("$ZodNanoID", (e, r) => {
    (r.pattern ?? (r.pattern = $n), M.init(e, r));
  }),
  xo = c("$ZodCUID", (e, r) => {
    (r.pattern ?? (r.pattern = bn), M.init(e, r));
  }),
  Ao = c("$ZodCUID2", (e, r) => {
    (r.pattern ?? (r.pattern = wn), M.init(e, r));
  }),
  ko = c("$ZodULID", (e, r) => {
    (r.pattern ?? (r.pattern = xn), M.init(e, r));
  }),
  $o = c("$ZodXID", (e, r) => {
    (r.pattern ?? (r.pattern = An), M.init(e, r));
  }),
  zo = c("$ZodKSUID", (e, r) => {
    (r.pattern ?? (r.pattern = kn), M.init(e, r));
  }),
  So = c("$ZodISODateTime", (e, r) => {
    (r.pattern ?? (r.pattern = Rn(r)), M.init(e, r));
  }),
  Io = c("$ZodISODate", (e, r) => {
    (r.pattern ?? (r.pattern = Mn), M.init(e, r));
  }),
  Po = c("$ZodISOTime", (e, r) => {
    (r.pattern ?? (r.pattern = Un(r)), M.init(e, r));
  }),
  Do = c("$ZodISODuration", (e, r) => {
    (r.pattern ?? (r.pattern = zn), M.init(e, r));
  }),
  Eo = c("$ZodIPv4", (e, r) => {
    (r.pattern ?? (r.pattern = Dn),
      M.init(e, r),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag;
        i.format = "ipv4";
      }));
  }),
  Vo = c("$ZodIPv6", (e, r) => {
    (r.pattern ?? (r.pattern = En),
      M.init(e, r),
      e._zod.onattach.push((n) => {
        let i = n._zod.bag;
        i.format = "ipv6";
      }),
      (e._zod.check = (n) => {
        try {
          new URL(`http://[${n.value}]`);
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
        }
      }));
  }),
  To = c("$ZodCIDRv4", (e, r) => {
    (r.pattern ?? (r.pattern = Vn), M.init(e, r));
  }),
  Oo = c("$ZodCIDRv6", (e, r) => {
    (r.pattern ?? (r.pattern = Tn),
      M.init(e, r),
      (e._zod.check = (n) => {
        let [i, t] = n.value.split("/");
        try {
          if (!t) throw new Error();
          let o = Number(t);
          if (`${o}` !== t) throw new Error();
          if (o < 0 || o > 128) throw new Error();
          new URL(`http://[${i}]`);
        } catch {
          n.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
        }
      }));
  });
function jo(e) {
  if (e === "") return !0;
  if (e.length % 4 !== 0) return !1;
  try {
    return (atob(e), !0);
  } catch {
    return !1;
  }
}
var No = c("$ZodBase64", (e, r) => {
  (r.pattern ?? (r.pattern = On),
    M.init(e, r),
    e._zod.onattach.push((n) => {
      n._zod.bag.contentEncoding = "base64";
    }),
    (e._zod.check = (n) => {
      jo(n.value) ||
        n.issues.push({
          code: "invalid_format",
          format: "base64",
          input: n.value,
          inst: e,
          continue: !r.abort,
        });
    }));
});
function ks(e) {
  if (!Wt.test(e)) return !1;
  let r = e.replace(/[-_]/g, (i) => (i === "-" ? "+" : "/")),
    n = r.padEnd(Math.ceil(r.length / 4) * 4, "=");
  return jo(n);
}
var Mo = c("$ZodBase64URL", (e, r) => {
    (r.pattern ?? (r.pattern = Wt),
      M.init(e, r),
      e._zod.onattach.push((n) => {
        n._zod.bag.contentEncoding = "base64url";
      }),
      (e._zod.check = (n) => {
        ks(n.value) ||
          n.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Uo = c("$ZodE164", (e, r) => {
    (r.pattern ?? (r.pattern = Nn), M.init(e, r));
  });
function $s(e, r = null) {
  try {
    let n = e.split(".");
    if (n.length !== 3) return !1;
    let [i] = n,
      t = JSON.parse(atob(i));
    return !(
      ("typ" in t && t?.typ !== "JWT") ||
      !t.alg ||
      (r && (!("alg" in t) || t.alg !== r))
    );
  } catch {
    return !1;
  }
}
var Ro = c("$ZodJWT", (e, r) => {
    (M.init(e, r),
      (e._zod.check = (n) => {
        $s(n.value, r.alg) ||
          n.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: n.value,
            inst: e,
            continue: !r.abort,
          });
      }));
  }),
  Qt = c("$ZodNumber", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern = e._zod.bag.pattern ?? Zn),
      (e._zod.parse = (n, i) => {
        if (r.coerce)
          try {
            n.value = Number(n.value);
          } catch {}
        let t = n.value;
        if (typeof t == "number" && !Number.isNaN(t) && Number.isFinite(t))
          return n;
        let o =
          typeof t == "number"
            ? Number.isNaN(t)
              ? "NaN"
              : Number.isFinite(t)
                ? void 0
                : "Infinity"
            : void 0;
        return (
          n.issues.push({
            expected: "number",
            code: "invalid_type",
            input: t,
            inst: e,
            ...(o ? { received: o } : {}),
          }),
          n
        );
      }));
  }),
  Co = c("$ZodNumber", (e, r) => {
    (Kn.init(e, r), Qt.init(e, r));
  }),
  lt = c("$ZodBoolean", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern = Bn),
      (e._zod.parse = (n, i) => {
        if (r.coerce)
          try {
            n.value = !!n.value;
          } catch {}
        let t = n.value;
        return (
          typeof t == "boolean" ||
            n.issues.push({
              expected: "boolean",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  er = c("$ZodBigInt", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern = Ln),
      (e._zod.parse = (n, i) => {
        if (r.coerce)
          try {
            n.value = BigInt(n.value);
          } catch {}
        let { value: t } = n;
        return (
          typeof t == "bigint" ||
            n.issues.push({
              expected: "bigint",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  Lo = c("$ZodBigInt", (e, r) => {
    (Xn.init(e, r), er.init(e, r));
  }),
  Fo = c("$ZodSymbol", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let { value: t } = n;
        return (
          typeof t == "symbol" ||
            n.issues.push({
              expected: "symbol",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  Zo = c("$ZodUndefined", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern = Gn),
      (e._zod.values = new Set([void 0])),
      (e._zod.parse = (n, i) => {
        let { value: t } = n;
        return (
          typeof t > "u" ||
            n.issues.push({
              expected: "undefined",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  Bo = c("$ZodNull", (e, r) => {
    (P.init(e, r),
      (e._zod.pattern = qn),
      (e._zod.values = new Set([null])),
      (e._zod.parse = (n, i) => {
        let { value: t } = n;
        return (
          t === null ||
            n.issues.push({
              expected: "null",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  qo = c("$ZodAny", (e, r) => {
    (P.init(e, r), (e._zod.parse = (n) => n));
  }),
  be = c("$ZodUnknown", (e, r) => {
    (P.init(e, r), (e._zod.parse = (n) => n));
  }),
  Go = c("$ZodNever", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => (
        n.issues.push({
          expected: "never",
          code: "invalid_type",
          input: n.value,
          inst: e,
        }),
        n
      )));
  }),
  Ho = c("$ZodVoid", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let { value: t } = n;
        return (
          typeof t > "u" ||
            n.issues.push({
              expected: "void",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  Wo = c("$ZodDate", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        if (r.coerce)
          try {
            n.value = new Date(n.value);
          } catch {}
        let t = n.value,
          o = t instanceof Date;
        return (
          (o && !Number.isNaN(t.getTime())) ||
            n.issues.push({
              expected: "date",
              code: "invalid_type",
              input: t,
              ...(o ? { received: "Invalid Date" } : {}),
              inst: e,
            }),
          n
        );
      }));
  });
function ms(e, r, n) {
  (e.issues.length && r.issues.push(...K(n, e.issues)), (r.value[n] = e.value));
}
var ut = c("$ZodArray", (e, r) => {
  (P.init(e, r),
    (e._zod.parse = (n, i) => {
      let t = n.value;
      if (!Array.isArray(t))
        return (
          n.issues.push({
            expected: "array",
            code: "invalid_type",
            input: t,
            inst: e,
          }),
          n
        );
      n.value = Array(t.length);
      let o = [];
      for (let a = 0; a < t.length; a++) {
        let s = t[a],
          u = r.element._zod.run({ value: s, issues: [] }, i);
        u instanceof Promise ? o.push(u.then((l) => ms(l, n, a))) : ms(u, n, a);
      }
      return o.length ? Promise.all(o).then(() => n) : n;
    }));
});
function Xt(e, r, n) {
  (e.issues.length && r.issues.push(...K(n, e.issues)), (r.value[n] = e.value));
}
function ps(e, r, n, i) {
  e.issues.length
    ? i[n] === void 0
      ? n in i
        ? (r.value[n] = void 0)
        : (r.value[n] = e.value)
      : r.issues.push(...K(n, e.issues))
    : e.value === void 0
      ? n in i && (r.value[n] = void 0)
      : (r.value[n] = e.value);
}
var Yo = c("$ZodObject", (e, r) => {
  P.init(e, r);
  let n = Xe(() => {
    let p = Object.keys(r.shape);
    for (let _ of p)
      if (!(r.shape[_] instanceof P))
        throw new Error(`Invalid element at key "${_}": expected a Zod schema`);
    let d = dn(r.shape);
    return {
      shape: r.shape,
      keys: p,
      keySet: new Set(p),
      numKeys: p.length,
      optionalKeys: new Set(d),
    };
  });
  j(e._zod, "propValues", () => {
    let p = r.shape,
      d = {};
    for (let _ in p) {
      let h = p[_]._zod;
      if (h.values) {
        d[_] ?? (d[_] = new Set());
        for (let w of h.values) d[_].add(w);
      }
    }
    return d;
  });
  let i = (p) => {
      let d = new at(["shape", "payload", "ctx"]),
        { keys: _, optionalKeys: h } = n.value,
        w = (A) => {
          let k = Ae(A);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
      d.write("const input = payload.value;");
      let z = Object.create(null);
      for (let A of _) z[A] = Lt(15);
      d.write("const newResult = {}");
      for (let A of _)
        if (h.has(A)) {
          let k = z[A];
          d.write(`const ${k} = ${w(A)};`);
          let g = Ae(A);
          d.write(`
        if (${k}.issues.length) {
          if (input[${g}] === undefined) {
            if (${g} in input) {
              newResult[${g}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${k}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${g}, ...iss.path] : [${g}],
              }))
            );
          }
        } else if (${k}.value === undefined) {
          if (${g} in input) newResult[${g}] = undefined;
        } else {
          newResult[${g}] = ${k}.value;
        }
        `);
        } else {
          let k = z[A];
          (d.write(`const ${k} = ${w(A)};`),
            d.write(`
          if (${k}.issues.length) payload.issues = payload.issues.concat(${k}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${Ae(A)}, ...iss.path] : [${Ae(A)}]
          })));`),
            d.write(`newResult[${Ae(A)}] = ${k}.value`));
        }
      (d.write("payload.value = newResult;"), d.write("return payload;"));
      let S = d.compile();
      return (A, k) => S(p, A, k);
    },
    t,
    o = Ve,
    a = !We.jitless,
    u = a && cn.value,
    { catchall: l } = r,
    m;
  e._zod.parse = (p, d) => {
    m ?? (m = n.value);
    let _ = p.value;
    if (!o(_))
      return (
        p.issues.push({
          expected: "object",
          code: "invalid_type",
          input: _,
          inst: e,
        }),
        p
      );
    let h = [];
    if (a && u && d?.async === !1 && d.jitless !== !0)
      (t || (t = i(r.shape)), (p = t(p, d)));
    else {
      p.value = {};
      let k = m.shape;
      for (let g of m.keys) {
        let $ = k[g],
          D = $._zod.run({ value: _[g], issues: [] }, d),
          V = $._zod.optin === "optional" && $._zod.optout === "optional";
        D instanceof Promise
          ? h.push(D.then((I) => (V ? ps(I, p, g, _) : Xt(I, p, g))))
          : V
            ? ps(D, p, g, _)
            : Xt(D, p, g);
      }
    }
    if (!l) return h.length ? Promise.all(h).then(() => p) : p;
    let w = [],
      z = m.keySet,
      S = l._zod,
      A = S.def.type;
    for (let k of Object.keys(_)) {
      if (z.has(k)) continue;
      if (A === "never") {
        w.push(k);
        continue;
      }
      let g = S.run({ value: _[k], issues: [] }, d);
      g instanceof Promise ? h.push(g.then(($) => Xt($, p, k))) : Xt(g, p, k);
    }
    return (
      w.length &&
        p.issues.push({
          code: "unrecognized_keys",
          keys: w,
          input: _,
          inst: e,
        }),
      h.length ? Promise.all(h).then(() => p) : p
    );
  };
});
function fs(e, r, n, i) {
  for (let t of e) if (t.issues.length === 0) return ((r.value = t.value), r);
  return (
    r.issues.push({
      code: "invalid_union",
      input: r.value,
      inst: n,
      errors: e.map((t) => t.issues.map((o) => ee(o, i, F()))),
    }),
    r
  );
}
var tr = c("$ZodUnion", (e, r) => {
    (P.init(e, r),
      j(e._zod, "values", () => {
        if (r.options.every((n) => n._zod.values))
          return new Set(r.options.flatMap((n) => Array.from(n._zod.values)));
      }),
      j(e._zod, "pattern", () => {
        if (r.options.every((n) => n._zod.pattern)) {
          let n = r.options.map((i) => i._zod.pattern);
          return new RegExp(`^(${n.map((i) => Je(i.source)).join("|")})$`);
        }
      }),
      (e._zod.parse = (n, i) => {
        let t = !1,
          o = [];
        for (let a of r.options) {
          let s = a._zod.run({ value: n.value, issues: [] }, i);
          if (s instanceof Promise) (o.push(s), (t = !0));
          else {
            if (s.issues.length === 0) return s;
            o.push(s);
          }
        }
        return t ? Promise.all(o).then((a) => fs(a, n, e, i)) : fs(o, n, e, i);
      }));
  }),
  Ko = c("$ZodDiscriminatedUnion", (e, r) => {
    tr.init(e, r);
    let n = e._zod.parse;
    j(e._zod, "propValues", () => {
      let t = {};
      for (let o of r.options) {
        let a = o._zod.propValues;
        if (!a || Object.keys(a).length === 0)
          throw new Error(
            `Invalid discriminated union option at index "${r.options.indexOf(o)}"`,
          );
        for (let [s, u] of Object.entries(a)) {
          t[s] || (t[s] = new Set());
          for (let l of u) t[s].add(l);
        }
      }
      return t;
    });
    let i = Xe(() => {
      let t = r.options,
        o = new Map();
      for (let a of t) {
        let s = a._zod.propValues[r.discriminator];
        if (!s || s.size === 0)
          throw new Error(
            `Invalid discriminated union option at index "${r.options.indexOf(a)}"`,
          );
        for (let u of s) {
          if (o.has(u))
            throw new Error(`Duplicate discriminator value "${String(u)}"`);
          o.set(u, a);
        }
      }
      return o;
    });
    e._zod.parse = (t, o) => {
      let a = t.value;
      if (!Ve(a))
        return (
          t.issues.push({
            code: "invalid_type",
            expected: "object",
            input: a,
            inst: e,
          }),
          t
        );
      let s = i.value.get(a?.[r.discriminator]);
      return s
        ? s._zod.run(t, o)
        : r.unionFallback
          ? n(t, o)
          : (t.issues.push({
              code: "invalid_union",
              errors: [],
              note: "No matching discriminator",
              input: a,
              path: [r.discriminator],
              inst: e,
            }),
            t);
    };
  }),
  Xo = c("$ZodIntersection", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let { value: t } = n,
          o = r.left._zod.run({ value: t, issues: [] }, i),
          a = r.right._zod.run({ value: t, issues: [] }, i);
        return o instanceof Promise || a instanceof Promise
          ? Promise.all([o, a]).then(([u, l]) => gs(n, u, l))
          : gs(n, o, a);
      }));
  });
function fo(e, r) {
  if (e === r) return { valid: !0, data: e };
  if (e instanceof Date && r instanceof Date && +e == +r)
    return { valid: !0, data: e };
  if (Qe(e) && Qe(r)) {
    let n = Object.keys(r),
      i = Object.keys(e).filter((o) => n.indexOf(o) !== -1),
      t = { ...e, ...r };
    for (let o of i) {
      let a = fo(e[o], r[o]);
      if (!a.valid)
        return { valid: !1, mergeErrorPath: [o, ...a.mergeErrorPath] };
      t[o] = a.data;
    }
    return { valid: !0, data: t };
  }
  if (Array.isArray(e) && Array.isArray(r)) {
    if (e.length !== r.length) return { valid: !1, mergeErrorPath: [] };
    let n = [];
    for (let i = 0; i < e.length; i++) {
      let t = e[i],
        o = r[i],
        a = fo(t, o);
      if (!a.valid)
        return { valid: !1, mergeErrorPath: [i, ...a.mergeErrorPath] };
      n.push(a.data);
    }
    return { valid: !0, data: n };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function gs(e, r, n) {
  if (
    (r.issues.length && e.issues.push(...r.issues),
    n.issues.length && e.issues.push(...n.issues),
    ke(e))
  )
    return e;
  let i = fo(r.value, n.value);
  if (!i.valid)
    throw new Error(
      `Unmergable intersection. Error path: ${JSON.stringify(i.mergeErrorPath)}`,
    );
  return ((e.value = i.data), e);
}
var Se = c("$ZodTuple", (e, r) => {
  P.init(e, r);
  let n = r.items,
    i =
      n.length - [...n].reverse().findIndex((t) => t._zod.optin !== "optional");
  e._zod.parse = (t, o) => {
    let a = t.value;
    if (!Array.isArray(a))
      return (
        t.issues.push({
          input: a,
          inst: e,
          expected: "tuple",
          code: "invalid_type",
        }),
        t
      );
    t.value = [];
    let s = [];
    if (!r.rest) {
      let l = a.length > n.length,
        m = a.length < i - 1;
      if (l || m)
        return (
          t.issues.push({
            input: a,
            inst: e,
            origin: "array",
            ...(l
              ? { code: "too_big", maximum: n.length }
              : { code: "too_small", minimum: n.length }),
          }),
          t
        );
    }
    let u = -1;
    for (let l of n) {
      if ((u++, u >= a.length && u >= i)) continue;
      let m = l._zod.run({ value: a[u], issues: [] }, o);
      m instanceof Promise ? s.push(m.then((p) => Jt(p, t, u))) : Jt(m, t, u);
    }
    if (r.rest) {
      let l = a.slice(n.length);
      for (let m of l) {
        u++;
        let p = r.rest._zod.run({ value: m, issues: [] }, o);
        p instanceof Promise ? s.push(p.then((d) => Jt(d, t, u))) : Jt(p, t, u);
      }
    }
    return s.length ? Promise.all(s).then(() => t) : t;
  };
});
function Jt(e, r, n) {
  (e.issues.length && r.issues.push(...K(n, e.issues)), (r.value[n] = e.value));
}
var Jo = c("$ZodRecord", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let t = n.value;
        if (!Qe(t))
          return (
            n.issues.push({
              expected: "record",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
            n
          );
        let o = [];
        if (r.keyType._zod.values) {
          let a = r.keyType._zod.values;
          n.value = {};
          for (let u of a)
            if (
              typeof u == "string" ||
              typeof u == "number" ||
              typeof u == "symbol"
            ) {
              let l = r.valueType._zod.run({ value: t[u], issues: [] }, i);
              l instanceof Promise
                ? o.push(
                    l.then((m) => {
                      (m.issues.length && n.issues.push(...K(u, m.issues)),
                        (n.value[u] = m.value));
                    }),
                  )
                : (l.issues.length && n.issues.push(...K(u, l.issues)),
                  (n.value[u] = l.value));
            }
          let s;
          for (let u in t) a.has(u) || ((s = s ?? []), s.push(u));
          s &&
            s.length > 0 &&
            n.issues.push({
              code: "unrecognized_keys",
              input: t,
              inst: e,
              keys: s,
            });
        } else {
          n.value = {};
          for (let a of Reflect.ownKeys(t)) {
            if (a === "__proto__") continue;
            let s = r.keyType._zod.run({ value: a, issues: [] }, i);
            if (s instanceof Promise)
              throw new Error(
                "Async schemas not supported in object keys currently",
              );
            if (s.issues.length) {
              (n.issues.push({
                origin: "record",
                code: "invalid_key",
                issues: s.issues.map((l) => ee(l, i, F())),
                input: a,
                path: [a],
                inst: e,
              }),
                (n.value[s.value] = s.value));
              continue;
            }
            let u = r.valueType._zod.run({ value: t[a], issues: [] }, i);
            u instanceof Promise
              ? o.push(
                  u.then((l) => {
                    (l.issues.length && n.issues.push(...K(a, l.issues)),
                      (n.value[s.value] = l.value));
                  }),
                )
              : (u.issues.length && n.issues.push(...K(a, u.issues)),
                (n.value[s.value] = u.value));
          }
        }
        return o.length ? Promise.all(o).then(() => n) : n;
      }));
  }),
  Qo = c("$ZodMap", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let t = n.value;
        if (!(t instanceof Map))
          return (
            n.issues.push({
              expected: "map",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
            n
          );
        let o = [];
        n.value = new Map();
        for (let [a, s] of t) {
          let u = r.keyType._zod.run({ value: a, issues: [] }, i),
            l = r.valueType._zod.run({ value: s, issues: [] }, i);
          u instanceof Promise || l instanceof Promise
            ? o.push(
                Promise.all([u, l]).then(([m, p]) => {
                  hs(m, p, n, a, t, e, i);
                }),
              )
            : hs(u, l, n, a, t, e, i);
        }
        return o.length ? Promise.all(o).then(() => n) : n;
      }));
  });
function hs(e, r, n, i, t, o, a) {
  (e.issues.length &&
    (et.has(typeof i)
      ? n.issues.push(...K(i, e.issues))
      : n.issues.push({
          origin: "map",
          code: "invalid_key",
          input: t,
          inst: o,
          issues: e.issues.map((s) => ee(s, a, F())),
        })),
    r.issues.length &&
      (et.has(typeof i)
        ? n.issues.push(...K(i, r.issues))
        : n.issues.push({
            origin: "map",
            code: "invalid_element",
            input: t,
            inst: o,
            key: i,
            issues: r.issues.map((s) => ee(s, a, F())),
          })),
    n.value.set(e.value, r.value));
}
var ei = c("$ZodSet", (e, r) => {
  (P.init(e, r),
    (e._zod.parse = (n, i) => {
      let t = n.value;
      if (!(t instanceof Set))
        return (
          n.issues.push({
            input: t,
            inst: e,
            expected: "set",
            code: "invalid_type",
          }),
          n
        );
      let o = [];
      n.value = new Set();
      for (let a of t) {
        let s = r.valueType._zod.run({ value: a, issues: [] }, i);
        s instanceof Promise ? o.push(s.then((u) => vs(u, n))) : vs(s, n);
      }
      return o.length ? Promise.all(o).then(() => n) : n;
    }));
});
function vs(e, r) {
  (e.issues.length && r.issues.push(...e.issues), r.value.add(e.value));
}
var ti = c("$ZodEnum", (e, r) => {
    P.init(e, r);
    let n = Ke(r.entries);
    ((e._zod.values = new Set(n)),
      (e._zod.pattern = new RegExp(
        `^(${n
          .filter((i) => et.has(typeof i))
          .map((i) => (typeof i == "string" ? ue(i) : i.toString()))
          .join("|")})$`,
      )),
      (e._zod.parse = (i, t) => {
        let o = i.value;
        return (
          e._zod.values.has(o) ||
            i.issues.push({
              code: "invalid_value",
              values: n,
              input: o,
              inst: e,
            }),
          i
        );
      }));
  }),
  ri = c("$ZodLiteral", (e, r) => {
    (P.init(e, r),
      (e._zod.values = new Set(r.values)),
      (e._zod.pattern = new RegExp(
        `^(${r.values.map((n) => (typeof n == "string" ? ue(n) : n ? n.toString() : String(n))).join("|")})$`,
      )),
      (e._zod.parse = (n, i) => {
        let t = n.value;
        return (
          e._zod.values.has(t) ||
            n.issues.push({
              code: "invalid_value",
              values: r.values,
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  ni = c("$ZodFile", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let t = n.value;
        return (
          t instanceof File ||
            n.issues.push({
              expected: "file",
              code: "invalid_type",
              input: t,
              inst: e,
            }),
          n
        );
      }));
  }),
  oi = c("$ZodTransform", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let t = r.transform(n.value, n);
        if (i.async)
          return (t instanceof Promise ? t : Promise.resolve(t)).then(
            (a) => ((n.value = a), n),
          );
        if (t instanceof Promise) throw new ae();
        return ((n.value = t), n);
      }));
  }),
  ii = c("$ZodOptional", (e, r) => {
    (P.init(e, r),
      (e._zod.optin = "optional"),
      (e._zod.optout = "optional"),
      j(e._zod, "values", () =>
        r.innerType._zod.values
          ? new Set([...r.innerType._zod.values, void 0])
          : void 0,
      ),
      j(e._zod, "pattern", () => {
        let n = r.innerType._zod.pattern;
        return n ? new RegExp(`^(${Je(n.source)})?$`) : void 0;
      }),
      (e._zod.parse = (n, i) =>
        n.value === void 0 ? n : r.innerType._zod.run(n, i)));
  }),
  ai = c("$ZodNullable", (e, r) => {
    (P.init(e, r),
      j(e._zod, "optin", () => r.innerType._zod.optin),
      j(e._zod, "optout", () => r.innerType._zod.optout),
      j(e._zod, "pattern", () => {
        let n = r.innerType._zod.pattern;
        return n ? new RegExp(`^(${Je(n.source)}|null)$`) : void 0;
      }),
      j(e._zod, "values", () =>
        r.innerType._zod.values
          ? new Set([...r.innerType._zod.values, null])
          : void 0,
      ),
      (e._zod.parse = (n, i) =>
        n.value === null ? n : r.innerType._zod.run(n, i)));
  }),
  si = c("$ZodDefault", (e, r) => {
    (P.init(e, r),
      (e._zod.optin = "optional"),
      j(e._zod, "values", () => r.innerType._zod.values),
      (e._zod.parse = (n, i) => {
        if (n.value === void 0) return ((n.value = r.defaultValue), n);
        let t = r.innerType._zod.run(n, i);
        return t instanceof Promise ? t.then((o) => ys(o, r)) : ys(t, r);
      }));
  });
function ys(e, r) {
  return (e.value === void 0 && (e.value = r.defaultValue), e);
}
var li = c("$ZodPrefault", (e, r) => {
    (P.init(e, r),
      (e._zod.optin = "optional"),
      j(e._zod, "values", () => r.innerType._zod.values),
      (e._zod.parse = (n, i) => (
        n.value === void 0 && (n.value = r.defaultValue),
        r.innerType._zod.run(n, i)
      )));
  }),
  ui = c("$ZodNonOptional", (e, r) => {
    (P.init(e, r),
      j(e._zod, "values", () => {
        let n = r.innerType._zod.values;
        return n ? new Set([...n].filter((i) => i !== void 0)) : void 0;
      }),
      (e._zod.parse = (n, i) => {
        let t = r.innerType._zod.run(n, i);
        return t instanceof Promise ? t.then((o) => bs(o, e)) : bs(t, e);
      }));
  });
function bs(e, r) {
  return (
    !e.issues.length &&
      e.value === void 0 &&
      e.issues.push({
        code: "invalid_type",
        expected: "nonoptional",
        input: e.value,
        inst: r,
      }),
    e
  );
}
var ci = c("$ZodSuccess", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => {
        let t = r.innerType._zod.run(n, i);
        return t instanceof Promise
          ? t.then((o) => ((n.value = o.issues.length === 0), n))
          : ((n.value = t.issues.length === 0), n);
      }));
  }),
  _i = c("$ZodCatch", (e, r) => {
    (P.init(e, r),
      j(e._zod, "optin", () => r.innerType._zod.optin),
      j(e._zod, "optout", () => r.innerType._zod.optout),
      j(e._zod, "values", () => r.innerType._zod.values),
      (e._zod.parse = (n, i) => {
        let t = r.innerType._zod.run(n, i);
        return t instanceof Promise
          ? t.then(
              (o) => (
                (n.value = o.value),
                o.issues.length &&
                  ((n.value = r.catchValue({
                    ...n,
                    error: { issues: o.issues.map((a) => ee(a, i, F())) },
                    input: n.value,
                  })),
                  (n.issues = [])),
                n
              ),
            )
          : ((n.value = t.value),
            t.issues.length &&
              ((n.value = r.catchValue({
                ...n,
                error: { issues: t.issues.map((o) => ee(o, i, F())) },
                input: n.value,
              })),
              (n.issues = [])),
            n);
      }));
  }),
  di = c("$ZodNaN", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) => (
        (typeof n.value != "number" || !Number.isNaN(n.value)) &&
          n.issues.push({
            input: n.value,
            inst: e,
            expected: "nan",
            code: "invalid_type",
          }),
        n
      )));
  }),
  ct = c("$ZodPipe", (e, r) => {
    (P.init(e, r),
      j(e._zod, "values", () => r.in._zod.values),
      j(e._zod, "optin", () => r.in._zod.optin),
      j(e._zod, "optout", () => r.out._zod.optout),
      (e._zod.parse = (n, i) => {
        let t = r.in._zod.run(n, i);
        return t instanceof Promise ? t.then((o) => ws(o, r, i)) : ws(t, r, i);
      }));
  });
function ws(e, r, n) {
  return ke(e) ? e : r.out._zod.run({ value: e.value, issues: e.issues }, n);
}
var mi = c("$ZodReadonly", (e, r) => {
  (P.init(e, r),
    j(e._zod, "propValues", () => r.innerType._zod.propValues),
    j(e._zod, "optin", () => r.innerType._zod.optin),
    j(e._zod, "optout", () => r.innerType._zod.optout),
    (e._zod.parse = (n, i) => {
      let t = r.innerType._zod.run(n, i);
      return t instanceof Promise ? t.then(xs) : xs(t);
    }));
});
function xs(e) {
  return ((e.value = Object.freeze(e.value)), e);
}
var pi = c("$ZodTemplateLiteral", (e, r) => {
    P.init(e, r);
    let n = [];
    for (let i of r.parts)
      if (i instanceof P) {
        if (!i._zod.pattern)
          throw new Error(
            `Invalid template literal part, no pattern found: ${[...i._zod.traits].shift()}`,
          );
        let t =
          i._zod.pattern instanceof RegExp
            ? i._zod.pattern.source
            : i._zod.pattern;
        if (!t)
          throw new Error(`Invalid template literal part: ${i._zod.traits}`);
        let o = t.startsWith("^") ? 1 : 0,
          a = t.endsWith("$") ? t.length - 1 : t.length;
        n.push(t.slice(o, a));
      } else if (i === null || _n.has(typeof i)) n.push(ue(`${i}`));
      else throw new Error(`Invalid template literal part: ${i}`);
    ((e._zod.pattern = new RegExp(`^${n.join("")}$`)),
      (e._zod.parse = (i, t) =>
        typeof i.value != "string"
          ? (i.issues.push({
              input: i.value,
              inst: e,
              expected: "template_literal",
              code: "invalid_type",
            }),
            i)
          : ((e._zod.pattern.lastIndex = 0),
            e._zod.pattern.test(i.value) ||
              i.issues.push({
                input: i.value,
                inst: e,
                code: "invalid_format",
                format: "template_literal",
                pattern: e._zod.pattern.source,
              }),
            i)));
  }),
  fi = c("$ZodPromise", (e, r) => {
    (P.init(e, r),
      (e._zod.parse = (n, i) =>
        Promise.resolve(n.value).then((t) =>
          r.innerType._zod.run({ value: t, issues: [] }, i),
        )));
  }),
  gi = c("$ZodLazy", (e, r) => {
    (P.init(e, r),
      j(e._zod, "innerType", () => r.getter()),
      j(e._zod, "pattern", () => e._zod.innerType._zod.pattern),
      j(e._zod, "propValues", () => e._zod.innerType._zod.propValues),
      j(e._zod, "optin", () => e._zod.innerType._zod.optin),
      j(e._zod, "optout", () => e._zod.innerType._zod.optout),
      (e._zod.parse = (n, i) => e._zod.innerType._zod.run(n, i)));
  }),
  hi = c("$ZodCustom", (e, r) => {
    (L.init(e, r),
      P.init(e, r),
      (e._zod.parse = (n, i) => n),
      (e._zod.check = (n) => {
        let i = n.value,
          t = r.fn(i);
        if (t instanceof Promise) return t.then((o) => As(o, n, i, e));
        As(t, n, i, e);
      }));
  });
function As(e, r, n, i) {
  if (!e) {
    let t = {
      code: "custom",
      input: n,
      inst: i,
      path: [...(i._zod.def.path ?? [])],
      continue: !i._zod.def.abort,
    };
    (i._zod.def.params && (t.params = i._zod.def.params), r.issues.push(fn(t)));
  }
}
var _t = {};
xe(_t, {
  ar: () => Ss,
  az: () => Is,
  be: () => Ds,
  ca: () => Es,
  cs: () => Vs,
  de: () => Ts,
  en: () => rr,
  es: () => Os,
  fa: () => js,
  fi: () => Ns,
  fr: () => Ms,
  frCA: () => Us,
  he: () => Rs,
  hu: () => Cs,
  id: () => Ls,
  it: () => Fs,
  ja: () => Zs,
  kh: () => Bs,
  ko: () => qs,
  mk: () => Gs,
  ms: () => Hs,
  nl: () => Ws,
  no: () => Ys,
  ota: () => Ks,
  pl: () => Xs,
  pt: () => Js,
  ru: () => el,
  sl: () => tl,
  sv: () => rl,
  ta: () => nl,
  th: () => ol,
  tr: () => il,
  ua: () => al,
  ur: () => sl,
  vi: () => ll,
  zhCN: () => ul,
  zhTW: () => cl,
});
var fc = () => {
  let e = {
    string: {
      unit: "\u062D\u0631\u0641",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    file: {
      unit: "\u0628\u0627\u064A\u062A",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    array: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
    set: {
      unit: "\u0639\u0646\u0635\u0631",
      verb: "\u0623\u0646 \u064A\u062D\u0648\u064A",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0645\u062F\u062E\u0644",
      email:
        "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
      url: "\u0631\u0627\u0628\u0637",
      emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
      ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
      ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
      cidrv4:
        "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
      cidrv6:
        "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
      base64:
        "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
      base64url:
        "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
      json_string:
        "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
      e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
      jwt: "JWT",
      template_literal: "\u0645\u062F\u062E\u0644",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${t.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${x(t.values[0])}`
          : `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${t.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${o} ${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0635\u0631"}`
          : `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${t.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${t.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${o} ${t.minimum.toString()} ${a.unit}`
          : `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${t.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${t.prefix}"`
          : o.format === "ends_with"
            ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${o.suffix}"`
            : o.format === "includes"
              ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${o.includes}"`
              : o.format === "regex"
                ? `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${o.pattern}`
                : `${i[o.format] ?? t.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
      }
      case "not_multiple_of":
        return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${t.divisor}`;
      case "unrecognized_keys":
        return `\u0645\u0639\u0631\u0641${t.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${t.keys.length > 1 ? "\u0629" : ""}: ${f(t.keys, "\u060C ")}`;
      case "invalid_key":
        return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${t.origin}`;
      case "invalid_union":
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
      case "invalid_element":
        return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${t.origin}`;
      default:
        return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
    }
  };
};
function Ss() {
  return { localeError: fc() };
}
var gc = () => {
  let e = {
    string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "element", verb: "olmal\u0131d\u0131r" },
    set: { unit: "element", verb: "olmal\u0131d\u0131r" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${t.expected}, daxil olan ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${x(t.values[0])}`
          : `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${t.origin ?? "d\u0259y\u0259r"} ${o}${t.maximum.toString()} ${a.unit ?? "element"}`
          : `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${t.origin ?? "d\u0259y\u0259r"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${t.origin} ${o}${t.minimum.toString()} ${a.unit}`
          : `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Yanl\u0131\u015F m\u0259tn: "${o.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`
          : o.format === "ends_with"
            ? `Yanl\u0131\u015F m\u0259tn: "${o.suffix}" il\u0259 bitm\u0259lidir`
            : o.format === "includes"
              ? `Yanl\u0131\u015F m\u0259tn: "${o.includes}" daxil olmal\u0131d\u0131r`
              : o.format === "regex"
                ? `Yanl\u0131\u015F m\u0259tn: ${o.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`
                : `Yanl\u0131\u015F ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Yanl\u0131\u015F \u0259d\u0259d: ${t.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan a\xE7ar${t.keys.length > 1 ? "lar" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
      case "invalid_union":
        return "Yanl\u0131\u015F d\u0259y\u0259r";
      case "invalid_element":
        return `${t.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
      default:
        return "Yanl\u0131\u015F d\u0259y\u0259r";
    }
  };
};
function Is() {
  return { localeError: gc() };
}
function Ps(e, r, n, i) {
  let t = Math.abs(e),
    o = t % 10,
    a = t % 100;
  return a >= 11 && a <= 19 ? i : o === 1 ? r : o >= 2 && o <= 4 ? n : i;
}
var hc = () => {
  let e = {
    string: {
      unit: {
        one: "\u0441\u0456\u043C\u0432\u0430\u043B",
        few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
        many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u044B",
        many: "\u0431\u0430\u0439\u0442\u0430\u045E",
      },
      verb: "\u043C\u0435\u0446\u044C",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u043B\u0456\u043A";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0456\u045E";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0443\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0430\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0447\u0430\u0441",
      duration:
        "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
      cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
      base64:
        "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
      base64url:
        "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
      json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
      e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0443\u0432\u043E\u0434",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${t.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${x(t.values[0])}`
          : `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        if (a) {
          let s = Number(t.maximum),
            u = Ps(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${a.verb} ${o}${t.maximum.toString()} ${u}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        if (a) {
          let s = Number(t.minimum),
            u = Ps(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${a.verb} ${o}${t.minimum.toString()} ${u}`;
        }
        return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${t.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${t.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
      case "invalid_element":
        return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${t.origin}`;
      default:
        return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
    }
  };
};
function Ds() {
  return { localeError: hc() };
}
var vc = () => {
  let e = {
    string: { unit: "car\xE0cters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entrada",
      email: "adre\xE7a electr\xF2nica",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "durada ISO",
      ipv4: "adre\xE7a IPv4",
      ipv6: "adre\xE7a IPv6",
      cidrv4: "rang IPv4",
      cidrv6: "rang IPv6",
      base64: "cadena codificada en base64",
      base64url: "cadena codificada en base64url",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Tipus inv\xE0lid: s'esperava ${t.expected}, s'ha rebut ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Valor inv\xE0lid: s'esperava ${x(t.values[0])}`
          : `Opci\xF3 inv\xE0lida: s'esperava una de ${f(t.values, " o ")}`;
      case "too_big": {
        let o = t.inclusive ? "com a m\xE0xim" : "menys de",
          a = r(t.origin);
        return a
          ? `Massa gran: s'esperava que ${t.origin ?? "el valor"} contingu\xE9s ${o} ${t.maximum.toString()} ${a.unit ?? "elements"}`
          : `Massa gran: s'esperava que ${t.origin ?? "el valor"} fos ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? "com a m\xEDnim" : "m\xE9s de",
          a = r(t.origin);
        return a
          ? `Massa petit: s'esperava que ${t.origin} contingu\xE9s ${o} ${t.minimum.toString()} ${a.unit}`
          : `Massa petit: s'esperava que ${t.origin} fos ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Format inv\xE0lid: ha de comen\xE7ar amb "${o.prefix}"`
          : o.format === "ends_with"
            ? `Format inv\xE0lid: ha d'acabar amb "${o.suffix}"`
            : o.format === "includes"
              ? `Format inv\xE0lid: ha d'incloure "${o.includes}"`
              : o.format === "regex"
                ? `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${o.pattern}`
                : `Format inv\xE0lid per a ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Clau${t.keys.length > 1 ? "s" : ""} no reconeguda${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Clau inv\xE0lida a ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE0lida";
      case "invalid_element":
        return `Element inv\xE0lid a ${t.origin}`;
      default:
        return "Entrada inv\xE0lida";
    }
  };
};
function Es() {
  return { localeError: vc() };
}
var yc = () => {
  let e = {
    string: { unit: "znak\u016F", verb: "m\xEDt" },
    file: { unit: "bajt\u016F", verb: "m\xEDt" },
    array: { unit: "prvk\u016F", verb: "m\xEDt" },
    set: { unit: "prvk\u016F", verb: "m\xEDt" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u010D\xEDslo";
        case "string":
          return "\u0159et\u011Bzec";
        case "boolean":
          return "boolean";
        case "bigint":
          return "bigint";
        case "function":
          return "funkce";
        case "symbol":
          return "symbol";
        case "undefined":
          return "undefined";
        case "object": {
          if (Array.isArray(t)) return "pole";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "regul\xE1rn\xED v\xFDraz",
      email: "e-mailov\xE1 adresa",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "datum a \u010Das ve form\xE1tu ISO",
      date: "datum ve form\xE1tu ISO",
      time: "\u010Das ve form\xE1tu ISO",
      duration: "doba trv\xE1n\xED ISO",
      ipv4: "IPv4 adresa",
      ipv6: "IPv6 adresa",
      cidrv4: "rozsah IPv4",
      cidrv6: "rozsah IPv6",
      base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
      base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
      json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
      e164: "\u010D\xEDslo E.164",
      jwt: "JWT",
      template_literal: "vstup",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${t.expected}, obdr\u017Eeno ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${x(t.values[0])}`
          : `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${t.origin ?? "hodnota"} mus\xED m\xEDt ${o}${t.maximum.toString()} ${a.unit ?? "prvk\u016F"}`
          : `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${t.origin ?? "hodnota"} mus\xED b\xFDt ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${t.origin ?? "hodnota"} mus\xED m\xEDt ${o}${t.minimum.toString()} ${a.unit ?? "prvk\u016F"}`
          : `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${t.origin ?? "hodnota"} mus\xED b\xFDt ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${o.prefix}"`
          : o.format === "ends_with"
            ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${o.suffix}"`
            : o.format === "includes"
              ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${o.includes}"`
              : o.format === "regex"
                ? `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${o.pattern}`
                : `Neplatn\xFD form\xE1t ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${t.divisor}`;
      case "unrecognized_keys":
        return `Nezn\xE1m\xE9 kl\xED\u010De: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn\xFD kl\xED\u010D v ${t.origin}`;
      case "invalid_union":
        return "Neplatn\xFD vstup";
      case "invalid_element":
        return `Neplatn\xE1 hodnota v ${t.origin}`;
      default:
        return "Neplatn\xFD vstup";
    }
  };
};
function Vs() {
  return { localeError: yc() };
}
var bc = () => {
  let e = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "Zahl";
        case "object": {
          if (Array.isArray(t)) return "Array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "Eingabe",
      email: "E-Mail-Adresse",
      url: "URL",
      emoji: "Emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-Datum und -Uhrzeit",
      date: "ISO-Datum",
      time: "ISO-Uhrzeit",
      duration: "ISO-Dauer",
      ipv4: "IPv4-Adresse",
      ipv6: "IPv6-Adresse",
      cidrv4: "IPv4-Bereich",
      cidrv6: "IPv6-Bereich",
      base64: "Base64-codierter String",
      base64url: "Base64-URL-codierter String",
      json_string: "JSON-String",
      e164: "E.164-Nummer",
      jwt: "JWT",
      template_literal: "Eingabe",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ung\xFCltige Eingabe: erwartet ${t.expected}, erhalten ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ung\xFCltige Eingabe: erwartet ${x(t.values[0])}`
          : `Ung\xFCltige Option: erwartet eine von ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Zu gro\xDF: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ${a.unit ?? "Elemente"} hat`
          : `Zu gro\xDF: erwartet, dass ${t.origin ?? "Wert"} ${o}${t.maximum.toString()} ist`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ${a.unit} hat`
          : `Zu klein: erwartet, dass ${t.origin} ${o}${t.minimum.toString()} ist`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ung\xFCltiger String: muss mit "${o.prefix}" beginnen`
          : o.format === "ends_with"
            ? `Ung\xFCltiger String: muss mit "${o.suffix}" enden`
            : o.format === "includes"
              ? `Ung\xFCltiger String: muss "${o.includes}" enthalten`
              : o.format === "regex"
                ? `Ung\xFCltiger String: muss dem Muster ${o.pattern} entsprechen`
                : `Ung\xFCltig: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ung\xFCltige Zahl: muss ein Vielfaches von ${t.divisor} sein`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Ung\xFCltiger Schl\xFCssel in ${t.origin}`;
      case "invalid_union":
        return "Ung\xFCltige Eingabe";
      case "invalid_element":
        return `Ung\xFCltiger Wert in ${t.origin}`;
      default:
        return "Ung\xFCltige Eingabe";
    }
  };
};
function Ts() {
  return { localeError: bc() };
}
var wc = (e) => {
    let r = typeof e;
    switch (r) {
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(e)) return "array";
        if (e === null) return "null";
        if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
          return e.constructor.name;
      }
    }
    return r;
  },
  xc = () => {
    let e = {
      string: { unit: "characters", verb: "to have" },
      file: { unit: "bytes", verb: "to have" },
      array: { unit: "items", verb: "to have" },
      set: { unit: "items", verb: "to have" },
    };
    function r(i) {
      return e[i] ?? null;
    }
    let n = {
      regex: "input",
      email: "email address",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datetime",
      date: "ISO date",
      time: "ISO time",
      duration: "ISO duration",
      ipv4: "IPv4 address",
      ipv6: "IPv6 address",
      cidrv4: "IPv4 range",
      cidrv6: "IPv6 range",
      base64: "base64-encoded string",
      base64url: "base64url-encoded string",
      json_string: "JSON string",
      e164: "E.164 number",
      jwt: "JWT",
      template_literal: "input",
    };
    return (i) => {
      switch (i.code) {
        case "invalid_type":
          return `Invalid input: expected ${i.expected}, received ${wc(i.input)}`;
        case "invalid_value":
          return i.values.length === 1
            ? `Invalid input: expected ${x(i.values[0])}`
            : `Invalid option: expected one of ${f(i.values, "|")}`;
        case "too_big": {
          let t = i.inclusive ? "<=" : "<",
            o = r(i.origin);
          return o
            ? `Too big: expected ${i.origin ?? "value"} to have ${t}${i.maximum.toString()} ${o.unit ?? "elements"}`
            : `Too big: expected ${i.origin ?? "value"} to be ${t}${i.maximum.toString()}`;
        }
        case "too_small": {
          let t = i.inclusive ? ">=" : ">",
            o = r(i.origin);
          return o
            ? `Too small: expected ${i.origin} to have ${t}${i.minimum.toString()} ${o.unit}`
            : `Too small: expected ${i.origin} to be ${t}${i.minimum.toString()}`;
        }
        case "invalid_format": {
          let t = i;
          return t.format === "starts_with"
            ? `Invalid string: must start with "${t.prefix}"`
            : t.format === "ends_with"
              ? `Invalid string: must end with "${t.suffix}"`
              : t.format === "includes"
                ? `Invalid string: must include "${t.includes}"`
                : t.format === "regex"
                  ? `Invalid string: must match pattern ${t.pattern}`
                  : `Invalid ${n[t.format] ?? i.format}`;
        }
        case "not_multiple_of":
          return `Invalid number: must be a multiple of ${i.divisor}`;
        case "unrecognized_keys":
          return `Unrecognized key${i.keys.length > 1 ? "s" : ""}: ${f(i.keys, ", ")}`;
        case "invalid_key":
          return `Invalid key in ${i.origin}`;
        case "invalid_union":
          return "Invalid input";
        case "invalid_element":
          return `Invalid value in ${i.origin}`;
        default:
          return "Invalid input";
      }
    };
  };
function rr() {
  return { localeError: xc() };
}
var Ac = () => {
  let e = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "n\xFAmero";
        case "object": {
          if (Array.isArray(t)) return "arreglo";
          if (t === null) return "nulo";
          if (Object.getPrototypeOf(t) !== Object.prototype)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entrada",
      email: "direcci\xF3n de correo electr\xF3nico",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "fecha y hora ISO",
      date: "fecha ISO",
      time: "hora ISO",
      duration: "duraci\xF3n ISO",
      ipv4: "direcci\xF3n IPv4",
      ipv6: "direcci\xF3n IPv6",
      cidrv4: "rango IPv4",
      cidrv6: "rango IPv6",
      base64: "cadena codificada en base64",
      base64url: "URL codificada en base64",
      json_string: "cadena JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entrada inv\xE1lida: se esperaba ${t.expected}, recibido ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entrada inv\xE1lida: se esperaba ${x(t.values[0])}`
          : `Opci\xF3n inv\xE1lida: se esperaba una de ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Demasiado grande: se esperaba que ${t.origin ?? "valor"} tuviera ${o}${t.maximum.toString()} ${a.unit ?? "elementos"}`
          : `Demasiado grande: se esperaba que ${t.origin ?? "valor"} fuera ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Demasiado peque\xF1o: se esperaba que ${t.origin} tuviera ${o}${t.minimum.toString()} ${a.unit}`
          : `Demasiado peque\xF1o: se esperaba que ${t.origin} fuera ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cadena inv\xE1lida: debe comenzar con "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cadena inv\xE1lida: debe terminar en "${o.suffix}"`
            : o.format === "includes"
              ? `Cadena inv\xE1lida: debe incluir "${o.includes}"`
              : o.format === "regex"
                ? `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${o.pattern}`
                : `Inv\xE1lido ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Llave${t.keys.length > 1 ? "s" : ""} desconocida${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Llave inv\xE1lida en ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido en ${t.origin}`;
      default:
        return "Entrada inv\xE1lida";
    }
  };
};
function Os() {
  return { localeError: Ac() };
}
var kc = () => {
  let e = {
    string: {
      unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    file: {
      unit: "\u0628\u0627\u06CC\u062A",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    array: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
    set: {
      unit: "\u0622\u06CC\u062A\u0645",
      verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0639\u062F\u062F";
        case "object": {
          if (Array.isArray(t)) return "\u0622\u0631\u0627\u06CC\u0647";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0648\u0631\u0648\u062F\u06CC",
      email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
      url: "URL",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
      time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      duration:
        "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
      ipv4: "IPv4 \u0622\u062F\u0631\u0633",
      ipv6: "IPv6 \u0622\u062F\u0631\u0633",
      cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
      cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
      base64: "base64-encoded \u0631\u0634\u062A\u0647",
      base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
      json_string: "JSON \u0631\u0634\u062A\u0647",
      e164: "E.164 \u0639\u062F\u062F",
      jwt: "JWT",
      template_literal: "\u0648\u0631\u0648\u062F\u06CC",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${t.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${n(t.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${x(t.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`
          : `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${f(t.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${t.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${o}${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`
          : `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${t.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${o}${t.maximum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${t.origin} \u0628\u0627\u06CC\u062F ${o}${t.minimum.toString()} ${a.unit} \u0628\u0627\u0634\u062F`
          : `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${t.origin} \u0628\u0627\u06CC\u062F ${o}${t.minimum.toString()} \u0628\u0627\u0634\u062F`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${o.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`
          : o.format === "ends_with"
            ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${o.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`
            : o.format === "includes"
              ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${o.includes}" \u0628\u0627\u0634\u062F`
              : o.format === "regex"
                ? `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${o.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`
                : `${i[o.format] ?? t.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
      }
      case "not_multiple_of":
        return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${t.divisor} \u0628\u0627\u0634\u062F`;
      case "unrecognized_keys":
        return `\u06A9\u0644\u06CC\u062F${t.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${t.origin}`;
      case "invalid_union":
        return "\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631";
      case "invalid_element":
        return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${t.origin}`;
      default:
        return "\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631";
    }
  };
};
function js() {
  return { localeError: kc() };
}
var $c = () => {
  let e = {
    string: { unit: "merkki\xE4", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "s\xE4\xE4nn\xF6llinen lauseke",
      email: "s\xE4hk\xF6postiosoite",
      url: "URL-osoite",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-aikaleima",
      date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
      time: "ISO-aika",
      duration: "ISO-kesto",
      ipv4: "IPv4-osoite",
      ipv6: "IPv6-osoite",
      cidrv4: "IPv4-alue",
      cidrv6: "IPv6-alue",
      base64: "base64-koodattu merkkijono",
      base64url: "base64url-koodattu merkkijono",
      json_string: "JSON-merkkijono",
      e164: "E.164-luku",
      jwt: "JWT",
      template_literal: "templaattimerkkijono",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${t.expected}, oli ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Virheellinen sy\xF6te: t\xE4ytyy olla ${x(t.values[0])}`
          : `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Liian suuri: ${a.subject} t\xE4ytyy olla ${o}${t.maximum.toString()} ${a.unit}`.trim()
          : `Liian suuri: arvon t\xE4ytyy olla ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Liian pieni: ${a.subject} t\xE4ytyy olla ${o}${t.minimum.toString()} ${a.unit}`.trim()
          : `Liian pieni: arvon t\xE4ytyy olla ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${o.prefix}"`
          : o.format === "ends_with"
            ? `Virheellinen sy\xF6te: t\xE4ytyy loppua "${o.suffix}"`
            : o.format === "includes"
              ? `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${o.includes}"`
              : o.format === "regex"
                ? `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${o.pattern}`
                : `Virheellinen ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: t\xE4ytyy olla luvun ${t.divisor} monikerta`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen sy\xF6te";
    }
  };
};
function Ns() {
  return { localeError: $c() };
}
var zc = () => {
  let e = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "nombre";
        case "object": {
          if (Array.isArray(t)) return "tableau";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entr\xE9e",
      email: "adresse e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date et heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : ${t.expected} attendu, ${n(t.input)} re\xE7u`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entr\xE9e invalide : ${x(t.values[0])} attendu`
          : `Option invalide : une valeur parmi ${f(t.values, "|")} attendue`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Trop grand : ${t.origin ?? "valeur"} doit ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "\xE9l\xE9ment(s)"}`
          : `Trop grand : ${t.origin ?? "valeur"} doit \xEAtre ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Trop petit : ${t.origin} doit ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Trop petit : ${t.origin} doit \xEAtre ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cha\xEEne invalide : doit commencer par "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cha\xEEne invalide : doit se terminer par "${o.suffix}"`
            : o.format === "includes"
              ? `Cha\xEEne invalide : doit inclure "${o.includes}"`
              : o.format === "regex"
                ? `Cha\xEEne invalide : doit correspondre au mod\xE8le ${o.pattern}`
                : `${i[o.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entr\xE9e invalide";
    }
  };
};
function Ms() {
  return { localeError: zc() };
}
var Sc = () => {
  let e = {
    string: { unit: "caract\xE8res", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "\xE9l\xE9ments", verb: "avoir" },
    set: { unit: "\xE9l\xE9ments", verb: "avoir" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "entr\xE9e",
      email: "adresse courriel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "date-heure ISO",
      date: "date ISO",
      time: "heure ISO",
      duration: "dur\xE9e ISO",
      ipv4: "adresse IPv4",
      ipv6: "adresse IPv6",
      cidrv4: "plage IPv4",
      cidrv6: "plage IPv6",
      base64: "cha\xEEne encod\xE9e en base64",
      base64url: "cha\xEEne encod\xE9e en base64url",
      json_string: "cha\xEEne JSON",
      e164: "num\xE9ro E.164",
      jwt: "JWT",
      template_literal: "entr\xE9e",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Entr\xE9e invalide : attendu ${t.expected}, re\xE7u ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entr\xE9e invalide : attendu ${x(t.values[0])}`
          : `Option invalide : attendu l'une des valeurs suivantes ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "\u2264" : "<",
          a = r(t.origin);
        return a
          ? `Trop grand : attendu que ${t.origin ?? "la valeur"} ait ${o}${t.maximum.toString()} ${a.unit}`
          : `Trop grand : attendu que ${t.origin ?? "la valeur"} soit ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? "\u2265" : ">",
          a = r(t.origin);
        return a
          ? `Trop petit : attendu que ${t.origin} ait ${o}${t.minimum.toString()} ${a.unit}`
          : `Trop petit : attendu que ${t.origin} soit ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Cha\xEEne invalide : doit commencer par "${o.prefix}"`
          : o.format === "ends_with"
            ? `Cha\xEEne invalide : doit se terminer par "${o.suffix}"`
            : o.format === "includes"
              ? `Cha\xEEne invalide : doit inclure "${o.includes}"`
              : o.format === "regex"
                ? `Cha\xEEne invalide : doit correspondre au motif ${o.pattern}`
                : `${i[o.format] ?? t.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit \xEAtre un multiple de ${t.divisor}`;
      case "unrecognized_keys":
        return `Cl\xE9${t.keys.length > 1 ? "s" : ""} non reconnue${t.keys.length > 1 ? "s" : ""} : ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Cl\xE9 invalide dans ${t.origin}`;
      case "invalid_union":
        return "Entr\xE9e invalide";
      case "invalid_element":
        return `Valeur invalide dans ${t.origin}`;
      default:
        return "Entr\xE9e invalide";
    }
  };
};
function Us() {
  return { localeError: Sc() };
}
var Ic = () => {
  let e = {
    string: {
      unit: "\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    file: {
      unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    array: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
    set: {
      unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD",
      verb: "\u05DC\u05DB\u05DC\u05D5\u05DC",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u05E7\u05DC\u05D8",
      email:
        "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC",
      url: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA",
      emoji: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO",
      date: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO",
      time: "\u05D6\u05DE\u05DF ISO",
      duration: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO",
      ipv4: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4",
      ipv6: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6",
      cidrv4: "\u05D8\u05D5\u05D5\u05D7 IPv4",
      cidrv6: "\u05D8\u05D5\u05D5\u05D7 IPv6",
      base64:
        "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64",
      base64url:
        "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA",
      json_string: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON",
      e164: "\u05DE\u05E1\u05E4\u05E8 E.164",
      jwt: "JWT",
      template_literal: "\u05E7\u05DC\u05D8",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${t.expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA ${x(t.values[0])}`
          : `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05D0\u05D7\u05EA \u05DE\u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA  ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${t.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.maximum.toString()} ${a.unit ?? "elements"}`
          : `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${t.origin ?? "value"} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${t.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.minimum.toString()} ${a.unit}`
          : `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${t.origin} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1"${o.prefix}"`
          : o.format === "ends_with"
            ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${o.suffix}"`
            : o.format === "includes"
              ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${o.includes}"`
              : o.format === "regex"
                ? `\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05E0\u05D4: \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${o.pattern}`
                : `${i[o.format] ?? t.format} \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
      }
      case "not_multiple_of":
        return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${t.divisor}`;
      case "unrecognized_keys":
        return `\u05DE\u05E4\u05EA\u05D7${t.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${t.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u05DE\u05E4\u05EA\u05D7 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${t.origin}`;
      case "invalid_union":
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
      case "invalid_element":
        return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${t.origin}`;
      default:
        return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
    }
  };
};
function Rs() {
  return { localeError: Ic() };
}
var Pc = () => {
  let e = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "sz\xE1m";
        case "object": {
          if (Array.isArray(t)) return "t\xF6mb";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "bemenet",
      email: "email c\xEDm",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO id\u0151b\xE9lyeg",
      date: "ISO d\xE1tum",
      time: "ISO id\u0151",
      duration: "ISO id\u0151intervallum",
      ipv4: "IPv4 c\xEDm",
      ipv6: "IPv6 c\xEDm",
      cidrv4: "IPv4 tartom\xE1ny",
      cidrv6: "IPv6 tartom\xE1ny",
      base64: "base64-k\xF3dolt string",
      base64url: "base64url-k\xF3dolt string",
      json_string: "JSON string",
      e164: "E.164 sz\xE1m",
      jwt: "JWT",
      template_literal: "bemenet",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${t.expected}, a kapott \xE9rt\xE9k ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${x(t.values[0])}`
          : `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `T\xFAl nagy: ${t.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${o}${t.maximum.toString()} ${a.unit ?? "elem"}`
          : `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${t.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${t.origin} m\xE9rete t\xFAl kicsi ${o}${t.minimum.toString()} ${a.unit}`
          : `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${t.origin} t\xFAl kicsi ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\xC9rv\xE9nytelen string: "${o.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`
          : o.format === "ends_with"
            ? `\xC9rv\xE9nytelen string: "${o.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`
            : o.format === "includes"
              ? `\xC9rv\xE9nytelen string: "${o.includes}" \xE9rt\xE9ket kell tartalmaznia`
              : o.format === "regex"
                ? `\xC9rv\xE9nytelen string: ${o.pattern} mint\xE1nak kell megfelelnie`
                : `\xC9rv\xE9nytelen ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\xC9rv\xE9nytelen sz\xE1m: ${t.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\xC9rv\xE9nytelen kulcs ${t.origin}`;
      case "invalid_union":
        return "\xC9rv\xE9nytelen bemenet";
      case "invalid_element":
        return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${t.origin}`;
      default:
        return "\xC9rv\xE9nytelen bemenet";
    }
  };
};
function Cs() {
  return { localeError: Pc() };
}
var Dc = () => {
  let e = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "alamat email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tanggal dan waktu format ISO",
      date: "tanggal format ISO",
      time: "jam format ISO",
      duration: "durasi format ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "rentang alamat IPv4",
      cidrv6: "rentang alamat IPv6",
      base64: "string dengan enkode base64",
      base64url: "string dengan enkode base64url",
      json_string: "string JSON",
      e164: "angka E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${t.expected}, diterima ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input tidak valid: diharapkan ${x(t.values[0])}`
          : `Pilihan tidak valid: diharapkan salah satu dari ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Terlalu besar: diharapkan ${t.origin ?? "value"} memiliki ${o}${t.maximum.toString()} ${a.unit ?? "elemen"}`
          : `Terlalu besar: diharapkan ${t.origin ?? "value"} menjadi ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Terlalu kecil: diharapkan ${t.origin} memiliki ${o}${t.minimum.toString()} ${a.unit}`
          : `Terlalu kecil: diharapkan ${t.origin} menjadi ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `String tidak valid: harus dimulai dengan "${o.prefix}"`
          : o.format === "ends_with"
            ? `String tidak valid: harus berakhir dengan "${o.suffix}"`
            : o.format === "includes"
              ? `String tidak valid: harus menyertakan "${o.includes}"`
              : o.format === "regex"
                ? `String tidak valid: harus sesuai pola ${o.pattern}`
                : `${i[o.format] ?? t.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${t.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${t.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function Ls() {
  return { localeError: Dc() };
}
var Ec = () => {
  let e = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "numero";
        case "object": {
          if (Array.isArray(t)) return "vettore";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "indirizzo email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e ora ISO",
      date: "data ISO",
      time: "ora ISO",
      duration: "durata ISO",
      ipv4: "indirizzo IPv4",
      ipv6: "indirizzo IPv6",
      cidrv4: "intervallo IPv4",
      cidrv6: "intervallo IPv6",
      base64: "stringa codificata in base64",
      base64url: "URL codificata in base64",
      json_string: "stringa JSON",
      e164: "numero E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input non valido: atteso ${t.expected}, ricevuto ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input non valido: atteso ${x(t.values[0])}`
          : `Opzione non valida: atteso uno tra ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Troppo grande: ${t.origin ?? "valore"} deve avere ${o}${t.maximum.toString()} ${a.unit ?? "elementi"}`
          : `Troppo grande: ${t.origin ?? "valore"} deve essere ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Troppo piccolo: ${t.origin} deve avere ${o}${t.minimum.toString()} ${a.unit}`
          : `Troppo piccolo: ${t.origin} deve essere ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Stringa non valida: deve iniziare con "${o.prefix}"`
          : o.format === "ends_with"
            ? `Stringa non valida: deve terminare con "${o.suffix}"`
            : o.format === "includes"
              ? `Stringa non valida: deve includere "${o.includes}"`
              : o.format === "regex"
                ? `Stringa non valida: deve corrispondere al pattern ${o.pattern}`
                : `Invalid ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${t.divisor}`;
      case "unrecognized_keys":
        return `Chiav${t.keys.length > 1 ? "i" : "e"} non riconosciut${t.keys.length > 1 ? "e" : "a"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${t.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${t.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function Fs() {
  return { localeError: Ec() };
}
var Vc = () => {
  let e = {
    string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
    file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
    array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
    set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u6570\u5024";
        case "object": {
          if (Array.isArray(t)) return "\u914D\u5217";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u5165\u529B\u5024",
      email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
      url: "URL",
      emoji: "\u7D75\u6587\u5B57",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u6642",
      date: "ISO\u65E5\u4ED8",
      time: "ISO\u6642\u523B",
      duration: "ISO\u671F\u9593",
      ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
      ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
      cidrv4: "IPv4\u7BC4\u56F2",
      cidrv6: "IPv6\u7BC4\u56F2",
      base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
      json_string: "JSON\u6587\u5B57\u5217",
      e164: "E.164\u756A\u53F7",
      jwt: "JWT",
      template_literal: "\u5165\u529B\u5024",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u7121\u52B9\u306A\u5165\u529B: ${t.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${n(t.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u7121\u52B9\u306A\u5165\u529B: ${x(t.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`
          : `\u7121\u52B9\u306A\u9078\u629E: ${f(t.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u5927\u304D\u3059\u304E\u308B\u5024: ${t.origin ?? "\u5024"}\u306F${t.maximum.toString()}${a.unit ?? "\u8981\u7D20"}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : `\u5927\u304D\u3059\u304E\u308B\u5024: ${t.origin ?? "\u5024"}\u306F${t.maximum.toString()}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${t.origin}\u306F${t.minimum.toString()}${a.unit}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${t.origin}\u306F${t.minimum.toString()}${o}\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
          : o.format === "ends_with"
            ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
            : o.format === "includes"
              ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${o.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
              : o.format === "regex"
                ? `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${o.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`
                : `\u7121\u52B9\u306A${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u52B9\u306A\u6570\u5024: ${t.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
      case "unrecognized_keys":
        return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${t.keys.length > 1 ? "\u7FA4" : ""}: ${f(t.keys, "\u3001")}`;
      case "invalid_key":
        return `${t.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
      case "invalid_union":
        return "\u7121\u52B9\u306A\u5165\u529B";
      case "invalid_element":
        return `${t.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
      default:
        return "\u7121\u52B9\u306A\u5165\u529B";
    }
  };
};
function Zs() {
  return { localeError: Vc() };
}
var Tc = () => {
  let e = {
    string: {
      unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    file: {
      unit: "\u1794\u17C3",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    array: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
    set: {
      unit: "\u1792\u17B6\u178F\u17BB",
      verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)"
            : "\u179B\u17C1\u1781";
        case "object": {
          if (Array.isArray(t)) return "\u17A2\u17B6\u179A\u17C1 (Array)";
          if (t === null)
            return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex:
        "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
      email:
        "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
      url: "URL",
      emoji:
        "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
      date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
      time: "\u1798\u17C9\u17C4\u1784 ISO",
      duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
      ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      cidrv4:
        "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
      cidrv6:
        "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
      base64:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
      base64url:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
      json_string:
        "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
      e164: "\u179B\u17C1\u1781 E.164",
      jwt: "JWT",
      template_literal:
        "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${x(t.values[0])}`
          : `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${o} ${t.maximum.toString()} ${a.unit ?? "\u1792\u17B6\u178F\u17BB"}`
          : `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin} ${o} ${t.minimum.toString()} ${a.unit}`
          : `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${t.origin} ${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${o.suffix}"`
            : o.format === "includes"
              ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${o.includes}"`
              : o.format === "regex"
                ? `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${o.pattern}`
                : `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${t.divisor}`;
      case "unrecognized_keys":
        return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${t.origin}`;
      case "invalid_union":
        return "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C";
      case "invalid_element":
        return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${t.origin}`;
      default:
        return "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C";
    }
  };
};
function Bs() {
  return { localeError: Tc() };
}
var Oc = () => {
  let e = {
    string: { unit: "\uBB38\uC790", verb: "to have" },
    file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
    array: { unit: "\uAC1C", verb: "to have" },
    set: { unit: "\uAC1C", verb: "to have" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\uC785\uB825",
      email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
      url: "URL",
      emoji: "\uC774\uBAA8\uC9C0",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
      date: "ISO \uB0A0\uC9DC",
      time: "ISO \uC2DC\uAC04",
      duration: "ISO \uAE30\uAC04",
      ipv4: "IPv4 \uC8FC\uC18C",
      ipv6: "IPv6 \uC8FC\uC18C",
      cidrv4: "IPv4 \uBC94\uC704",
      cidrv6: "IPv6 \uBC94\uC704",
      base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
      json_string: "JSON \uBB38\uC790\uC5F4",
      e164: "E.164 \uBC88\uD638",
      jwt: "JWT",
      template_literal: "\uC785\uB825",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${t.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${n(t.input)}\uC785\uB2C8\uB2E4`;
      case "invalid_value":
        return t.values.length === 1
          ? `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${x(t.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`
          : `\uC798\uBABB\uB41C \uC635\uC158: ${f(t.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "too_big": {
        let o = t.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC",
          a =
            o === "\uBBF8\uB9CC"
              ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
              : "\uC5EC\uC57C \uD569\uB2C8\uB2E4",
          s = r(t.origin),
          u = s?.unit ?? "\uC694\uC18C";
        return s
          ? `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${t.maximum.toString()}${u} ${o}${a}`
          : `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${t.maximum.toString()} ${o}${a}`;
      }
      case "too_small": {
        let o = t.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC",
          a =
            o === "\uC774\uC0C1"
              ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4"
              : "\uC5EC\uC57C \uD569\uB2C8\uB2E4",
          s = r(t.origin),
          u = s?.unit ?? "\uC694\uC18C";
        return s
          ? `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${t.minimum.toString()}${u} ${o}${a}`
          : `${t.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${t.minimum.toString()} ${o}${a}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`
          : o.format === "ends_with"
            ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`
            : o.format === "includes"
              ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${o.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`
              : o.format === "regex"
                ? `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${o.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`
                : `\uC798\uBABB\uB41C ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\uC798\uBABB\uB41C \uC22B\uC790: ${t.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
      case "unrecognized_keys":
        return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\uC798\uBABB\uB41C \uD0A4: ${t.origin}`;
      case "invalid_union":
        return "\uC798\uBABB\uB41C \uC785\uB825";
      case "invalid_element":
        return `\uC798\uBABB\uB41C \uAC12: ${t.origin}`;
      default:
        return "\uC798\uBABB\uB41C \uC785\uB825";
    }
  };
};
function qs() {
  return { localeError: Oc() };
}
var jc = () => {
  let e = {
    string: {
      unit: "\u0437\u043D\u0430\u0446\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    file: {
      unit: "\u0431\u0430\u0458\u0442\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    array: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
    set: {
      unit: "\u0441\u0442\u0430\u0432\u043A\u0438",
      verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0431\u0440\u043E\u0458";
        case "object": {
          if (Array.isArray(t)) return "\u043D\u0438\u0437\u0430";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u043D\u0435\u0441",
      email:
        "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u045F\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
      date: "ISO \u0434\u0430\u0442\u0443\u043C",
      time: "ISO \u0432\u0440\u0435\u043C\u0435",
      duration:
        "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
      cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
      cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
      base64:
        "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      base64url:
        "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
      json_string: "JSON \u043D\u0438\u0437\u0430",
      e164: "E.164 \u0431\u0440\u043E\u0458",
      jwt: "JWT",
      template_literal: "\u0432\u043D\u0435\u0441",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Invalid input: expected ${x(t.values[0])}`
          : `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${o}${t.maximum.toString()} ${a.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`
          : `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin} \u0434\u0430 \u0438\u043C\u0430 ${o}${t.minimum.toString()} ${a.unit}`
          : `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${t.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${o.pattern}`
                : `Invalid ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${t.origin}`;
      case "invalid_union":
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
      case "invalid_element":
        return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${t.origin}`;
      default:
        return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
    }
  };
};
function Gs() {
  return { localeError: jc() };
}
var Nc = () => {
  let e = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "nombor";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "alamat e-mel",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "tarikh masa ISO",
      date: "tarikh ISO",
      time: "masa ISO",
      duration: "tempoh ISO",
      ipv4: "alamat IPv4",
      ipv6: "alamat IPv6",
      cidrv4: "julat IPv4",
      cidrv6: "julat IPv6",
      base64: "string dikodkan base64",
      base64url: "string dikodkan base64url",
      json_string: "string JSON",
      e164: "nombor E.164",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${t.expected}, diterima ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Input tidak sah: dijangka ${x(t.values[0])}`
          : `Pilihan tidak sah: dijangka salah satu daripada ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Terlalu besar: dijangka ${t.origin ?? "nilai"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "elemen"}`
          : `Terlalu besar: dijangka ${t.origin ?? "nilai"} adalah ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Terlalu kecil: dijangka ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Terlalu kecil: dijangka ${t.origin} adalah ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `String tidak sah: mesti bermula dengan "${o.prefix}"`
          : o.format === "ends_with"
            ? `String tidak sah: mesti berakhir dengan "${o.suffix}"`
            : o.format === "includes"
              ? `String tidak sah: mesti mengandungi "${o.includes}"`
              : o.format === "regex"
                ? `String tidak sah: mesti sepadan dengan corak ${o.pattern}`
                : `${i[o.format] ?? t.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${t.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${t.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${t.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function Hs() {
  return { localeError: Nc() };
}
var Mc = () => {
  let e = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "getal";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "invoer",
      email: "emailadres",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum en tijd",
      date: "ISO datum",
      time: "ISO tijd",
      duration: "ISO duur",
      ipv4: "IPv4-adres",
      ipv6: "IPv6-adres",
      cidrv4: "IPv4-bereik",
      cidrv6: "IPv6-bereik",
      base64: "base64-gecodeerde tekst",
      base64url: "base64 URL-gecodeerde tekst",
      json_string: "JSON string",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "invoer",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${t.expected}, ontving ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ongeldige invoer: verwacht ${x(t.values[0])}`
          : `Ongeldige optie: verwacht \xE9\xE9n van ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} ${a.unit ?? "elementen"} bevat`
          : `Te lang: verwacht dat ${t.origin ?? "waarde"} ${o}${t.maximum.toString()} is`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} ${a.unit} bevat`
          : `Te kort: verwacht dat ${t.origin} ${o}${t.minimum.toString()} is`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ongeldige tekst: moet met "${o.prefix}" beginnen`
          : o.format === "ends_with"
            ? `Ongeldige tekst: moet op "${o.suffix}" eindigen`
            : o.format === "includes"
              ? `Ongeldige tekst: moet "${o.includes}" bevatten`
              : o.format === "regex"
                ? `Ongeldige tekst: moet overeenkomen met patroon ${o.pattern}`
                : `Ongeldig: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${t.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${t.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${t.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Ws() {
  return { localeError: Mc() };
}
var Uc = () => {
  let e = {
    string: { unit: "tegn", verb: "\xE5 ha" },
    file: { unit: "bytes", verb: "\xE5 ha" },
    array: { unit: "elementer", verb: "\xE5 inneholde" },
    set: { unit: "elementer", verb: "\xE5 inneholde" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "tall";
        case "object": {
          if (Array.isArray(t)) return "liste";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "input",
      email: "e-postadresse",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO dato- og klokkeslett",
      date: "ISO-dato",
      time: "ISO-klokkeslett",
      duration: "ISO-varighet",
      ipv4: "IPv4-omr\xE5de",
      ipv6: "IPv6-omr\xE5de",
      cidrv4: "IPv4-spekter",
      cidrv6: "IPv6-spekter",
      base64: "base64-enkodet streng",
      base64url: "base64url-enkodet streng",
      json_string: "JSON-streng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${t.expected}, fikk ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ugyldig verdi: forventet ${x(t.values[0])}`
          : `Ugyldig valg: forventet en av ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `For stor(t): forventet ${t.origin ?? "value"} til \xE5 ha ${o}${t.maximum.toString()} ${a.unit ?? "elementer"}`
          : `For stor(t): forventet ${t.origin ?? "value"} til \xE5 ha ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `For lite(n): forventet ${t.origin} til \xE5 ha ${o}${t.minimum.toString()} ${a.unit}`
          : `For lite(n): forventet ${t.origin} til \xE5 ha ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ugyldig streng: m\xE5 starte med "${o.prefix}"`
          : o.format === "ends_with"
            ? `Ugyldig streng: m\xE5 ende med "${o.suffix}"`
            : o.format === "includes"
              ? `Ugyldig streng: m\xE5 inneholde "${o.includes}"`
              : o.format === "regex"
                ? `Ugyldig streng: m\xE5 matche m\xF8nsteret ${o.pattern}`
                : `Ugyldig ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig n\xF8kkel i ${t.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${t.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function Ys() {
  return { localeError: Uc() };
}
var Rc = () => {
  let e = {
    string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
    file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
    array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
    set: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "numara";
        case "object": {
          if (Array.isArray(t)) return "saf";
          if (t === null) return "gayb";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "giren",
      email: "epostag\xE2h",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO heng\xE2m\u0131",
      date: "ISO tarihi",
      time: "ISO zaman\u0131",
      duration: "ISO m\xFCddeti",
      ipv4: "IPv4 ni\u015F\xE2n\u0131",
      ipv6: "IPv6 ni\u015F\xE2n\u0131",
      cidrv4: "IPv4 menzili",
      cidrv6: "IPv6 menzili",
      base64: "base64-\u015Fifreli metin",
      base64url: "base64url-\u015Fifreli metin",
      json_string: "JSON metin",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "giren",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `F\xE2sit giren: umulan ${t.expected}, al\u0131nan ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `F\xE2sit giren: umulan ${x(t.values[0])}`
          : `F\xE2sit tercih: m\xFBteberler ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Fazla b\xFCy\xFCk: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} ${a.unit ?? "elements"} sahip olmal\u0131yd\u0131.`
          : `Fazla b\xFCy\xFCk: ${t.origin ?? "value"}, ${o}${t.maximum.toString()} olmal\u0131yd\u0131.`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Fazla k\xFC\xE7\xFCk: ${t.origin}, ${o}${t.minimum.toString()} ${a.unit} sahip olmal\u0131yd\u0131.`
          : `Fazla k\xFC\xE7\xFCk: ${t.origin}, ${o}${t.minimum.toString()} olmal\u0131yd\u0131.`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `F\xE2sit metin: "${o.prefix}" ile ba\u015Flamal\u0131.`
          : o.format === "ends_with"
            ? `F\xE2sit metin: "${o.suffix}" ile bitmeli.`
            : o.format === "includes"
              ? `F\xE2sit metin: "${o.includes}" ihtiv\xE2 etmeli.`
              : o.format === "regex"
                ? `F\xE2sit metin: ${o.pattern} nak\u015F\u0131na uymal\u0131.`
                : `F\xE2sit ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `F\xE2sit say\u0131: ${t.divisor} kat\u0131 olmal\u0131yd\u0131.`;
      case "unrecognized_keys":
        return `Tan\u0131nmayan anahtar ${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} i\xE7in tan\u0131nmayan anahtar var.`;
      case "invalid_union":
        return "Giren tan\u0131namad\u0131.";
      case "invalid_element":
        return `${t.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
      default:
        return "K\u0131ymet tan\u0131namad\u0131.";
    }
  };
};
function Ks() {
  return { localeError: Rc() };
}
var Cc = () => {
  let e = {
    string: { unit: "znak\xF3w", verb: "mie\u0107" },
    file: { unit: "bajt\xF3w", verb: "mie\u0107" },
    array: { unit: "element\xF3w", verb: "mie\u0107" },
    set: { unit: "element\xF3w", verb: "mie\u0107" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "liczba";
        case "object": {
          if (Array.isArray(t)) return "tablica";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "wyra\u017Cenie",
      email: "adres email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data i godzina w formacie ISO",
      date: "data w formacie ISO",
      time: "godzina w formacie ISO",
      duration: "czas trwania ISO",
      ipv4: "adres IPv4",
      ipv6: "adres IPv6",
      cidrv4: "zakres IPv4",
      cidrv6: "zakres IPv6",
      base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
      base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
      json_string: "ci\u0105g znak\xF3w w formacie JSON",
      e164: "liczba E.164",
      jwt: "JWT",
      template_literal: "wej\u015Bcie",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${t.expected}, otrzymano ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${x(t.values[0])}`
          : `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${o}${t.maximum.toString()} ${a.unit ?? "element\xF3w"}`
          : `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${o}${t.minimum.toString()} ${a.unit ?? "element\xF3w"}`
          : `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${t.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${o.prefix}"`
          : o.format === "ends_with"
            ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${o.suffix}"`
            : o.format === "includes"
              ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${o.includes}"`
              : o.format === "regex"
                ? `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${o.pattern}`
                : `Nieprawid\u0142ow(y/a/e) ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${t.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawid\u0142owy klucz w ${t.origin}`;
      case "invalid_union":
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
      case "invalid_element":
        return `Nieprawid\u0142owa warto\u015B\u0107 w ${t.origin}`;
      default:
        return "Nieprawid\u0142owe dane wej\u015Bciowe";
    }
  };
};
function Xs() {
  return { localeError: Cc() };
}
var Lc = () => {
  let e = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "n\xFAmero";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "nulo";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "padr\xE3o",
      email: "endere\xE7o de e-mail",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "data e hora ISO",
      date: "data ISO",
      time: "hora ISO",
      duration: "dura\xE7\xE3o ISO",
      ipv4: "endere\xE7o IPv4",
      ipv6: "endere\xE7o IPv6",
      cidrv4: "faixa de IPv4",
      cidrv6: "faixa de IPv6",
      base64: "texto codificado em base64",
      base64url: "URL codificada em base64",
      json_string: "texto JSON",
      e164: "n\xFAmero E.164",
      jwt: "JWT",
      template_literal: "entrada",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Tipo inv\xE1lido: esperado ${t.expected}, recebido ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Entrada inv\xE1lida: esperado ${x(t.values[0])}`
          : `Op\xE7\xE3o inv\xE1lida: esperada uma das ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Muito grande: esperado que ${t.origin ?? "valor"} tivesse ${o}${t.maximum.toString()} ${a.unit ?? "elementos"}`
          : `Muito grande: esperado que ${t.origin ?? "valor"} fosse ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Muito pequeno: esperado que ${t.origin} tivesse ${o}${t.minimum.toString()} ${a.unit}`
          : `Muito pequeno: esperado que ${t.origin} fosse ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Texto inv\xE1lido: deve come\xE7ar com "${o.prefix}"`
          : o.format === "ends_with"
            ? `Texto inv\xE1lido: deve terminar com "${o.suffix}"`
            : o.format === "includes"
              ? `Texto inv\xE1lido: deve incluir "${o.includes}"`
              : o.format === "regex"
                ? `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${o.pattern}`
                : `${i[o.format] ?? t.format} inv\xE1lido`;
      }
      case "not_multiple_of":
        return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${t.divisor}`;
      case "unrecognized_keys":
        return `Chave${t.keys.length > 1 ? "s" : ""} desconhecida${t.keys.length > 1 ? "s" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Chave inv\xE1lida em ${t.origin}`;
      case "invalid_union":
        return "Entrada inv\xE1lida";
      case "invalid_element":
        return `Valor inv\xE1lido em ${t.origin}`;
      default:
        return "Campo inv\xE1lido";
    }
  };
};
function Js() {
  return { localeError: Lc() };
}
function Qs(e, r, n, i) {
  let t = Math.abs(e),
    o = t % 10,
    a = t % 100;
  return a >= 11 && a <= 19 ? i : o === 1 ? r : o >= 2 && o <= 4 ? n : i;
}
var Fc = () => {
  let e = {
    string: {
      unit: {
        one: "\u0441\u0438\u043C\u0432\u043E\u043B",
        few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
        many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    file: {
      unit: {
        one: "\u0431\u0430\u0439\u0442",
        few: "\u0431\u0430\u0439\u0442\u0430",
        many: "\u0431\u0430\u0439\u0442",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    array: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
    set: {
      unit: {
        one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
        few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
        many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432",
      },
      verb: "\u0438\u043C\u0435\u0442\u044C",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0441\u0438\u0432";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u0432\u043E\u0434",
      email: "email \u0430\u0434\u0440\u0435\u0441",
      url: "URL",
      emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
      date: "ISO \u0434\u0430\u0442\u0430",
      time: "ISO \u0432\u0440\u0435\u043C\u044F",
      duration:
        "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
      ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
      ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
      cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
      base64:
        "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
      base64url:
        "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
      json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal: "\u0432\u0432\u043E\u0434",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${t.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${x(t.values[0])}`
          : `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        if (a) {
          let s = Number(t.maximum),
            u = Qs(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${o}${t.maximum.toString()} ${u}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        if (a) {
          let s = Number(t.minimum),
            u = Qs(s, a.unit.one, a.unit.few, a.unit.many);
          return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${o}${t.minimum.toString()} ${u}`;
        }
        return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${t.origin} \u0431\u0443\u0434\u0435\u0442 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${t.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${t.keys.length > 1 ? "\u0438" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
      case "invalid_element":
        return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${t.origin}`;
      default:
        return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
    }
  };
};
function el() {
  return { localeError: Fc() };
}
var Zc = () => {
  let e = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0161tevilo";
        case "object": {
          if (Array.isArray(t)) return "tabela";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "vnos",
      email: "e-po\u0161tni naslov",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO datum in \u010Das",
      date: "ISO datum",
      time: "ISO \u010Das",
      duration: "ISO trajanje",
      ipv4: "IPv4 naslov",
      ipv6: "IPv6 naslov",
      cidrv4: "obseg IPv4",
      cidrv6: "obseg IPv6",
      base64: "base64 kodiran niz",
      base64url: "base64url kodiran niz",
      json_string: "JSON niz",
      e164: "E.164 \u0161tevilka",
      jwt: "JWT",
      template_literal: "vnos",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Neveljaven vnos: pri\u010Dakovano ${t.expected}, prejeto ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Neveljaven vnos: pri\u010Dakovano ${x(t.values[0])}`
          : `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Preveliko: pri\u010Dakovano, da bo ${t.origin ?? "vrednost"} imelo ${o}${t.maximum.toString()} ${a.unit ?? "elementov"}`
          : `Preveliko: pri\u010Dakovano, da bo ${t.origin ?? "vrednost"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Premajhno: pri\u010Dakovano, da bo ${t.origin} imelo ${o}${t.minimum.toString()} ${a.unit}`
          : `Premajhno: pri\u010Dakovano, da bo ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Neveljaven niz: mora se za\u010Deti z "${o.prefix}"`
          : o.format === "ends_with"
            ? `Neveljaven niz: mora se kon\u010Dati z "${o.suffix}"`
            : o.format === "includes"
              ? `Neveljaven niz: mora vsebovati "${o.includes}"`
              : o.format === "regex"
                ? `Neveljaven niz: mora ustrezati vzorcu ${o.pattern}`
                : `Neveljaven ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${t.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${t.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju\u010D v ${t.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${t.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function tl() {
  return { localeError: Zc() };
}
var Bc = () => {
  let e = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att inneh\xE5lla" },
    set: { unit: "objekt", verb: "att inneh\xE5lla" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "antal";
        case "object": {
          if (Array.isArray(t)) return "lista";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "regulj\xE4rt uttryck",
      email: "e-postadress",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO-datum och tid",
      date: "ISO-datum",
      time: "ISO-tid",
      duration: "ISO-varaktighet",
      ipv4: "IPv4-intervall",
      ipv6: "IPv6-intervall",
      cidrv4: "IPv4-spektrum",
      cidrv6: "IPv6-spektrum",
      base64: "base64-kodad str\xE4ng",
      base64url: "base64url-kodad str\xE4ng",
      json_string: "JSON-str\xE4ng",
      e164: "E.164-nummer",
      jwt: "JWT",
      template_literal: "mall-literal",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `Ogiltig inmatning: f\xF6rv\xE4ntat ${t.expected}, fick ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `Ogiltig inmatning: f\xF6rv\xE4ntat ${x(t.values[0])}`
          : `Ogiltigt val: f\xF6rv\xE4ntade en av ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `F\xF6r stor(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.maximum.toString()} ${a.unit ?? "element"}`
          : `F\xF6r stor(t): f\xF6rv\xE4ntat ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `F\xF6r lite(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.minimum.toString()} ${a.unit}`
          : `F\xF6r lite(t): f\xF6rv\xE4ntade ${t.origin ?? "v\xE4rdet"} att ha ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${o.prefix}"`
          : o.format === "ends_with"
            ? `Ogiltig str\xE4ng: m\xE5ste sluta med "${o.suffix}"`
            : o.format === "includes"
              ? `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${o.includes}"`
              : o.format === "regex"
                ? `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${o.pattern}"`
                : `Ogiltig(t) ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: m\xE5ste vara en multipel av ${t.divisor}`;
      case "unrecognized_keys":
        return `${t.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${t.origin ?? "v\xE4rdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt v\xE4rde i ${t.origin ?? "v\xE4rdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function rl() {
  return { localeError: Bc() };
}
var qc = () => {
  let e = {
    string: {
      unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    file: {
      unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    array: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
    set: {
      unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD",
      verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1"
            : "\u0B8E\u0BA3\u0BCD";
        case "object": {
          if (Array.isArray(t)) return "\u0B85\u0BA3\u0BBF";
          if (t === null) return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
      email:
        "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
      time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
      duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
      ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
      cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
      base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
      json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
      e164: "E.164 \u0B8E\u0BA3\u0BCD",
      jwt: "JWT",
      template_literal: "input",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${x(t.values[0])}`
          : `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${f(t.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${o}${t.maximum.toString()} ${a.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${o}${t.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin} ${o}${t.minimum.toString()} ${a.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${t.origin} ${o}${t.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
          : o.format === "ends_with"
            ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
            : o.format === "includes"
              ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${o.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
              : o.format === "regex"
                ? `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${o.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`
                : `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${t.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
      case "unrecognized_keys":
        return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${t.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
      case "invalid_union":
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
      case "invalid_element":
        return `${t.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
      default:
        return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
    }
  };
};
function nl() {
  return { localeError: qc() };
}
var Gc = () => {
  let e = {
    string: {
      unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    file: {
      unit: "\u0E44\u0E1A\u0E15\u0E4C",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    array: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
    set: {
      unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23",
      verb: "\u0E04\u0E27\u0E23\u0E21\u0E35",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t)
            ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)"
            : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
        case "object": {
          if (Array.isArray(t))
            return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
          if (t === null)
            return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex:
        "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
      email:
        "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
      url: "URL",
      emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime:
        "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
      time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      duration:
        "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
      ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
      ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
      cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
      cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
      base64:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
      base64url:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
      json_string:
        "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
      e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
      jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
      template_literal:
        "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${t.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${x(t.values[0])}`
          : `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive
            ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19"
            : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32",
          a = r(t.origin);
        return a
          ? `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.maximum.toString()} ${a.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`
          : `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive
            ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22"
            : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32",
          a = r(t.origin);
        return a
          ? `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.minimum.toString()} ${a.unit}`
          : `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${t.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${o} ${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${o.suffix}"`
            : o.format === "includes"
              ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${o.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`
              : o.format === "regex"
                ? `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${o.pattern}`
                : `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${t.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
      case "unrecognized_keys":
        return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${t.origin}`;
      case "invalid_union":
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
      case "invalid_element":
        return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${t.origin}`;
      default:
        return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07";
    }
  };
};
function ol() {
  return { localeError: Gc() };
}
var Hc = (e) => {
    let r = typeof e;
    switch (r) {
      case "number":
        return Number.isNaN(e) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(e)) return "array";
        if (e === null) return "null";
        if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
          return e.constructor.name;
      }
    }
    return r;
  },
  Wc = () => {
    let e = {
      string: { unit: "karakter", verb: "olmal\u0131" },
      file: { unit: "bayt", verb: "olmal\u0131" },
      array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
      set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
    };
    function r(i) {
      return e[i] ?? null;
    }
    let n = {
      regex: "girdi",
      email: "e-posta adresi",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO tarih ve saat",
      date: "ISO tarih",
      time: "ISO saat",
      duration: "ISO s\xFCre",
      ipv4: "IPv4 adresi",
      ipv6: "IPv6 adresi",
      cidrv4: "IPv4 aral\u0131\u011F\u0131",
      cidrv6: "IPv6 aral\u0131\u011F\u0131",
      base64: "base64 ile \u015Fifrelenmi\u015F metin",
      base64url: "base64url ile \u015Fifrelenmi\u015F metin",
      json_string: "JSON dizesi",
      e164: "E.164 say\u0131s\u0131",
      jwt: "JWT",
      template_literal: "\u015Eablon dizesi",
    };
    return (i) => {
      switch (i.code) {
        case "invalid_type":
          return `Ge\xE7ersiz de\u011Fer: beklenen ${i.expected}, al\u0131nan ${Hc(i.input)}`;
        case "invalid_value":
          return i.values.length === 1
            ? `Ge\xE7ersiz de\u011Fer: beklenen ${x(i.values[0])}`
            : `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${f(i.values, "|")}`;
        case "too_big": {
          let t = i.inclusive ? "<=" : "<",
            o = r(i.origin);
          return o
            ? `\xC7ok b\xFCy\xFCk: beklenen ${i.origin ?? "de\u011Fer"} ${t}${i.maximum.toString()} ${o.unit ?? "\xF6\u011Fe"}`
            : `\xC7ok b\xFCy\xFCk: beklenen ${i.origin ?? "de\u011Fer"} ${t}${i.maximum.toString()}`;
        }
        case "too_small": {
          let t = i.inclusive ? ">=" : ">",
            o = r(i.origin);
          return o
            ? `\xC7ok k\xFC\xE7\xFCk: beklenen ${i.origin} ${t}${i.minimum.toString()} ${o.unit}`
            : `\xC7ok k\xFC\xE7\xFCk: beklenen ${i.origin} ${t}${i.minimum.toString()}`;
        }
        case "invalid_format": {
          let t = i;
          return t.format === "starts_with"
            ? `Ge\xE7ersiz metin: "${t.prefix}" ile ba\u015Flamal\u0131`
            : t.format === "ends_with"
              ? `Ge\xE7ersiz metin: "${t.suffix}" ile bitmeli`
              : t.format === "includes"
                ? `Ge\xE7ersiz metin: "${t.includes}" i\xE7ermeli`
                : t.format === "regex"
                  ? `Ge\xE7ersiz metin: ${t.pattern} desenine uymal\u0131`
                  : `Ge\xE7ersiz ${n[t.format] ?? i.format}`;
        }
        case "not_multiple_of":
          return `Ge\xE7ersiz say\u0131: ${i.divisor} ile tam b\xF6l\xFCnebilmeli`;
        case "unrecognized_keys":
          return `Tan\u0131nmayan anahtar${i.keys.length > 1 ? "lar" : ""}: ${f(i.keys, ", ")}`;
        case "invalid_key":
          return `${i.origin} i\xE7inde ge\xE7ersiz anahtar`;
        case "invalid_union":
          return "Ge\xE7ersiz de\u011Fer";
        case "invalid_element":
          return `${i.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
        default:
          return "Ge\xE7ersiz de\u011Fer";
      }
    };
  };
function il() {
  return { localeError: Wc() };
}
var Yc = () => {
  let e = {
    string: {
      unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    file: {
      unit: "\u0431\u0430\u0439\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    array: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
    set: {
      unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432",
      verb: "\u043C\u0430\u0442\u0438\u043C\u0435",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        case "object": {
          if (Array.isArray(t)) return "\u043C\u0430\u0441\u0438\u0432";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
      email:
        "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
      url: "URL",
      emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
      date: "\u0434\u0430\u0442\u0430 ISO",
      time: "\u0447\u0430\u0441 ISO",
      duration:
        "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
      ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
      ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
      cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
      cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
      base64:
        "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
      base64url:
        "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
      json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
      e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
      jwt: "JWT",
      template_literal:
        "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${t.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${x(t.values[0])}`
          : `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`
          : `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${t.origin} \u0431\u0443\u0434\u0435 ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${o.prefix}"`
          : o.format === "ends_with"
            ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${o.suffix}"`
            : o.format === "includes"
              ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${o.includes}"`
              : o.format === "regex"
                ? `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${o.pattern}`
                : `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${t.divisor}`;
      case "unrecognized_keys":
        return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${t.keys.length > 1 ? "\u0456" : ""}: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${t.origin}`;
      case "invalid_union":
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
      case "invalid_element":
        return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${t.origin}`;
      default:
        return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
    }
  };
};
function al() {
  return { localeError: Yc() };
}
var Kc = () => {
  let e = {
    string: {
      unit: "\u062D\u0631\u0648\u0641",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    file: {
      unit: "\u0628\u0627\u0626\u0679\u0633",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    array: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
    set: {
      unit: "\u0622\u0626\u0679\u0645\u0632",
      verb: "\u06C1\u0648\u0646\u0627",
    },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "\u0646\u0645\u0628\u0631";
        case "object": {
          if (Array.isArray(t)) return "\u0622\u0631\u06D2";
          if (t === null) return "\u0646\u0644";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0627\u0646 \u067E\u0679",
      email:
        "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
      emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
      uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      uuidv4:
        "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
      uuidv6:
        "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
      nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
      ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
      xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
      ksuid:
        "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
      datetime:
        "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
      date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
      time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
      duration:
        "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
      ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
      cidrv4:
        "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
      cidrv6:
        "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
      base64:
        "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      base64url:
        "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
      json_string:
        "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
      e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
      jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
      template_literal: "\u0627\u0646 \u067E\u0679",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${t.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${n(t.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${x(t.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`
          : `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${f(t.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u0628\u06C1\u062A \u0628\u0691\u0627: ${t.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${o}${t.maximum.toString()} ${a.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`
          : `\u0628\u06C1\u062A \u0628\u0691\u0627: ${t.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${o}${t.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${t.origin} \u06A9\u06D2 ${o}${t.minimum.toString()} ${a.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`
          : `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${t.origin} \u06A9\u0627 ${o}${t.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
          : o.format === "ends_with"
            ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
            : o.format === "includes"
              ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${o.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
              : o.format === "regex"
                ? `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${o.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`
                : `\u063A\u0644\u0637 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${t.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
      case "unrecognized_keys":
        return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${t.keys.length > 1 ? "\u0632" : ""}: ${f(t.keys, "\u060C ")}`;
      case "invalid_key":
        return `${t.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
      case "invalid_union":
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
      case "invalid_element":
        return `${t.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
      default:
        return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
    }
  };
};
function sl() {
  return { localeError: Kc() };
}
var Xc = () => {
  let e = {
    string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
    file: { unit: "byte", verb: "c\xF3" },
    array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
    set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "s\u1ED1";
        case "object": {
          if (Array.isArray(t)) return "m\u1EA3ng";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u0111\u1EA7u v\xE0o",
      email: "\u0111\u1ECBa ch\u1EC9 email",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ng\xE0y gi\u1EDD ISO",
      date: "ng\xE0y ISO",
      time: "gi\u1EDD ISO",
      duration: "kho\u1EA3ng th\u1EDDi gian ISO",
      ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
      ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
      cidrv4: "d\u1EA3i IPv4",
      cidrv6: "d\u1EA3i IPv6",
      base64: "chu\u1ED7i m\xE3 h\xF3a base64",
      base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
      json_string: "chu\u1ED7i JSON",
      e164: "s\u1ED1 E.164",
      jwt: "JWT",
      template_literal: "\u0111\u1EA7u v\xE0o",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${t.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${x(t.values[0])}`
          : `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${t.origin ?? "gi\xE1 tr\u1ECB"} ${a.verb} ${o}${t.maximum.toString()} ${a.unit ?? "ph\u1EA7n t\u1EED"}`
          : `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${t.origin ?? "gi\xE1 tr\u1ECB"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${t.origin} ${a.verb} ${o}${t.minimum.toString()} ${a.unit}`
          : `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${o.prefix}"`
          : o.format === "ends_with"
            ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${o.suffix}"`
            : o.format === "includes"
              ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${o.includes}"`
              : o.format === "regex"
                ? `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${o.pattern}`
                : `${i[o.format] ?? t.format} kh\xF4ng h\u1EE3p l\u1EC7`;
      }
      case "not_multiple_of":
        return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${t.divisor}`;
      case "unrecognized_keys":
        return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${t.origin}`;
      case "invalid_union":
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
      case "invalid_element":
        return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${t.origin}`;
      default:
        return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
    }
  };
};
function ll() {
  return { localeError: Xc() };
}
var Jc = () => {
  let e = {
    string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
    file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
    array: { unit: "\u9879", verb: "\u5305\u542B" },
    set: { unit: "\u9879", verb: "\u5305\u542B" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
        case "object": {
          if (Array.isArray(t)) return "\u6570\u7EC4";
          if (t === null) return "\u7A7A\u503C(null)";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u8F93\u5165",
      email: "\u7535\u5B50\u90AE\u4EF6",
      url: "URL",
      emoji: "\u8868\u60C5\u7B26\u53F7",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO\u65E5\u671F\u65F6\u95F4",
      date: "ISO\u65E5\u671F",
      time: "ISO\u65F6\u95F4",
      duration: "ISO\u65F6\u957F",
      ipv4: "IPv4\u5730\u5740",
      ipv6: "IPv6\u5730\u5740",
      cidrv4: "IPv4\u7F51\u6BB5",
      cidrv6: "IPv6\u7F51\u6BB5",
      base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
      base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
      json_string: "JSON\u5B57\u7B26\u4E32",
      e164: "E.164\u53F7\u7801",
      jwt: "JWT",
      template_literal: "\u8F93\u5165",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${t.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${x(t.values[0])}`
          : `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${t.origin ?? "\u503C"} ${o}${t.maximum.toString()} ${a.unit ?? "\u4E2A\u5143\u7D20"}`
          : `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${t.origin ?? "\u503C"} ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${t.origin} ${o}${t.minimum.toString()} ${a.unit}`
          : `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${t.origin} ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${o.prefix}" \u5F00\u5934`
          : o.format === "ends_with"
            ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${o.suffix}" \u7ED3\u5C3E`
            : o.format === "includes"
              ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${o.includes}"`
              : o.format === "regex"
                ? `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${o.pattern}`
                : `\u65E0\u6548${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${t.divisor} \u7684\u500D\u6570`;
      case "unrecognized_keys":
        return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${f(t.keys, ", ")}`;
      case "invalid_key":
        return `${t.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
      case "invalid_union":
        return "\u65E0\u6548\u8F93\u5165";
      case "invalid_element":
        return `${t.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
      default:
        return "\u65E0\u6548\u8F93\u5165";
    }
  };
};
function ul() {
  return { localeError: Jc() };
}
var Qc = () => {
  let e = {
    string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
    file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
    array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
    set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
  };
  function r(t) {
    return e[t] ?? null;
  }
  let n = (t) => {
      let o = typeof t;
      switch (o) {
        case "number":
          return Number.isNaN(t) ? "NaN" : "number";
        case "object": {
          if (Array.isArray(t)) return "array";
          if (t === null) return "null";
          if (Object.getPrototypeOf(t) !== Object.prototype && t.constructor)
            return t.constructor.name;
        }
      }
      return o;
    },
    i = {
      regex: "\u8F38\u5165",
      email: "\u90F5\u4EF6\u5730\u5740",
      url: "URL",
      emoji: "emoji",
      uuid: "UUID",
      uuidv4: "UUIDv4",
      uuidv6: "UUIDv6",
      nanoid: "nanoid",
      guid: "GUID",
      cuid: "cuid",
      cuid2: "cuid2",
      ulid: "ULID",
      xid: "XID",
      ksuid: "KSUID",
      datetime: "ISO \u65E5\u671F\u6642\u9593",
      date: "ISO \u65E5\u671F",
      time: "ISO \u6642\u9593",
      duration: "ISO \u671F\u9593",
      ipv4: "IPv4 \u4F4D\u5740",
      ipv6: "IPv6 \u4F4D\u5740",
      cidrv4: "IPv4 \u7BC4\u570D",
      cidrv6: "IPv6 \u7BC4\u570D",
      base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
      base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
      json_string: "JSON \u5B57\u4E32",
      e164: "E.164 \u6578\u503C",
      jwt: "JWT",
      template_literal: "\u8F38\u5165",
    };
  return (t) => {
    switch (t.code) {
      case "invalid_type":
        return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${t.expected}\uFF0C\u4F46\u6536\u5230 ${n(t.input)}`;
      case "invalid_value":
        return t.values.length === 1
          ? `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${x(t.values[0])}`
          : `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${f(t.values, "|")}`;
      case "too_big": {
        let o = t.inclusive ? "<=" : "<",
          a = r(t.origin);
        return a
          ? `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${t.origin ?? "\u503C"} \u61C9\u70BA ${o}${t.maximum.toString()} ${a.unit ?? "\u500B\u5143\u7D20"}`
          : `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${t.origin ?? "\u503C"} \u61C9\u70BA ${o}${t.maximum.toString()}`;
      }
      case "too_small": {
        let o = t.inclusive ? ">=" : ">",
          a = r(t.origin);
        return a
          ? `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${t.origin} \u61C9\u70BA ${o}${t.minimum.toString()} ${a.unit}`
          : `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${t.origin} \u61C9\u70BA ${o}${t.minimum.toString()}`;
      }
      case "invalid_format": {
        let o = t;
        return o.format === "starts_with"
          ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${o.prefix}" \u958B\u982D`
          : o.format === "ends_with"
            ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${o.suffix}" \u7D50\u5C3E`
            : o.format === "includes"
              ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${o.includes}"`
              : o.format === "regex"
                ? `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${o.pattern}`
                : `\u7121\u6548\u7684 ${i[o.format] ?? t.format}`;
      }
      case "not_multiple_of":
        return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${t.divisor} \u7684\u500D\u6578`;
      case "unrecognized_keys":
        return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${t.keys.length > 1 ? "\u5011" : ""}\uFF1A${f(t.keys, "\u3001")}`;
      case "invalid_key":
        return `${t.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
      case "invalid_union":
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
      case "invalid_element":
        return `${t.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
      default:
        return "\u7121\u6548\u7684\u8F38\u5165\u503C";
    }
  };
};
function cl() {
  return { localeError: Qc() };
}
var vi = Symbol("ZodOutput"),
  yi = Symbol("ZodInput"),
  je = class {
    constructor() {
      ((this._map = new WeakMap()), (this._idmap = new Map()));
    }
    add(r, ...n) {
      let i = n[0];
      if ((this._map.set(r, i), i && typeof i == "object" && "id" in i)) {
        if (this._idmap.has(i.id))
          throw new Error(`ID ${i.id} already exists in the registry`);
        this._idmap.set(i.id, r);
      }
      return this;
    }
    remove(r) {
      return (this._map.delete(r), this);
    }
    get(r) {
      let n = r._zod.parent;
      if (n) {
        let i = { ...(this.get(n) ?? {}) };
        return (delete i.id, { ...i, ...this._map.get(r) });
      }
      return this._map.get(r);
    }
    has(r) {
      return this._map.has(r);
    }
  };
function nr() {
  return new je();
}
var se = nr();
function bi(e, r) {
  return new e({ type: "string", ...y(r) });
}
function wi(e, r) {
  return new e({ type: "string", coerce: !0, ...y(r) });
}
function or(e, r) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function dt(e, r) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function ir(e, r) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function ar(e, r) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...y(r),
  });
}
function sr(e, r) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...y(r),
  });
}
function lr(e, r) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...y(r),
  });
}
function ur(e, r) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function cr(e, r) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function _r(e, r) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function dr(e, r) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function mr(e, r) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function pr(e, r) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function fr(e, r) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function gr(e, r) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function hr(e, r) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function vr(e, r) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function yr(e, r) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function br(e, r) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function wr(e, r) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function xr(e, r) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function Ar(e, r) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function kr(e, r) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...y(r),
  });
}
function xi(e, r) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...y(r),
  });
}
function Ai(e, r) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...y(r),
  });
}
function ki(e, r) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...y(r),
  });
}
function $i(e, r) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...y(r),
  });
}
function zi(e, r) {
  return new e({ type: "number", checks: [], ...y(r) });
}
function Si(e, r) {
  return new e({ type: "number", coerce: !0, checks: [], ...y(r) });
}
function Ii(e, r) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...y(r),
  });
}
function Pi(e, r) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...y(r),
  });
}
function Di(e, r) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...y(r),
  });
}
function Ei(e, r) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...y(r),
  });
}
function Vi(e, r) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...y(r),
  });
}
function Ti(e, r) {
  return new e({ type: "boolean", ...y(r) });
}
function Oi(e, r) {
  return new e({ type: "boolean", coerce: !0, ...y(r) });
}
function ji(e, r) {
  return new e({ type: "bigint", ...y(r) });
}
function Ni(e, r) {
  return new e({ type: "bigint", coerce: !0, ...y(r) });
}
function Mi(e, r) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...y(r),
  });
}
function Ui(e, r) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...y(r),
  });
}
function Ri(e, r) {
  return new e({ type: "symbol", ...y(r) });
}
function Ci(e, r) {
  return new e({ type: "undefined", ...y(r) });
}
function Li(e, r) {
  return new e({ type: "null", ...y(r) });
}
function Fi(e) {
  return new e({ type: "any" });
}
function Ne(e) {
  return new e({ type: "unknown" });
}
function Zi(e, r) {
  return new e({ type: "never", ...y(r) });
}
function Bi(e, r) {
  return new e({ type: "void", ...y(r) });
}
function qi(e, r) {
  return new e({ type: "date", ...y(r) });
}
function Gi(e, r) {
  return new e({ type: "date", coerce: !0, ...y(r) });
}
function Hi(e, r) {
  return new e({ type: "nan", ...y(r) });
}
function ce(e, r) {
  return new Yt({ check: "less_than", ...y(r), value: e, inclusive: !1 });
}
function re(e, r) {
  return new Yt({ check: "less_than", ...y(r), value: e, inclusive: !0 });
}
function _e(e, r) {
  return new Kt({ check: "greater_than", ...y(r), value: e, inclusive: !1 });
}
function X(e, r) {
  return new Kt({ check: "greater_than", ...y(r), value: e, inclusive: !0 });
}
function Wi(e) {
  return _e(0, e);
}
function Yi(e) {
  return ce(0, e);
}
function Ki(e) {
  return re(0, e);
}
function Xi(e) {
  return X(0, e);
}
function Ie(e, r) {
  return new Yn({ check: "multiple_of", ...y(r), value: e });
}
function Me(e, r) {
  return new Jn({ check: "max_size", ...y(r), maximum: e });
}
function Pe(e, r) {
  return new Qn({ check: "min_size", ...y(r), minimum: e });
}
function mt(e, r) {
  return new eo({ check: "size_equals", ...y(r), size: e });
}
function Ue(e, r) {
  return new to({ check: "max_length", ...y(r), maximum: e });
}
function we(e, r) {
  return new ro({ check: "min_length", ...y(r), minimum: e });
}
function Re(e, r) {
  return new no({ check: "length_equals", ...y(r), length: e });
}
function pt(e, r) {
  return new oo({
    check: "string_format",
    format: "regex",
    ...y(r),
    pattern: e,
  });
}
function ft(e) {
  return new io({ check: "string_format", format: "lowercase", ...y(e) });
}
function gt(e) {
  return new ao({ check: "string_format", format: "uppercase", ...y(e) });
}
function ht(e, r) {
  return new so({
    check: "string_format",
    format: "includes",
    ...y(r),
    includes: e,
  });
}
function vt(e, r) {
  return new lo({
    check: "string_format",
    format: "starts_with",
    ...y(r),
    prefix: e,
  });
}
function yt(e, r) {
  return new uo({
    check: "string_format",
    format: "ends_with",
    ...y(r),
    suffix: e,
  });
}
function Ji(e, r, n) {
  return new co({ check: "property", property: e, schema: r, ...y(n) });
}
function bt(e, r) {
  return new _o({ check: "mime_type", mime: e, ...y(r) });
}
function de(e) {
  return new mo({ check: "overwrite", tx: e });
}
function wt(e) {
  return de((r) => r.normalize(e));
}
function xt() {
  return de((e) => e.trim());
}
function At() {
  return de((e) => e.toLowerCase());
}
function kt() {
  return de((e) => e.toUpperCase());
}
function $t(e, r, n) {
  return new e({ type: "array", element: r, ...y(n) });
}
function e_(e, r, n) {
  return new e({ type: "union", options: r, ...y(n) });
}
function t_(e, r, n, i) {
  return new e({ type: "union", options: n, discriminator: r, ...y(i) });
}
function r_(e, r, n) {
  return new e({ type: "intersection", left: r, right: n });
}
function Qi(e, r, n, i) {
  let t = n instanceof P,
    o = t ? i : n,
    a = t ? n : null;
  return new e({ type: "tuple", items: r, rest: a, ...y(o) });
}
function n_(e, r, n, i) {
  return new e({ type: "record", keyType: r, valueType: n, ...y(i) });
}
function o_(e, r, n, i) {
  return new e({ type: "map", keyType: r, valueType: n, ...y(i) });
}
function i_(e, r, n) {
  return new e({ type: "set", valueType: r, ...y(n) });
}
function a_(e, r, n) {
  let i = Array.isArray(r) ? Object.fromEntries(r.map((t) => [t, t])) : r;
  return new e({ type: "enum", entries: i, ...y(n) });
}
function s_(e, r, n) {
  return new e({ type: "enum", entries: r, ...y(n) });
}
function l_(e, r, n) {
  return new e({
    type: "literal",
    values: Array.isArray(r) ? r : [r],
    ...y(n),
  });
}
function ea(e, r) {
  return new e({ type: "file", ...y(r) });
}
function u_(e, r) {
  return new e({ type: "transform", transform: r });
}
function c_(e, r) {
  return new e({ type: "optional", innerType: r });
}
function __(e, r) {
  return new e({ type: "nullable", innerType: r });
}
function d_(e, r, n) {
  return new e({
    type: "default",
    innerType: r,
    get defaultValue() {
      return typeof n == "function" ? n() : n;
    },
  });
}
function m_(e, r, n) {
  return new e({ type: "nonoptional", innerType: r, ...y(n) });
}
function p_(e, r) {
  return new e({ type: "success", innerType: r });
}
function f_(e, r, n) {
  return new e({
    type: "catch",
    innerType: r,
    catchValue: typeof n == "function" ? n : () => n,
  });
}
function g_(e, r, n) {
  return new e({ type: "pipe", in: r, out: n });
}
function h_(e, r) {
  return new e({ type: "readonly", innerType: r });
}
function v_(e, r, n) {
  return new e({ type: "template_literal", parts: r, ...y(n) });
}
function y_(e, r) {
  return new e({ type: "lazy", getter: r });
}
function b_(e, r) {
  return new e({ type: "promise", innerType: r });
}
function ta(e, r, n) {
  let i = y(n);
  return (
    i.abort ?? (i.abort = !0),
    new e({ type: "custom", check: "custom", fn: r, ...i })
  );
}
function ra(e, r, n) {
  return new e({ type: "custom", check: "custom", fn: r, ...y(n) });
}
function na(e, r) {
  let { case: n, error: i, truthy: t, falsy: o } = y(r),
    a = new Set(t ?? ["true", "1", "yes", "on", "y", "enabled"]),
    s = new Set(o ?? ["false", "0", "no", "off", "n", "disabled"]),
    u = e.Pipe ?? ct,
    l = e.Boolean ?? lt,
    m = e.Unknown ?? be,
    p = new m({
      type: "unknown",
      checks: [
        {
          _zod: {
            check: (d) => {
              if (typeof d.value == "string") {
                let _ = d.value;
                (n !== "sensitive" && (_ = _.toLowerCase()),
                  a.has(_)
                    ? (d.value = !0)
                    : s.has(_)
                      ? (d.value = !1)
                      : d.issues.push({
                          code: "invalid_value",
                          expected: "stringbool",
                          values: [...a, ...s],
                          input: d.value,
                          inst: p,
                        }));
              } else
                d.issues.push({
                  code: "invalid_type",
                  expected: "string",
                  input: d.value,
                });
            },
            def: { check: "custom" },
            onattach: [],
          },
        },
      ],
      error: i,
    });
  return new u({
    type: "pipe",
    in: p,
    out: new l({ type: "boolean", error: i }),
    error: i,
  });
}
var $r = class {
  constructor(r) {
    ((this._def = r), (this.def = r));
  }
  implement(r) {
    if (typeof r != "function")
      throw new Error("implement() must be called with a function");
    let n = (...i) => {
      let t = this._def.input
        ? Zt(this._def.input, i, void 0, { callee: n })
        : i;
      if (!Array.isArray(t))
        throw new Error(
          "Invalid arguments schema: not an array or tuple schema.",
        );
      let o = r(...t);
      return this._def.output
        ? Zt(this._def.output, o, void 0, { callee: n })
        : o;
    };
    return n;
  }
  implementAsync(r) {
    if (typeof r != "function")
      throw new Error("implement() must be called with a function");
    let n = async (...i) => {
      let t = this._def.input
        ? await qt(this._def.input, i, void 0, { callee: n })
        : i;
      if (!Array.isArray(t))
        throw new Error(
          "Invalid arguments schema: not an array or tuple schema.",
        );
      let o = await r(...t);
      return this._def.output
        ? qt(this._def.output, o, void 0, { callee: n })
        : o;
    };
    return n;
  }
  input(...r) {
    let n = this.constructor;
    return Array.isArray(r[0])
      ? new n({
          type: "function",
          input: new Se({ type: "tuple", items: r[0], rest: r[1] }),
          output: this._def.output,
        })
      : new n({ type: "function", input: r[0], output: this._def.output });
  }
  output(r) {
    let n = this.constructor;
    return new n({ type: "function", input: this._def.input, output: r });
  }
};
function oa(e) {
  return new $r({
    type: "function",
    input: Array.isArray(e?.input)
      ? Qi(Se, e?.input)
      : (e?.input ?? $t(ut, Ne(be))),
    output: e?.output ?? Ne(be),
  });
}
var zt = class {
  constructor(r) {
    ((this.counter = 0),
      (this.metadataRegistry = r?.metadata ?? se),
      (this.target = r?.target ?? "draft-2020-12"),
      (this.unrepresentable = r?.unrepresentable ?? "throw"),
      (this.override = r?.override ?? (() => {})),
      (this.io = r?.io ?? "output"),
      (this.seen = new Map()));
  }
  process(r, n = { path: [], schemaPath: [] }) {
    var i;
    let t = r._zod.def,
      o = {
        guid: "uuid",
        url: "uri",
        datetime: "date-time",
        json_string: "json-string",
        regex: "",
      },
      a = this.seen.get(r);
    if (a)
      return (
        a.count++,
        n.schemaPath.includes(r) && (a.cycle = n.path),
        a.schema
      );
    let s = { schema: {}, count: 1, cycle: void 0 };
    (this.seen.set(r, s),
      r._zod.toJSONSchema && (s.schema = r._zod.toJSONSchema()));
    let u = { ...n, schemaPath: [...n.schemaPath, r], path: n.path },
      l = r._zod.parent;
    if (l) ((s.ref = l), this.process(l, u), (this.seen.get(l).isParent = !0));
    else {
      let d = s.schema;
      switch (t.type) {
        case "string": {
          let _ = d;
          _.type = "string";
          let {
            minimum: h,
            maximum: w,
            format: z,
            patterns: S,
            contentEncoding: A,
          } = r._zod.bag;
          if (
            (typeof h == "number" && (_.minLength = h),
            typeof w == "number" && (_.maxLength = w),
            z && ((_.format = o[z] ?? z), _.format === "" && delete _.format),
            A && (_.contentEncoding = A),
            S && S.size > 0)
          ) {
            let k = [...S];
            k.length === 1
              ? (_.pattern = k[0].source)
              : k.length > 1 &&
                (s.schema.allOf = [
                  ...k.map((g) => ({
                    ...(this.target === "draft-7" ? { type: "string" } : {}),
                    pattern: g.source,
                  })),
                ]);
          }
          break;
        }
        case "number": {
          let _ = d,
            {
              minimum: h,
              maximum: w,
              format: z,
              multipleOf: S,
              exclusiveMaximum: A,
              exclusiveMinimum: k,
            } = r._zod.bag;
          (typeof z == "string" && z.includes("int")
            ? (_.type = "integer")
            : (_.type = "number"),
            typeof k == "number" && (_.exclusiveMinimum = k),
            typeof h == "number" &&
              ((_.minimum = h),
              typeof k == "number" &&
                (k >= h ? delete _.minimum : delete _.exclusiveMinimum)),
            typeof A == "number" && (_.exclusiveMaximum = A),
            typeof w == "number" &&
              ((_.maximum = w),
              typeof A == "number" &&
                (A <= w ? delete _.maximum : delete _.exclusiveMaximum)),
            typeof S == "number" && (_.multipleOf = S));
          break;
        }
        case "boolean": {
          let _ = d;
          _.type = "boolean";
          break;
        }
        case "bigint": {
          if (this.unrepresentable === "throw")
            throw new Error("BigInt cannot be represented in JSON Schema");
          break;
        }
        case "symbol": {
          if (this.unrepresentable === "throw")
            throw new Error("Symbols cannot be represented in JSON Schema");
          break;
        }
        case "undefined": {
          let _ = d;
          _.type = "null";
          break;
        }
        case "null": {
          d.type = "null";
          break;
        }
        case "any":
          break;
        case "unknown":
          break;
        case "never": {
          d.not = {};
          break;
        }
        case "void": {
          if (this.unrepresentable === "throw")
            throw new Error("Void cannot be represented in JSON Schema");
          break;
        }
        case "date": {
          if (this.unrepresentable === "throw")
            throw new Error("Date cannot be represented in JSON Schema");
          break;
        }
        case "array": {
          let _ = d,
            { minimum: h, maximum: w } = r._zod.bag;
          (typeof h == "number" && (_.minItems = h),
            typeof w == "number" && (_.maxItems = w),
            (_.type = "array"),
            (_.items = this.process(t.element, {
              ...u,
              path: [...u.path, "items"],
            })));
          break;
        }
        case "object": {
          let _ = d;
          ((_.type = "object"), (_.properties = {}));
          let h = t.shape;
          for (let S in h)
            _.properties[S] = this.process(h[S], {
              ...u,
              path: [...u.path, "properties", S],
            });
          let w = new Set(Object.keys(h)),
            z = new Set(
              [...w].filter((S) => {
                let A = t.shape[S]._zod;
                return this.io === "input"
                  ? A.optin === void 0
                  : A.optout === void 0;
              }),
            );
          (z.size > 0 && (_.required = Array.from(z)),
            t.catchall?._zod.def.type === "never"
              ? (_.additionalProperties = !1)
              : t.catchall
                ? t.catchall &&
                  (_.additionalProperties = this.process(t.catchall, {
                    ...u,
                    path: [...u.path, "additionalProperties"],
                  }))
                : this.io === "output" && (_.additionalProperties = !1));
          break;
        }
        case "union": {
          let _ = d;
          _.anyOf = t.options.map((h, w) =>
            this.process(h, { ...u, path: [...u.path, "anyOf", w] }),
          );
          break;
        }
        case "intersection": {
          let _ = d,
            h = this.process(t.left, { ...u, path: [...u.path, "allOf", 0] }),
            w = this.process(t.right, { ...u, path: [...u.path, "allOf", 1] }),
            z = (A) => "allOf" in A && Object.keys(A).length === 1,
            S = [...(z(h) ? h.allOf : [h]), ...(z(w) ? w.allOf : [w])];
          _.allOf = S;
          break;
        }
        case "tuple": {
          let _ = d;
          _.type = "array";
          let h = t.items.map((S, A) =>
            this.process(S, { ...u, path: [...u.path, "prefixItems", A] }),
          );
          if (
            (this.target === "draft-2020-12"
              ? (_.prefixItems = h)
              : (_.items = h),
            t.rest)
          ) {
            let S = this.process(t.rest, { ...u, path: [...u.path, "items"] });
            this.target === "draft-2020-12"
              ? (_.items = S)
              : (_.additionalItems = S);
          }
          t.rest &&
            (_.items = this.process(t.rest, {
              ...u,
              path: [...u.path, "items"],
            }));
          let { minimum: w, maximum: z } = r._zod.bag;
          (typeof w == "number" && (_.minItems = w),
            typeof z == "number" && (_.maxItems = z));
          break;
        }
        case "record": {
          let _ = d;
          ((_.type = "object"),
            (_.propertyNames = this.process(t.keyType, {
              ...u,
              path: [...u.path, "propertyNames"],
            })),
            (_.additionalProperties = this.process(t.valueType, {
              ...u,
              path: [...u.path, "additionalProperties"],
            })));
          break;
        }
        case "map": {
          if (this.unrepresentable === "throw")
            throw new Error("Map cannot be represented in JSON Schema");
          break;
        }
        case "set": {
          if (this.unrepresentable === "throw")
            throw new Error("Set cannot be represented in JSON Schema");
          break;
        }
        case "enum": {
          let _ = d,
            h = Ke(t.entries);
          (h.every((w) => typeof w == "number") && (_.type = "number"),
            h.every((w) => typeof w == "string") && (_.type = "string"),
            (_.enum = h));
          break;
        }
        case "literal": {
          let _ = d,
            h = [];
          for (let w of t.values)
            if (w === void 0) {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "Literal `undefined` cannot be represented in JSON Schema",
                );
            } else if (typeof w == "bigint") {
              if (this.unrepresentable === "throw")
                throw new Error(
                  "BigInt literals cannot be represented in JSON Schema",
                );
              h.push(Number(w));
            } else h.push(w);
          if (h.length !== 0)
            if (h.length === 1) {
              let w = h[0];
              ((_.type = w === null ? "null" : typeof w), (_.const = w));
            } else
              (h.every((w) => typeof w == "number") && (_.type = "number"),
                h.every((w) => typeof w == "string") && (_.type = "string"),
                h.every((w) => typeof w == "boolean") && (_.type = "string"),
                h.every((w) => w === null) && (_.type = "null"),
                (_.enum = h));
          break;
        }
        case "file": {
          let _ = d,
            h = { type: "string", format: "binary", contentEncoding: "binary" },
            { minimum: w, maximum: z, mime: S } = r._zod.bag;
          (w !== void 0 && (h.minLength = w),
            z !== void 0 && (h.maxLength = z),
            S
              ? S.length === 1
                ? ((h.contentMediaType = S[0]), Object.assign(_, h))
                : (_.anyOf = S.map((A) => ({ ...h, contentMediaType: A })))
              : Object.assign(_, h));
          break;
        }
        case "transform": {
          if (this.unrepresentable === "throw")
            throw new Error("Transforms cannot be represented in JSON Schema");
          break;
        }
        case "nullable": {
          let _ = this.process(t.innerType, u);
          d.anyOf = [_, { type: "null" }];
          break;
        }
        case "nonoptional": {
          (this.process(t.innerType, u), (s.ref = t.innerType));
          break;
        }
        case "success": {
          let _ = d;
          _.type = "boolean";
          break;
        }
        case "default": {
          (this.process(t.innerType, u),
            (s.ref = t.innerType),
            (d.default = t.defaultValue));
          break;
        }
        case "prefault": {
          (this.process(t.innerType, u),
            (s.ref = t.innerType),
            this.io === "input" && (d._prefault = t.defaultValue));
          break;
        }
        case "catch": {
          (this.process(t.innerType, u), (s.ref = t.innerType));
          let _;
          try {
            _ = t.catchValue(void 0);
          } catch {
            throw new Error(
              "Dynamic catch values are not supported in JSON Schema",
            );
          }
          d.default = _;
          break;
        }
        case "nan": {
          if (this.unrepresentable === "throw")
            throw new Error("NaN cannot be represented in JSON Schema");
          break;
        }
        case "template_literal": {
          let _ = d,
            h = r._zod.pattern;
          if (!h) throw new Error("Pattern not found in template literal");
          ((_.type = "string"), (_.pattern = h.source));
          break;
        }
        case "pipe": {
          let _ =
            this.io === "input"
              ? t.in._zod.def.type === "transform"
                ? t.out
                : t.in
              : t.out;
          (this.process(_, u), (s.ref = _));
          break;
        }
        case "readonly": {
          (this.process(t.innerType, u),
            (s.ref = t.innerType),
            (d.readOnly = !0));
          break;
        }
        case "promise": {
          (this.process(t.innerType, u), (s.ref = t.innerType));
          break;
        }
        case "optional": {
          (this.process(t.innerType, u), (s.ref = t.innerType));
          break;
        }
        case "lazy": {
          let _ = r._zod.innerType;
          (this.process(_, u), (s.ref = _));
          break;
        }
        case "custom": {
          if (this.unrepresentable === "throw")
            throw new Error(
              "Custom types cannot be represented in JSON Schema",
            );
          break;
        }
        default:
      }
    }
    let m = this.metadataRegistry.get(r);
    return (
      m && Object.assign(s.schema, m),
      this.io === "input" &&
        Z(r) &&
        (delete s.schema.examples, delete s.schema.default),
      this.io === "input" &&
        s.schema._prefault &&
        ((i = s.schema).default ?? (i.default = s.schema._prefault)),
      delete s.schema._prefault,
      this.seen.get(r).schema
    );
  }
  emit(r, n) {
    let i = {
        cycles: n?.cycles ?? "ref",
        reused: n?.reused ?? "inline",
        external: n?.external ?? void 0,
      },
      t = this.seen.get(r);
    if (!t) throw new Error("Unprocessed schema. This is a bug in Zod.");
    let o = (m) => {
        let p = this.target === "draft-2020-12" ? "$defs" : "definitions";
        if (i.external) {
          let w = i.external.registry.get(m[0])?.id;
          if (w) return { ref: i.external.uri(w) };
          let z = m[1].defId ?? m[1].schema.id ?? `schema${this.counter++}`;
          return (
            (m[1].defId = z),
            { defId: z, ref: `${i.external.uri("__shared")}#/${p}/${z}` }
          );
        }
        if (m[1] === t) return { ref: "#" };
        let _ = `#/${p}/`,
          h = m[1].schema.id ?? `__schema${this.counter++}`;
        return { defId: h, ref: _ + h };
      },
      a = (m) => {
        if (m[1].schema.$ref) return;
        let p = m[1],
          { ref: d, defId: _ } = o(m);
        ((p.def = { ...p.schema }), _ && (p.defId = _));
        let h = p.schema;
        for (let w in h) delete h[w];
        h.$ref = d;
      };
    for (let m of this.seen.entries()) {
      let p = m[1];
      if (r === m[0]) {
        a(m);
        continue;
      }
      if (i.external) {
        let _ = i.external.registry.get(m[0])?.id;
        if (r !== m[0] && _) {
          a(m);
          continue;
        }
      }
      if (this.metadataRegistry.get(m[0])?.id) {
        a(m);
        continue;
      }
      if (p.cycle) {
        if (i.cycles === "throw")
          throw new Error(`Cycle detected: #/${p.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        i.cycles === "ref" && a(m);
        continue;
      }
      if (p.count > 1 && i.reused === "ref") {
        a(m);
        continue;
      }
    }
    let s = (m, p) => {
      let d = this.seen.get(m),
        _ = d.def ?? d.schema,
        h = { ..._ };
      if (d.ref === null) return;
      let w = d.ref;
      if (((d.ref = null), w)) {
        s(w, p);
        let z = this.seen.get(w).schema;
        z.$ref && p.target === "draft-7"
          ? ((_.allOf = _.allOf ?? []), _.allOf.push(z))
          : (Object.assign(_, z), Object.assign(_, h));
      }
      d.isParent || this.override({ zodSchema: m, jsonSchema: _ });
    };
    for (let m of [...this.seen.entries()].reverse())
      s(m[0], { target: this.target });
    let u = {};
    (this.target === "draft-2020-12"
      ? (u.$schema = "https://json-schema.org/draft/2020-12/schema")
      : this.target === "draft-7"
        ? (u.$schema = "http://json-schema.org/draft-07/schema#")
        : console.warn(`Invalid target: ${this.target}`),
      Object.assign(u, t.def));
    let l = i.external?.defs ?? {};
    for (let m of this.seen.entries()) {
      let p = m[1];
      p.def && p.defId && (l[p.defId] = p.def);
    }
    !i.external &&
      Object.keys(l).length > 0 &&
      (this.target === "draft-2020-12" ? (u.$defs = l) : (u.definitions = l));
    try {
      return JSON.parse(JSON.stringify(u));
    } catch {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function ia(e, r) {
  if (e instanceof je) {
    let i = new zt(r),
      t = {};
    for (let s of e._idmap.entries()) {
      let [u, l] = s;
      i.process(l);
    }
    let o = {},
      a = { registry: e, uri: r?.uri || ((s) => s), defs: t };
    for (let s of e._idmap.entries()) {
      let [u, l] = s;
      o[u] = i.emit(l, { ...r, external: a });
    }
    if (Object.keys(t).length > 0) {
      let s = i.target === "draft-2020-12" ? "$defs" : "definitions";
      o.__shared = { [s]: t };
    }
    return { schemas: o };
  }
  let n = new zt(r);
  return (n.process(e), n.emit(e, r));
}
function Z(e, r) {
  let n = r ?? { seen: new Set() };
  if (n.seen.has(e)) return !1;
  n.seen.add(e);
  let t = e._zod.def;
  switch (t.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return !1;
    case "array":
      return Z(t.element, n);
    case "object": {
      for (let o in t.shape) if (Z(t.shape[o], n)) return !0;
      return !1;
    }
    case "union": {
      for (let o of t.options) if (Z(o, n)) return !0;
      return !1;
    }
    case "intersection":
      return Z(t.left, n) || Z(t.right, n);
    case "tuple": {
      for (let o of t.items) if (Z(o, n)) return !0;
      return !!(t.rest && Z(t.rest, n));
    }
    case "record":
      return Z(t.keyType, n) || Z(t.valueType, n);
    case "map":
      return Z(t.keyType, n) || Z(t.valueType, n);
    case "set":
      return Z(t.valueType, n);
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return Z(t.innerType, n);
    case "lazy":
      return Z(t.getter(), n);
    case "default":
      return Z(t.innerType, n);
    case "prefault":
      return Z(t.innerType, n);
    case "custom":
      return !1;
    case "transform":
      return !0;
    case "pipe":
      return Z(t.in, n) || Z(t.out, n);
    case "success":
      return !1;
    case "catch":
      return !1;
    default:
  }
  throw new Error(`Unknown schema type: ${t.type}`);
}
var _l = {};
var Dr = {};
xe(Dr, {
  ZodISODate: () => Sr,
  ZodISODateTime: () => zr,
  ZodISODuration: () => Pr,
  ZodISOTime: () => Ir,
  date: () => sa,
  datetime: () => aa,
  duration: () => ua,
  time: () => la,
});
var zr = c("ZodISODateTime", (e, r) => {
  (So.init(e, r), R.init(e, r));
});
function aa(e) {
  return xi(zr, e);
}
var Sr = c("ZodISODate", (e, r) => {
  (Io.init(e, r), R.init(e, r));
});
function sa(e) {
  return Ai(Sr, e);
}
var Ir = c("ZodISOTime", (e, r) => {
  (Po.init(e, r), R.init(e, r));
});
function la(e) {
  return ki(Ir, e);
}
var Pr = c("ZodISODuration", (e, r) => {
  (Do.init(e, r), R.init(e, r));
});
function ua(e) {
  return $i(Pr, e);
}
var ml = (e, r) => {
    (nt.init(e, r),
      (e.name = "ZodError"),
      Object.defineProperties(e, {
        format: { value: (n) => it(e, n) },
        flatten: { value: (n) => ot(e, n) },
        addIssue: { value: (n) => e.issues.push(n) },
        addIssues: { value: (n) => e.issues.push(...n) },
        isEmpty: {
          get() {
            return e.issues.length === 0;
          },
        },
      }));
  },
  x_ = c("ZodError", ml),
  Ce = c("ZodError", ml, { Parent: Error });
var ca = Ft(Ce),
  _a = Bt(Ce),
  da = Gt(Ce),
  ma = Ht(Ce);
var T = c(
    "ZodType",
    (e, r) => (
      P.init(e, r),
      (e.def = r),
      Object.defineProperty(e, "_def", { value: r }),
      (e.check = (...n) =>
        e.clone({
          ...r,
          checks: [
            ...(r.checks ?? []),
            ...n.map((i) =>
              typeof i == "function"
                ? { _zod: { check: i, def: { check: "custom" }, onattach: [] } }
                : i,
            ),
          ],
        })),
      (e.clone = (n, i) => Q(e, n, i)),
      (e.brand = () => e),
      (e.register = (n, i) => (n.add(e, i), e)),
      (e.parse = (n, i) => ca(e, n, i, { callee: e.parse })),
      (e.safeParse = (n, i) => da(e, n, i)),
      (e.parseAsync = async (n, i) => _a(e, n, i, { callee: e.parseAsync })),
      (e.safeParseAsync = async (n, i) => ma(e, n, i)),
      (e.spa = e.safeParseAsync),
      (e.refine = (n, i) => e.check(Ql(n, i))),
      (e.superRefine = (n) => e.check(eu(n))),
      (e.overwrite = (n) => e.check(de(n))),
      (e.optional = () => Tr(e)),
      (e.nullable = () => Or(e)),
      (e.nullish = () => Tr(Or(e))),
      (e.nonoptional = (n) => Ll(e, n)),
      (e.array = () => Na(e)),
      (e.or = (n) => Cr([e, n])),
      (e.and = (n) => zl(e, n)),
      (e.transform = (n) => jr(e, Ra(n))),
      (e.default = (n) => Ul(e, n)),
      (e.prefault = (n) => Cl(e, n)),
      (e.catch = (n) => Bl(e, n)),
      (e.pipe = (n) => jr(e, n)),
      (e.readonly = () => Hl(e)),
      (e.describe = (n) => {
        let i = e.clone();
        return (se.add(i, { description: n }), i);
      }),
      Object.defineProperty(e, "description", {
        get() {
          return se.get(e)?.description;
        },
        configurable: !0,
      }),
      (e.meta = (...n) => {
        if (n.length === 0) return se.get(e);
        let i = e.clone();
        return (se.add(i, n[0]), i);
      }),
      (e.isOptional = () => e.safeParse(void 0).success),
      (e.isNullable = () => e.safeParse(null).success),
      e
    ),
  ),
  ga = c("_ZodString", (e, r) => {
    (st.init(e, r), T.init(e, r));
    let n = e._zod.bag;
    ((e.format = n.format ?? null),
      (e.minLength = n.minimum ?? null),
      (e.maxLength = n.maximum ?? null),
      (e.regex = (...i) => e.check(pt(...i))),
      (e.includes = (...i) => e.check(ht(...i))),
      (e.startsWith = (...i) => e.check(vt(...i))),
      (e.endsWith = (...i) => e.check(yt(...i))),
      (e.min = (...i) => e.check(we(...i))),
      (e.max = (...i) => e.check(Ue(...i))),
      (e.length = (...i) => e.check(Re(...i))),
      (e.nonempty = (...i) => e.check(we(1, ...i))),
      (e.lowercase = (i) => e.check(ft(i))),
      (e.uppercase = (i) => e.check(gt(i))),
      (e.trim = () => e.check(xt())),
      (e.normalize = (...i) => e.check(wt(...i))),
      (e.toLowerCase = () => e.check(At())),
      (e.toUpperCase = () => e.check(kt())));
  }),
  Nr = c("ZodString", (e, r) => {
    (st.init(e, r),
      ga.init(e, r),
      (e.email = (n) => e.check(or(ha, n))),
      (e.url = (n) => e.check(ur(va, n))),
      (e.jwt = (n) => e.check(kr(Ta, n))),
      (e.emoji = (n) => e.check(cr(ya, n))),
      (e.guid = (n) => e.check(dt(Er, n))),
      (e.uuid = (n) => e.check(ir(pe, n))),
      (e.uuidv4 = (n) => e.check(ar(pe, n))),
      (e.uuidv6 = (n) => e.check(sr(pe, n))),
      (e.uuidv7 = (n) => e.check(lr(pe, n))),
      (e.nanoid = (n) => e.check(_r(ba, n))),
      (e.guid = (n) => e.check(dt(Er, n))),
      (e.cuid = (n) => e.check(dr(wa, n))),
      (e.cuid2 = (n) => e.check(mr(xa, n))),
      (e.ulid = (n) => e.check(pr(Aa, n))),
      (e.base64 = (n) => e.check(wr(Da, n))),
      (e.base64url = (n) => e.check(xr(Ea, n))),
      (e.xid = (n) => e.check(fr(ka, n))),
      (e.ksuid = (n) => e.check(gr($a, n))),
      (e.ipv4 = (n) => e.check(hr(za, n))),
      (e.ipv6 = (n) => e.check(vr(Sa, n))),
      (e.cidrv4 = (n) => e.check(yr(Ia, n))),
      (e.cidrv6 = (n) => e.check(br(Pa, n))),
      (e.e164 = (n) => e.check(Ar(Va, n))),
      (e.datetime = (n) => e.check(aa(n))),
      (e.date = (n) => e.check(sa(n))),
      (e.time = (n) => e.check(la(n))),
      (e.duration = (n) => e.check(ua(n))));
  });
function pa(e) {
  return bi(Nr, e);
}
var R = c("ZodStringFormat", (e, r) => {
    (M.init(e, r), ga.init(e, r));
  }),
  ha = c("ZodEmail", (e, r) => {
    (vo.init(e, r), R.init(e, r));
  });
function k_(e) {
  return or(ha, e);
}
var Er = c("ZodGUID", (e, r) => {
  (go.init(e, r), R.init(e, r));
});
function $_(e) {
  return dt(Er, e);
}
var pe = c("ZodUUID", (e, r) => {
  (ho.init(e, r), R.init(e, r));
});
function z_(e) {
  return ir(pe, e);
}
function S_(e) {
  return ar(pe, e);
}
function I_(e) {
  return sr(pe, e);
}
function P_(e) {
  return lr(pe, e);
}
var va = c("ZodURL", (e, r) => {
  (yo.init(e, r), R.init(e, r));
});
function D_(e) {
  return ur(va, e);
}
var ya = c("ZodEmoji", (e, r) => {
  (bo.init(e, r), R.init(e, r));
});
function E_(e) {
  return cr(ya, e);
}
var ba = c("ZodNanoID", (e, r) => {
  (wo.init(e, r), R.init(e, r));
});
function V_(e) {
  return _r(ba, e);
}
var wa = c("ZodCUID", (e, r) => {
  (xo.init(e, r), R.init(e, r));
});
function T_(e) {
  return dr(wa, e);
}
var xa = c("ZodCUID2", (e, r) => {
  (Ao.init(e, r), R.init(e, r));
});
function O_(e) {
  return mr(xa, e);
}
var Aa = c("ZodULID", (e, r) => {
  (ko.init(e, r), R.init(e, r));
});
function j_(e) {
  return pr(Aa, e);
}
var ka = c("ZodXID", (e, r) => {
  ($o.init(e, r), R.init(e, r));
});
function N_(e) {
  return fr(ka, e);
}
var $a = c("ZodKSUID", (e, r) => {
  (zo.init(e, r), R.init(e, r));
});
function M_(e) {
  return gr($a, e);
}
var za = c("ZodIPv4", (e, r) => {
  (Eo.init(e, r), R.init(e, r));
});
function U_(e) {
  return hr(za, e);
}
var Sa = c("ZodIPv6", (e, r) => {
  (Vo.init(e, r), R.init(e, r));
});
function R_(e) {
  return vr(Sa, e);
}
var Ia = c("ZodCIDRv4", (e, r) => {
  (To.init(e, r), R.init(e, r));
});
function C_(e) {
  return yr(Ia, e);
}
var Pa = c("ZodCIDRv6", (e, r) => {
  (Oo.init(e, r), R.init(e, r));
});
function L_(e) {
  return br(Pa, e);
}
var Da = c("ZodBase64", (e, r) => {
  (No.init(e, r), R.init(e, r));
});
function F_(e) {
  return wr(Da, e);
}
var Ea = c("ZodBase64URL", (e, r) => {
  (Mo.init(e, r), R.init(e, r));
});
function Z_(e) {
  return xr(Ea, e);
}
var Va = c("ZodE164", (e, r) => {
  (Uo.init(e, r), R.init(e, r));
});
function B_(e) {
  return Ar(Va, e);
}
var Ta = c("ZodJWT", (e, r) => {
  (Ro.init(e, r), R.init(e, r));
});
function q_(e) {
  return kr(Ta, e);
}
var It = c("ZodNumber", (e, r) => {
  (Qt.init(e, r),
    T.init(e, r),
    (e.gt = (i, t) => e.check(_e(i, t))),
    (e.gte = (i, t) => e.check(X(i, t))),
    (e.min = (i, t) => e.check(X(i, t))),
    (e.lt = (i, t) => e.check(ce(i, t))),
    (e.lte = (i, t) => e.check(re(i, t))),
    (e.max = (i, t) => e.check(re(i, t))),
    (e.int = (i) => e.check(fa(i))),
    (e.safe = (i) => e.check(fa(i))),
    (e.positive = (i) => e.check(_e(0, i))),
    (e.nonnegative = (i) => e.check(X(0, i))),
    (e.negative = (i) => e.check(ce(0, i))),
    (e.nonpositive = (i) => e.check(re(0, i))),
    (e.multipleOf = (i, t) => e.check(Ie(i, t))),
    (e.step = (i, t) => e.check(Ie(i, t))),
    (e.finite = () => e));
  let n = e._zod.bag;
  ((e.minValue =
    Math.max(
      n.minimum ?? Number.NEGATIVE_INFINITY,
      n.exclusiveMinimum ?? Number.NEGATIVE_INFINITY,
    ) ?? null),
    (e.maxValue =
      Math.min(
        n.maximum ?? Number.POSITIVE_INFINITY,
        n.exclusiveMaximum ?? Number.POSITIVE_INFINITY,
      ) ?? null),
    (e.isInt =
      (n.format ?? "").includes("int") ||
      Number.isSafeInteger(n.multipleOf ?? 0.5)),
    (e.isFinite = !0),
    (e.format = n.format ?? null));
});
function pl(e) {
  return zi(It, e);
}
var Le = c("ZodNumberFormat", (e, r) => {
  (Co.init(e, r), It.init(e, r));
});
function fa(e) {
  return Ii(Le, e);
}
function G_(e) {
  return Pi(Le, e);
}
function H_(e) {
  return Di(Le, e);
}
function W_(e) {
  return Ei(Le, e);
}
function Y_(e) {
  return Vi(Le, e);
}
var Pt = c("ZodBoolean", (e, r) => {
  (lt.init(e, r), T.init(e, r));
});
function fl(e) {
  return Ti(Pt, e);
}
var Dt = c("ZodBigInt", (e, r) => {
  (er.init(e, r),
    T.init(e, r),
    (e.gte = (i, t) => e.check(X(i, t))),
    (e.min = (i, t) => e.check(X(i, t))),
    (e.gt = (i, t) => e.check(_e(i, t))),
    (e.gte = (i, t) => e.check(X(i, t))),
    (e.min = (i, t) => e.check(X(i, t))),
    (e.lt = (i, t) => e.check(ce(i, t))),
    (e.lte = (i, t) => e.check(re(i, t))),
    (e.max = (i, t) => e.check(re(i, t))),
    (e.positive = (i) => e.check(_e(BigInt(0), i))),
    (e.negative = (i) => e.check(ce(BigInt(0), i))),
    (e.nonpositive = (i) => e.check(re(BigInt(0), i))),
    (e.nonnegative = (i) => e.check(X(BigInt(0), i))),
    (e.multipleOf = (i, t) => e.check(Ie(i, t))));
  let n = e._zod.bag;
  ((e.minValue = n.minimum ?? null),
    (e.maxValue = n.maximum ?? null),
    (e.format = n.format ?? null));
});
function K_(e) {
  return ji(Dt, e);
}
var Oa = c("ZodBigIntFormat", (e, r) => {
  (Lo.init(e, r), Dt.init(e, r));
});
function X_(e) {
  return Mi(Oa, e);
}
function J_(e) {
  return Ui(Oa, e);
}
var gl = c("ZodSymbol", (e, r) => {
  (Fo.init(e, r), T.init(e, r));
});
function Q_(e) {
  return Ri(gl, e);
}
var hl = c("ZodUndefined", (e, r) => {
  (Zo.init(e, r), T.init(e, r));
});
function ed(e) {
  return Ci(hl, e);
}
var vl = c("ZodNull", (e, r) => {
  (Bo.init(e, r), T.init(e, r));
});
function yl(e) {
  return Li(vl, e);
}
var bl = c("ZodAny", (e, r) => {
  (qo.init(e, r), T.init(e, r));
});
function td() {
  return Fi(bl);
}
var ja = c("ZodUnknown", (e, r) => {
  (be.init(e, r), T.init(e, r));
});
function Vr() {
  return Ne(ja);
}
var wl = c("ZodNever", (e, r) => {
  (Go.init(e, r), T.init(e, r));
});
function Mr(e) {
  return Zi(wl, e);
}
var xl = c("ZodVoid", (e, r) => {
  (Ho.init(e, r), T.init(e, r));
});
function rd(e) {
  return Bi(xl, e);
}
var Ur = c("ZodDate", (e, r) => {
  (Wo.init(e, r),
    T.init(e, r),
    (e.min = (i, t) => e.check(X(i, t))),
    (e.max = (i, t) => e.check(re(i, t))));
  let n = e._zod.bag;
  ((e.minDate = n.minimum ? new Date(n.minimum) : null),
    (e.maxDate = n.maximum ? new Date(n.maximum) : null));
});
function nd(e) {
  return qi(Ur, e);
}
var Al = c("ZodArray", (e, r) => {
  (ut.init(e, r),
    T.init(e, r),
    (e.element = r.element),
    (e.min = (n, i) => e.check(we(n, i))),
    (e.nonempty = (n) => e.check(we(1, n))),
    (e.max = (n, i) => e.check(Ue(n, i))),
    (e.length = (n, i) => e.check(Re(n, i))),
    (e.unwrap = () => e.element));
});
function Na(e, r) {
  return $t(Al, e, r);
}
function od(e) {
  let r = e._zod.def.shape;
  return Tl(Object.keys(r));
}
var Rr = c("ZodObject", (e, r) => {
  (Yo.init(e, r),
    T.init(e, r),
    b.defineLazy(e, "shape", () =>
      Object.fromEntries(Object.entries(e._zod.def.shape)),
    ),
    (e.keyof = () => El(Object.keys(e._zod.def.shape))),
    (e.catchall = (n) => e.clone({ ...e._zod.def, catchall: n })),
    (e.passthrough = () => e.clone({ ...e._zod.def, catchall: Vr() })),
    (e.loose = () => e.clone({ ...e._zod.def, catchall: Vr() })),
    (e.strict = () => e.clone({ ...e._zod.def, catchall: Mr() })),
    (e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 })),
    (e.extend = (n) => b.extend(e, n)),
    (e.merge = (n) => b.merge(e, n)),
    (e.pick = (n) => b.pick(e, n)),
    (e.omit = (n) => b.omit(e, n)),
    (e.partial = (...n) => b.partial(Ca, e, n[0])),
    (e.required = (...n) => b.required(La, e, n[0])));
});
function id(e, r) {
  let n = {
    type: "object",
    get shape() {
      return (b.assignProp(this, "shape", { ...e }), this.shape);
    },
    ...b.normalizeParams(r),
  };
  return new Rr(n);
}
function ad(e, r) {
  return new Rr({
    type: "object",
    get shape() {
      return (b.assignProp(this, "shape", { ...e }), this.shape);
    },
    catchall: Mr(),
    ...b.normalizeParams(r),
  });
}
function sd(e, r) {
  return new Rr({
    type: "object",
    get shape() {
      return (b.assignProp(this, "shape", { ...e }), this.shape);
    },
    catchall: Vr(),
    ...b.normalizeParams(r),
  });
}
var Ma = c("ZodUnion", (e, r) => {
  (tr.init(e, r), T.init(e, r), (e.options = r.options));
});
function Cr(e, r) {
  return new Ma({ type: "union", options: e, ...b.normalizeParams(r) });
}
var kl = c("ZodDiscriminatedUnion", (e, r) => {
  (Ma.init(e, r), Ko.init(e, r));
});
function ld(e, r, n) {
  return new kl({
    type: "union",
    options: r,
    discriminator: e,
    ...b.normalizeParams(n),
  });
}
var $l = c("ZodIntersection", (e, r) => {
  (Xo.init(e, r), T.init(e, r));
});
function zl(e, r) {
  return new $l({ type: "intersection", left: e, right: r });
}
var Sl = c("ZodTuple", (e, r) => {
  (Se.init(e, r),
    T.init(e, r),
    (e.rest = (n) => e.clone({ ...e._zod.def, rest: n })));
});
function ud(e, r, n) {
  let i = r instanceof P,
    t = i ? n : r,
    o = i ? r : null;
  return new Sl({ type: "tuple", items: e, rest: o, ...b.normalizeParams(t) });
}
var Ua = c("ZodRecord", (e, r) => {
  (Jo.init(e, r),
    T.init(e, r),
    (e.keyType = r.keyType),
    (e.valueType = r.valueType));
});
function Il(e, r, n) {
  return new Ua({
    type: "record",
    keyType: e,
    valueType: r,
    ...b.normalizeParams(n),
  });
}
function cd(e, r, n) {
  return new Ua({
    type: "record",
    keyType: Cr([e, Mr()]),
    valueType: r,
    ...b.normalizeParams(n),
  });
}
var Pl = c("ZodMap", (e, r) => {
  (Qo.init(e, r),
    T.init(e, r),
    (e.keyType = r.keyType),
    (e.valueType = r.valueType));
});
function _d(e, r, n) {
  return new Pl({
    type: "map",
    keyType: e,
    valueType: r,
    ...b.normalizeParams(n),
  });
}
var Dl = c("ZodSet", (e, r) => {
  (ei.init(e, r),
    T.init(e, r),
    (e.min = (...n) => e.check(Pe(...n))),
    (e.nonempty = (n) => e.check(Pe(1, n))),
    (e.max = (...n) => e.check(Me(...n))),
    (e.size = (...n) => e.check(mt(...n))));
});
function dd(e, r) {
  return new Dl({ type: "set", valueType: e, ...b.normalizeParams(r) });
}
var St = c("ZodEnum", (e, r) => {
  (ti.init(e, r),
    T.init(e, r),
    (e.enum = r.entries),
    (e.options = Object.values(r.entries)));
  let n = new Set(Object.keys(r.entries));
  ((e.extract = (i, t) => {
    let o = {};
    for (let a of i)
      if (n.has(a)) o[a] = r.entries[a];
      else throw new Error(`Key ${a} not found in enum`);
    return new St({ ...r, checks: [], ...b.normalizeParams(t), entries: o });
  }),
    (e.exclude = (i, t) => {
      let o = { ...r.entries };
      for (let a of i)
        if (n.has(a)) delete o[a];
        else throw new Error(`Key ${a} not found in enum`);
      return new St({ ...r, checks: [], ...b.normalizeParams(t), entries: o });
    }));
});
function El(e, r) {
  let n = Array.isArray(e) ? Object.fromEntries(e.map((i) => [i, i])) : e;
  return new St({ type: "enum", entries: n, ...b.normalizeParams(r) });
}
function md(e, r) {
  return new St({ type: "enum", entries: e, ...b.normalizeParams(r) });
}
var Vl = c("ZodLiteral", (e, r) => {
  (ri.init(e, r),
    T.init(e, r),
    (e.values = new Set(r.values)),
    Object.defineProperty(e, "value", {
      get() {
        if (r.values.length > 1)
          throw new Error(
            "This schema contains multiple valid literal values. Use `.values` instead.",
          );
        return r.values[0];
      },
    }));
});
function Tl(e, r) {
  return new Vl({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...b.normalizeParams(r),
  });
}
var Ol = c("ZodFile", (e, r) => {
  (ni.init(e, r),
    T.init(e, r),
    (e.min = (n, i) => e.check(Pe(n, i))),
    (e.max = (n, i) => e.check(Me(n, i))),
    (e.mime = (n, i) => e.check(bt(Array.isArray(n) ? n : [n], i))));
});
function pd(e) {
  return ea(Ol, e);
}
var jl = c("ZodTransform", (e, r) => {
  (oi.init(e, r),
    T.init(e, r),
    (e._zod.parse = (n, i) => {
      n.addIssue = (o) => {
        if (typeof o == "string") n.issues.push(b.issue(o, n.value, r));
        else {
          let a = o;
          (a.fatal && (a.continue = !1),
            a.code ?? (a.code = "custom"),
            a.input ?? (a.input = n.value),
            a.inst ?? (a.inst = e),
            a.continue ?? (a.continue = !0),
            n.issues.push(b.issue(a)));
        }
      };
      let t = r.transform(n.value, n);
      return t instanceof Promise
        ? t.then((o) => ((n.value = o), n))
        : ((n.value = t), n);
    }));
});
function Ra(e) {
  return new jl({ type: "transform", transform: e });
}
var Ca = c("ZodOptional", (e, r) => {
  (ii.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function Tr(e) {
  return new Ca({ type: "optional", innerType: e });
}
var Nl = c("ZodNullable", (e, r) => {
  (ai.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function Or(e) {
  return new Nl({ type: "nullable", innerType: e });
}
function fd(e) {
  return Tr(Or(e));
}
var Ml = c("ZodDefault", (e, r) => {
  (si.init(e, r),
    T.init(e, r),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeDefault = e.unwrap));
});
function Ul(e, r) {
  return new Ml({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof r == "function" ? r() : r;
    },
  });
}
var Rl = c("ZodPrefault", (e, r) => {
  (li.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function Cl(e, r) {
  return new Rl({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof r == "function" ? r() : r;
    },
  });
}
var La = c("ZodNonOptional", (e, r) => {
  (ui.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function Ll(e, r) {
  return new La({ type: "nonoptional", innerType: e, ...b.normalizeParams(r) });
}
var Fl = c("ZodSuccess", (e, r) => {
  (ci.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function gd(e) {
  return new Fl({ type: "success", innerType: e });
}
var Zl = c("ZodCatch", (e, r) => {
  (_i.init(e, r),
    T.init(e, r),
    (e.unwrap = () => e._zod.def.innerType),
    (e.removeCatch = e.unwrap));
});
function Bl(e, r) {
  return new Zl({
    type: "catch",
    innerType: e,
    catchValue: typeof r == "function" ? r : () => r,
  });
}
var ql = c("ZodNaN", (e, r) => {
  (di.init(e, r), T.init(e, r));
});
function hd(e) {
  return Hi(ql, e);
}
var Fa = c("ZodPipe", (e, r) => {
  (ct.init(e, r), T.init(e, r), (e.in = r.in), (e.out = r.out));
});
function jr(e, r) {
  return new Fa({ type: "pipe", in: e, out: r });
}
var Gl = c("ZodReadonly", (e, r) => {
  (mi.init(e, r), T.init(e, r));
});
function Hl(e) {
  return new Gl({ type: "readonly", innerType: e });
}
var Wl = c("ZodTemplateLiteral", (e, r) => {
  (pi.init(e, r), T.init(e, r));
});
function vd(e, r) {
  return new Wl({
    type: "template_literal",
    parts: e,
    ...b.normalizeParams(r),
  });
}
var Yl = c("ZodLazy", (e, r) => {
  (gi.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.getter()));
});
function Kl(e) {
  return new Yl({ type: "lazy", getter: e });
}
var Xl = c("ZodPromise", (e, r) => {
  (fi.init(e, r), T.init(e, r), (e.unwrap = () => e._zod.def.innerType));
});
function yd(e) {
  return new Xl({ type: "promise", innerType: e });
}
var Lr = c("ZodCustom", (e, r) => {
  (hi.init(e, r), T.init(e, r));
});
function Jl(e, r) {
  let n = new L({ check: "custom", ...b.normalizeParams(r) });
  return ((n._zod.check = e), n);
}
function bd(e, r) {
  return ta(Lr, e ?? (() => !0), r);
}
function Ql(e, r = {}) {
  return ra(Lr, e, r);
}
function eu(e, r) {
  let n = Jl(
    (i) => (
      (i.addIssue = (t) => {
        if (typeof t == "string")
          i.issues.push(b.issue(t, i.value, n._zod.def));
        else {
          let o = t;
          (o.fatal && (o.continue = !1),
            o.code ?? (o.code = "custom"),
            o.input ?? (o.input = i.value),
            o.inst ?? (o.inst = n),
            o.continue ?? (o.continue = !n._zod.def.abort),
            i.issues.push(b.issue(o)));
        }
      }),
      e(i.value, i)
    ),
    r,
  );
  return n;
}
function wd(e, r = { error: `Input not instance of ${e.name}` }) {
  let n = new Lr({
    type: "custom",
    check: "custom",
    fn: (i) => i instanceof e,
    abort: !0,
    ...b.normalizeParams(r),
  });
  return ((n._zod.bag.Class = e), n);
}
var xd = (...e) => na({ Pipe: Fa, Boolean: Pt, Unknown: ja }, ...e);
function Ad(e) {
  let r = Kl(() => Cr([pa(e), pl(), fl(), yl(), Na(r), Il(pa(), r)]));
  return r;
}
function kd(e, r) {
  return jr(Ra(e), r);
}
var $d = {
    invalid_type: "invalid_type",
    too_big: "too_big",
    too_small: "too_small",
    invalid_format: "invalid_format",
    not_multiple_of: "not_multiple_of",
    unrecognized_keys: "unrecognized_keys",
    invalid_union: "invalid_union",
    invalid_key: "invalid_key",
    invalid_element: "invalid_element",
    invalid_value: "invalid_value",
    custom: "custom",
  },
  zd = Object.freeze({ status: "aborted" }),
  Sd = zd;
function Id(e) {
  F({ customError: e });
}
function Pd() {
  return F().customError;
}
var Za = {};
xe(Za, {
  bigint: () => Td,
  boolean: () => Vd,
  date: () => Od,
  number: () => Ed,
  string: () => Dd,
});
function Dd(e) {
  return wi(Nr, e);
}
function Ed(e) {
  return Si(It, e);
}
function Vd(e) {
  return Oi(Pt, e);
}
function Td(e) {
  return Ni(Dt, e);
}
function Od(e) {
  return Gi(Ur, e);
}
F(rr());
nn && v.config({ jitless: !0 });
var tu = [
    "ar",
    "bg",
    "ca",
    "co",
    "cs",
    "da",
    "de",
    "dsb",
    "el",
    "en",
    "es",
    "fr",
    "hsb",
    "hu",
    "id",
    "is",
    "it",
    "ja",
    "ko",
    "nb",
    "nl",
    "pl",
    "pt-BR",
    "ro",
    "ru",
    "sk",
    "sl",
    "sv",
    "tr",
    "uk",
    "zh-CN",
    "zh-TW",
  ],
  Fr = [
    "appDesc",
    "restore_purchase_button",
    "get_premium_button",
    "back",
    "rm_notifications_all",
    "waiting_for_media",
    "nomedia_title",
    "nomedia_description",
    "nomedia_reload_button",
    "nomedia_reload_button_tooltip",
    "show_nomedia_button",
    "show_nomedia_button_tooltip",
    "setting_button_tooltip",
    "history_button_tooltip",
    "show_all_history_button",
    "complete_title",
    "hide_complete_button",
    "translate_button_tooltip",
    "help_button_tooltip",
    "open_source_tab_button_tooltip",
    "retry_download_button_tooltip",
    "delete_file_button_tooltip",
    "download_directory_button_tooltip",
    "clear_downloaded_tooltip",
    "show_in_popup_button_tooltip",
    "show_in_sidebar_button_tooltip",
    "video_not_playing_button_tooltip",
    "play",
    "warn_drm_tooltip",
    "version_title",
    "account_title",
    "one_hundred_downloads_title",
    "leave_review_description",
    "leave_review_button",
    "account_status",
    "account_status_premium",
    "free_account",
    "copy_to_clipboard",
    "my_account_button",
    "download_title",
    "show_notification",
    "max_parallel_downloads",
    "saveas_detected_warning",
    "change_saveas_setting",
    "download_directory_title",
    "download_directory_description",
    "change_browser_download_directory",
    "bad_download_subdirectory_warning",
    "download_subdirectory",
    "private_browsing_title",
    "private_browsing_warning",
    "private_browsing_notifications",
    "private_browsing_button",
    "throttle_youtube",
    "prefer_original_audio",
    "prefer_hls",
    "settings_history_title",
    "transient_history_description",
    "history_limit",
    "appearance_title",
    "theme_title",
    "theme_light",
    "theme_dark",
    "theme_system",
    "popup_size_title",
    "popup_size_small",
    "popup_size_medium",
    "popup_size_big",
    "panel_position_title",
    "use_popup",
    "use_sidebar",
    "behavior_title",
    "controls_title",
    "show_in_context_menu",
    "restart_addon",
    "reset_settings",
    "prefered_quality",
    "prefered_quality_highest",
    "prefered_quality_1080p",
    "prefered_quality_720p",
    "prefer_mkv",
    "preview_mode_title",
    "preview_mode_none",
    "preview_mode_video",
    "preview_mode_image",
    "history_title",
    "history_warning",
    "history_warning_2",
    "enable_history",
    "clear_history",
    "disable_history",
    "no_downloads_yet",
    "download_failed",
    "download_failed_description",
    "download_interrupted",
    "download_interrupted_description",
    "download_with_drm_failed_description",
    "no_youtube",
    "no_youtube_description",
    "no_youtube_description_2",
    "premium_required",
    "premium_yt_required_description",
    "premium_hls_required_description",
    "premium_all_required_description",
    "youtube_too_many_downloads",
    "youtube_too_many_downloads_description",
    "stop",
    "cancel",
    "copy_url",
    "always_copy_url",
    "download_button",
    "download_as_button_and_menu",
    "rename_short",
    "always_download_as_menu",
    "download_audio_button",
    "download_audio_and_video_menu",
    "download_audio_only_menu",
    "audio_only_for_this_website",
    "details",
    "report",
    "reporting",
    "reported_thankyou",
    "not_playing_title",
    "not_playing_broken_title",
    "not_playing_broken_description",
    "not_playing_broken_solution_title",
    "not_playing_broken_solution_windows_1",
    "not_playing_broken_solution_mac_1",
    "not_playing_broken_solution_2",
    "not_playing_default_player",
    "not_playing_default_player_solution_windows",
    "not_playing_default_player_solution_mac",
  ],
  Ba = [
    "back",
    "header_help",
    "header_ask_question",
    "activate_title",
    "activate_pending",
    "activate_success",
    "activate_error",
    "activate_no_addon_found",
    "activate_no_method_found",
    "activate_help_me",
    "issue_title",
    "issue_submit",
    "issue_thank_you",
    "issue_enter_email",
    "issue_email_sent",
    "issue_or_digit",
    "issue_just_digit",
    "issue_i_have_a_code",
    "issue_i_have_a_key",
    "issue_key",
    "landing_text1",
    "landing_text2",
    "landing_text3",
    "landing_text4",
    "landing_install_for_google",
    "landing_install_for_mozilla",
    "landing_install_for_microsoft",
    "landing_feature1_title",
    "landing_feature1_description",
    "landing_feature2_title",
    "landing_feature2_description",
    "landing_feature3_title",
    "landing_feature3_description",
    "landing_feature4_title",
    "landing_feature4_description",
    "premium_hero1",
    "premium_hero2",
    "premium_hero3",
    "welcome_text",
    "welcome_pin_message",
  ];
var ub = new Set(tu),
  jd = v.enum(Fr),
  Nd = v.enum(Ba),
  ru = v.map(jd, v.string()),
  nu = v.map(Nd, v.string()),
  cb = new Set(Fr);
var iu = v.templateLiteral(["ded_", v.string()]),
  Ud = v.templateLiteral(["media_hash_", v.number()]),
  ou = v.enum(["download", "download_as", "download_audio", "copy"]),
  Rd = v.enum(["popup", "sidebar"]),
  Ga = v.string().brand("directorypath"),
  Cd = v.strictObject({
    downloaded_id: iu,
    media_hash: Ud,
    path: v.string(),
    browser_download_id: v.number(),
    download_timestamp: v.number(),
    origin_url: v.nullable(v.url()),
    origin_favicon_url: v.nullable(v.url()),
    has_drm: v.boolean(),
    subdir: v.optional(Ga),
  }),
  Ld = v.enum(["SUBSCRIPTION", "LIFETIME", "GOLDEN"]),
  Fd = v.object({
    iat: v.optional(v.number()),
    user_id: v.number(),
    store: v.string().max(256),
    jti: v.string().max(512),
    valid_until: v.number(),
    exp: v.number(),
    developer: v.boolean().optional(),
    entitlement_type: Ld.optional(),
  }),
  Zd = Fd.extend({ raw: v.string() }),
  Bd = v.enum(["original", "user_language"]),
  qd = v.enum(["none", "video", "image"]),
  Gd = v.enum(["system", "light", "dark"]),
  Hd = v.enum(["big", "medium", "small"]),
  Wd = v.strictObject({
    max_length: v.number(),
    template: v.string(),
    force_doc_title: v.optional(v.boolean()),
  }),
  Yd = v.strictObject({
    template: v.string(),
    url: v.string(),
    max_length: v.nullable(v.number()),
    selector: v.nullable(v.string()),
    subdir: v.optional(Ga),
    force_doc_title: v.optional(v.boolean()),
    replace: v.optional(
      v.array(v.strictObject({ from: v.string(), to: v.string() })),
    ),
  }),
  qa = v.strictObject({
    version: v.number(),
    default_action: ou,
    default_action_per_hostname: v.map(v.string(), ou),
    downloaded: v.map(iu, Cd),
    jwt: v.nullable(Zd),
    lsd: v.number(),
    dockmode: Rd,
    download_directory: Ga,
    youtube_throttle: v.boolean(),
    youtube_audio_strategy: Bd,
    youtube_prefer_hls: v.boolean(),
    max_concurrent_downloads: v.number(),
    show_desktop_notifications: v.boolean(),
    show_desktop_notifications_private: v.boolean(),
    history_days: v.number(),
    show_transient_history: v.boolean(),
    ui_theme: Gd,
    use_context_menu: v.boolean(),
    dont_ask_for_user_review: v.boolean(),
    successful_downloads_count: v.number(),
    prefered_quality: v.nullable(v.number()),
    prefered_av_muxer: v.enum(["mp4", "mkv"]),
    hide_nomedia_box: v.boolean(),
    popup_size: Hd,
    smartnaming: v.strictObject({
      source: v.nullable(v.string()),
      compiled: v.strictObject({ default_: Wd, rules: v.array(Yd) }),
    }),
    preview_mode: qd,
    last_migration_request: v.number(),
    custom_strings: v.strictObject({ web: nu, addon: ru }),
  }),
  pb = qa.readonly();
function au(e) {
  let r = Ha();
  if (e && typeof e == "object")
    for (let n of Object.keys(qa.shape)) {
      let i = qa.shape[n];
      if (n in e) {
        let t = e[n],
          o = i.safeParse(t);
        if (o.success) r[n] = o.data;
        else {
          for (let a of o.error.issues)
            (console.warn("Zod issue"),
              console.warn(a.path.join(".")),
              console.warn(a.message));
          (console.warn(o.error.issues),
            console.warn(o.error.type),
            console.warn(o.error.message),
            console.warn(
              `Failed to import past persitent state field: ${n}. Fallback to default. Value was:`,
              t,
            ));
        }
      }
    }
  return r;
}
var Kd = 1710169438e3;
function Ha() {
  return {
    version: 1,
    default_action_per_hostname: new Map(),
    downloaded: new Map(),
    jwt: null,
    lsd: Kd,
    default_action: "download",
    hide_nomedia_box: !0,
    dont_ask_for_user_review: !1,
    dockmode: "popup",
    download_directory: Rt,
    youtube_throttle: !0,
    youtube_audio_strategy: "original",
    youtube_prefer_hls: !0,
    max_concurrent_downloads: 6,
    show_desktop_notifications: !0,
    show_desktop_notifications_private: !1,
    history_days: 0,
    show_transient_history: !0,
    ui_theme: "system",
    use_context_menu: !0,
    prefered_quality: 1080,
    prefered_av_muxer: "mp4",
    popup_size: "medium",
    successful_downloads_count: 0,
    smartnaming: { source: null, compiled: en() },
    preview_mode: "video",
    last_migration_request: 0,
    custom_strings: { addon: new Map(), web: new Map() },
  };
}
function su() {
  return {
    current_win_tab: { tab_id: Y, win_id: Y },
    notifications: new Map(),
    discovered: new Map(),
    downloading: new Map(),
    transient_history: [],
    suspecting_saveas: !1,
  };
}
var Wa = "global_session_state",
  Ya = "global_persistent_state",
  Qd = "session";
async function lu() {
  let e = await Et.storage[Qd].get(Wa);
  if (Wa in e) {
    let r = e[Wa];
    return te(r);
  } else return su();
}
async function uu() {
  let e = await Et.storage.local.get(Ya);
  if (Ya in e) {
    let n = e[Ya];
    return au(te(n));
  }
  let r = Ha();
  {
    let n = await Et.storage.local.get();
    (typeof n.concurrent_downloads_max == "number" &&
      (r.max_concurrent_downloads = n.concurrent_downloads_max),
      typeof n.show_success_notification == "boolean" &&
        (r.show_desktop_notifications = n.show_success_notification),
      typeof n.show_success_notification_for_icognito == "boolean" &&
        (r.show_desktop_notifications =
          n.show_success_notification_for_icognito),
      typeof n.show_context_menu == "boolean" &&
        (r.use_context_menu = n.show_context_menu),
      typeof n.use_sidebar == "boolean" && (r.dockmode = "sidebar"),
      typeof n.theme == "string" &&
        (n.theme == "light" || n.theme == "dark" || n.theme == "system") &&
        (r.ui_theme = n.theme),
      typeof n.record_download_history == "boolean" &&
        n.record_download_history == !0 &&
        typeof n.history_limit_in_days == "number" &&
        (r.history_days = n.history_limit_in_days),
      typeof n.default_action == "string" &&
        (n.default_action == "copy" && (r.default_action = "copy"),
        n.default_action == "download_audio" &&
          (r.default_action = "download_audio")),
      typeof n.never_show_successfull_dl_message == "boolean" &&
        (r.dont_ask_for_user_review = n.never_show_successfull_dl_message),
      (r.smartnaming.compiled = await os()),
      await Et.storage.local.remove([
        "user_sidebar",
        "concurrent_downloads_max",
        "show_success_notification",
        "show_success_notification_for_icognito",
        "show_context_menu",
        "theme",
        "record_download_history",
        "history_limit_in_days",
        "default_action",
        "never_show_successfull_dl_message",
      ]));
  }
  return r;
}
var cu = new URL(document.location.toString()).searchParams,
  em = cu.get("tab_id") ?? "",
  _u = cu.get("media_hash") ?? "",
  tm = await lu(),
  Zr = await uu(),
  du = tm.discovered.get(parseInt(em)),
  N = du?.media.get(_u),
  fe = du?.meta.unwrapOr(null);
if (fe && N) {
  let e = (i) => i.href,
    { basename: r, subdir: n } = tn(N, fe);
  (B("Tab", `${fe.tab_id} (incognito: ${fe.incognito})`),
    B("Basename", r),
    B("SubDir", n),
    B("Hash", _u),
    B(
      "Page URL",
      `${fe.url.map(e).unwrapOr("none")} with ${[...N.sent_headers.values()].length} headers`,
    ),
    B("Thumbnail", fe.thumbnail_url.map(e).unwrapOr("none")),
    B("Type", N.type),
    B("DRM Protected", `${N.has_drm}`),
    "duration" in N && B("Duration", N.duration.toString()),
    "demuxer" in N && B("Demuxer", N.demuxer),
    "extension" in N && B("Extension", N.extension),
    "url" in N
      ? B("Media URL", N.url.href)
      : N.type == "m3u8_playlist" && B("Master URL", N.master_url.href),
    (N.type == "m3u8_playlist" || N.type == "youtube_format") && rm(N));
  for (let [i, t] of [...N.sent_headers.entries()]) B(i, t);
}
function rm(e) {
  let r = 0;
  for (let n of e.playlist.values()) {
    (n.av.video &&
      ("url" in n.av.video
        ? B(`#${r} video component`, n.av.video.url.href)
        : B(`#${r} video component`, n.av.video.href)),
      n.av.audio &&
        ("url" in n.av.audio
          ? B(`#${r} audio component`, n.av.audio.url.href)
          : B(`#${r} audio component`, n.av.audio.href)));
    let i = n.demuxer;
    ((i += " b:" + n.quality.bitrate),
      (i +=
        " p:" +
        n.quality.size.map((t) => `${t.width}x${t.height}`).unwrapOr("none")),
      B(`#${r} core media`, i),
      r++);
  }
}
function B(e, r, n) {
  let i = document.querySelector("tbody"),
    t = document.createElement("tr"),
    o = document.createElement("th"),
    a = document.createElement("td");
  (t.appendChild(o),
    t.appendChild(a),
    (o.textContent = e),
    (a.textContent = r),
    n && t.classList.add("separator"),
    i.appendChild(t));
}
if (N && fe) {
  let e,
    { basename: r, subdir: n } = tn(N, fe),
    i = N.is_youtube && Zr.youtube_throttle;
  if (
    N.type == "m3u8_playlist" ||
    N.type == "youtube_format" ||
    N.type == "mpd_playlist"
  ) {
    let s = ts(N, Zr.prefered_quality);
    e = rn(N, !1, !1, Zr.prefered_av_muxer, r, n, s, i);
  } else e = rn(N, !1, !1, Zr.prefered_av_muxer, r, n, void 0, i);
  let t = new Tt(),
    o = `libav-${Vt.VER}-${Vt.CONFIG}.wasm.wasm`,
    a = await Vt.LibAV({
      noworker: !0,
      base: "/download_worker/",
      wasmurl: `../download_worker/${o}`,
    });
  ((a.onwrite = t.onwrite.bind(t)),
    (window.debug = { libav: a, meta: fe, media: N, args: e }),
    await a.ffmpeg("-version"));
}
/*! Bundled license information:

smol-toml/dist/error.js:
smol-toml/dist/util.js:
smol-toml/dist/date.js:
smol-toml/dist/primitive.js:
smol-toml/dist/extract.js:
smol-toml/dist/struct.js:
smol-toml/dist/parse.js:
smol-toml/dist/stringify.js:
smol-toml/dist/index.js:
  (*!
   * Copyright (c) Squirrel Chat et al., All rights reserved.
   * SPDX-License-Identifier: BSD-3-Clause
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are met:
   *
   * 1. Redistributions of source code must retain the above copyright notice, this
   *    list of conditions and the following disclaimer.
   * 2. Redistributions in binary form must reproduce the above copyright notice,
   *    this list of conditions and the following disclaimer in the
   *    documentation and/or other materials provided with the distribution.
   * 3. Neither the name of the copyright holder nor the names of its contributors
   *    may be used to endorse or promote products derived from this software without
   *    specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
   * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
   * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
   * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
   * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   *)
*/
